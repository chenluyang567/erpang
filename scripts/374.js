(self.webpackChunkdesigner = self.webpackChunkdesigner || []).push([[374], {
  95766: function (t, e) { "use strict"; e.byteLength = function (t) { var e = o(t), n = e[0], r = e[1]; return 3 * (n + r) / 4 - r }, e.toByteArray = function (t) { var e, n, a = o(t), s = a[0], c = a[1], l = new i(function (t, e, n) { return 3 * (e + n) / 4 - n }(0, s, c)), f = 0, d = c > 0 ? s - 4 : s; for (n = 0; n < d; n += 4)e = r[t.charCodeAt(n)] << 18 | r[t.charCodeAt(n + 1)] << 12 | r[t.charCodeAt(n + 2)] << 6 | r[t.charCodeAt(n + 3)], l[f++] = e >> 16 & 255, l[f++] = e >> 8 & 255, l[f++] = 255 & e; 2 === c && (e = r[t.charCodeAt(n)] << 2 | r[t.charCodeAt(n + 1)] >> 4, l[f++] = 255 & e); 1 === c && (e = r[t.charCodeAt(n)] << 10 | r[t.charCodeAt(n + 1)] << 4 | r[t.charCodeAt(n + 2)] >> 2, l[f++] = e >> 8 & 255, l[f++] = 255 & e); return l }, e.fromByteArray = function (t) { for (var e, r = t.length, i = r % 3, a = [], s = 16383, o = 0, l = r - i; o < l; o += s)a.push(c(t, o, o + s > l ? l : o + s)); 1 === i ? (e = t[r - 1], a.push(n[e >> 2] + n[e << 4 & 63] + "==")) : 2 === i && (e = (t[r - 2] << 8) + t[r - 1], a.push(n[e >> 10] + n[e >> 4 & 63] + n[e << 2 & 63] + "=")); return a.join("") }; for (var n = [], r = [], i = "undefined" != typeof Uint8Array ? Uint8Array : Array, a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = 0; s < 64; ++s)n[s] = a[s], r[a.charCodeAt(s)] = s; function o(t) { var e = t.length; if (e % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4"); var n = t.indexOf("="); return -1 === n && (n = e), [n, n === e ? 0 : 4 - n % 4] } function c(t, e, r) { for (var i, a, s = [], o = e; o < r; o += 3)i = (t[o] << 16 & 16711680) + (t[o + 1] << 8 & 65280) + (255 & t[o + 2]), s.push(n[(a = i) >> 18 & 63] + n[a >> 12 & 63] + n[a >> 6 & 63] + n[63 & a]); return s.join("") } r["-".charCodeAt(0)] = 62, r["_".charCodeAt(0)] = 63 }, 48834: function (t, e, n) {
    "use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */const r = n(95766), i = n(62333), a = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null; e.Buffer = c, e.SlowBuffer = function (t) { +t != t && (t = 0); return c.alloc(+t) }, e.INSPECT_MAX_BYTES = 50; const s = 2147483647; function o(t) { if (t > s) throw new RangeError('The value "' + t + '" is invalid for option "size"'); const e = new Uint8Array(t); return Object.setPrototypeOf(e, c.prototype), e } function c(t, e, n) { if ("number" == typeof t) { if ("string" == typeof e) throw new TypeError('The "string" argument must be of type string. Received type number'); return d(t) } return l(t, e, n) } function l(t, e, n) { if ("string" == typeof t) return function (t, e) { "string" == typeof e && "" !== e || (e = "utf8"); if (!c.isEncoding(e)) throw new TypeError("Unknown encoding: " + e); const n = 0 | g(t, e); let r = o(n); const i = r.write(t, e); i !== n && (r = r.slice(0, i)); return r }(t, e); if (ArrayBuffer.isView(t)) return function (t) { if (G(t, Uint8Array)) { const e = new Uint8Array(t); return h(e.buffer, e.byteOffset, e.byteLength) } return u(t) }(t); if (null == t) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t); if (G(t, ArrayBuffer) || t && G(t.buffer, ArrayBuffer)) return h(t, e, n); if ("undefined" != typeof SharedArrayBuffer && (G(t, SharedArrayBuffer) || t && G(t.buffer, SharedArrayBuffer))) return h(t, e, n); if ("number" == typeof t) throw new TypeError('The "value" argument must not be of type number. Received type number'); const r = t.valueOf && t.valueOf(); if (null != r && r !== t) return c.from(r, e, n); const i = function (t) { if (c.isBuffer(t)) { const e = 0 | p(t.length), n = o(e); return 0 === n.length || t.copy(n, 0, 0, e), n } if (void 0 !== t.length) return "number" != typeof t.length || K(t.length) ? o(0) : u(t); if ("Buffer" === t.type && Array.isArray(t.data)) return u(t.data) }(t); if (i) return i; if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof t[Symbol.toPrimitive]) return c.from(t[Symbol.toPrimitive]("string"), e, n); throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t) } function f(t) { if ("number" != typeof t) throw new TypeError('"size" argument must be of type number'); if (t < 0) throw new RangeError('The value "' + t + '" is invalid for option "size"') } function d(t) { return f(t), o(t < 0 ? 0 : 0 | p(t)) } function u(t) { const e = t.length < 0 ? 0 : 0 | p(t.length), n = o(e); for (let r = 0; r < e; r += 1)n[r] = 255 & t[r]; return n } function h(t, e, n) { if (e < 0 || t.byteLength < e) throw new RangeError('"offset" is outside of buffer bounds'); if (t.byteLength < e + (n || 0)) throw new RangeError('"length" is outside of buffer bounds'); let r; return r = void 0 === e && void 0 === n ? new Uint8Array(t) : void 0 === n ? new Uint8Array(t, e) : new Uint8Array(t, e, n), Object.setPrototypeOf(r, c.prototype), r } function p(t) { if (t >= s) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s.toString(16) + " bytes"); return 0 | t } function g(t, e) { if (c.isBuffer(t)) return t.length; if (ArrayBuffer.isView(t) || G(t, ArrayBuffer)) return t.byteLength; if ("string" != typeof t) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t); const n = t.length, r = arguments.length > 2 && !0 === arguments[2]; if (!r && 0 === n) return 0; let i = !1; for (; ;)switch (e) { case "ascii": case "latin1": case "binary": return n; case "utf8": case "utf-8": return W(t).length; case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return 2 * n; case "hex": return n >>> 1; case "base64": return $(t).length; default: if (i) return r ? -1 : W(t).length; e = ("" + e).toLowerCase(), i = !0 } } function m(t, e, n) { let r = !1; if ((void 0 === e || e < 0) && (e = 0), e > this.length) return ""; if ((void 0 === n || n > this.length) && (n = this.length), n <= 0) return ""; if ((n >>>= 0) <= (e >>>= 0)) return ""; for (t || (t = "utf8"); ;)switch (t) { case "hex": return U(this, e, n); case "utf8": case "utf-8": return S(this, e, n); case "ascii": return z(this, e, n); case "latin1": case "binary": return C(this, e, n); case "base64": return A(this, e, n); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return I(this, e, n); default: if (r) throw new TypeError("Unknown encoding: " + t); t = (t + "").toLowerCase(), r = !0 } } function b(t, e, n) { const r = t[e]; t[e] = t[n], t[n] = r } function w(t, e, n, r, i) { if (0 === t.length) return -1; if ("string" == typeof n ? (r = n, n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648), K(n = +n) && (n = i ? 0 : t.length - 1), n < 0 && (n = t.length + n), n >= t.length) { if (i) return -1; n = t.length - 1 } else if (n < 0) { if (!i) return -1; n = 0 } if ("string" == typeof e && (e = c.from(e, r)), c.isBuffer(e)) return 0 === e.length ? -1 : y(t, e, n, r, i); if ("number" == typeof e) return e &= 255, "function" == typeof Uint8Array.prototype.indexOf ? i ? Uint8Array.prototype.indexOf.call(t, e, n) : Uint8Array.prototype.lastIndexOf.call(t, e, n) : y(t, [e], n, r, i); throw new TypeError("val must be string, number or Buffer") } function y(t, e, n, r, i) { let a, s = 1, o = t.length, c = e.length; if (void 0 !== r && ("ucs2" === (r = String(r).toLowerCase()) || "ucs-2" === r || "utf16le" === r || "utf-16le" === r)) { if (t.length < 2 || e.length < 2) return -1; s = 2, o /= 2, c /= 2, n /= 2 } function l(t, e) { return 1 === s ? t[e] : t.readUInt16BE(e * s) } if (i) { let r = -1; for (a = n; a < o; a++)if (l(t, a) === l(e, -1 === r ? 0 : a - r)) { if (-1 === r && (r = a), a - r + 1 === c) return r * s } else -1 !== r && (a -= a - r), r = -1 } else for (n + c > o && (n = o - c), a = n; a >= 0; a--) { let n = !0; for (let r = 0; r < c; r++)if (l(t, a + r) !== l(e, r)) { n = !1; break } if (n) return a } return -1 } function v(t, e, n, r) { n = Number(n) || 0; const i = t.length - n; r ? (r = Number(r)) > i && (r = i) : r = i; const a = e.length; let s; for (r > a / 2 && (r = a / 2), s = 0; s < r; ++s) { const r = parseInt(e.substr(2 * s, 2), 16); if (K(r)) return s; t[n + s] = r } return s } function _(t, e, n, r) { return Q(W(e, t.length - n), t, n, r) } function x(t, e, n, r) { return Q(function (t) { const e = []; for (let n = 0; n < t.length; ++n)e.push(255 & t.charCodeAt(n)); return e }(e), t, n, r) } function k(t, e, n, r) { return Q($(e), t, n, r) } function E(t, e, n, r) { return Q(function (t, e) { let n, r, i; const a = []; for (let s = 0; s < t.length && !((e -= 2) < 0); ++s)n = t.charCodeAt(s), r = n >> 8, i = n % 256, a.push(i), a.push(r); return a }(e, t.length - n), t, n, r) } function A(t, e, n) { return 0 === e && n === t.length ? r.fromByteArray(t) : r.fromByteArray(t.slice(e, n)) } function S(t, e, n) { n = Math.min(t.length, n); const r = []; let i = e; for (; i < n;) { const e = t[i]; let a = null, s = e > 239 ? 4 : e > 223 ? 3 : e > 191 ? 2 : 1; if (i + s <= n) { let n, r, o, c; switch (s) { case 1: e < 128 && (a = e); break; case 2: n = t[i + 1], 128 == (192 & n) && (c = (31 & e) << 6 | 63 & n, c > 127 && (a = c)); break; case 3: n = t[i + 1], r = t[i + 2], 128 == (192 & n) && 128 == (192 & r) && (c = (15 & e) << 12 | (63 & n) << 6 | 63 & r, c > 2047 && (c < 55296 || c > 57343) && (a = c)); break; case 4: n = t[i + 1], r = t[i + 2], o = t[i + 3], 128 == (192 & n) && 128 == (192 & r) && 128 == (192 & o) && (c = (15 & e) << 18 | (63 & n) << 12 | (63 & r) << 6 | 63 & o, c > 65535 && c < 1114112 && (a = c)) } } null === a ? (a = 65533, s = 1) : a > 65535 && (a -= 65536, r.push(a >>> 10 & 1023 | 55296), a = 56320 | 1023 & a), r.push(a), i += s } return function (t) { const e = t.length; if (e <= B) return String.fromCharCode.apply(String, t); let n = "", r = 0; for (; r < e;)n += String.fromCharCode.apply(String, t.slice(r, r += B)); return n }(r) } e.kMaxLength = s, c.TYPED_ARRAY_SUPPORT = function () { try { const t = new Uint8Array(1), e = { foo: function () { return 42 } }; return Object.setPrototypeOf(e, Uint8Array.prototype), Object.setPrototypeOf(t, e), 42 === t.foo() } catch (t) { return !1 } }(), c.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(c.prototype, "parent", { enumerable: !0, get: function () { if (c.isBuffer(this)) return this.buffer } }), Object.defineProperty(c.prototype, "offset", { enumerable: !0, get: function () { if (c.isBuffer(this)) return this.byteOffset } }), c.poolSize = 8192, c.from = function (t, e, n) { return l(t, e, n) }, Object.setPrototypeOf(c.prototype, Uint8Array.prototype), Object.setPrototypeOf(c, Uint8Array), c.alloc = function (t, e, n) { return function (t, e, n) { return f(t), t <= 0 ? o(t) : void 0 !== e ? "string" == typeof n ? o(t).fill(e, n) : o(t).fill(e) : o(t) }(t, e, n) }, c.allocUnsafe = function (t) { return d(t) }, c.allocUnsafeSlow = function (t) { return d(t) }, c.isBuffer = function (t) { return null != t && !0 === t._isBuffer && t !== c.prototype }, c.compare = function (t, e) { if (G(t, Uint8Array) && (t = c.from(t, t.offset, t.byteLength)), G(e, Uint8Array) && (e = c.from(e, e.offset, e.byteLength)), !c.isBuffer(t) || !c.isBuffer(e)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'); if (t === e) return 0; let n = t.length, r = e.length; for (let i = 0, a = Math.min(n, r); i < a; ++i)if (t[i] !== e[i]) { n = t[i], r = e[i]; break } return n < r ? -1 : r < n ? 1 : 0 }, c.isEncoding = function (t) { switch (String(t).toLowerCase()) { case "hex": case "utf8": case "utf-8": case "ascii": case "latin1": case "binary": case "base64": case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return !0; default: return !1 } }, c.concat = function (t, e) { if (!Array.isArray(t)) throw new TypeError('"list" argument must be an Array of Buffers'); if (0 === t.length) return c.alloc(0); let n; if (void 0 === e) for (e = 0, n = 0; n < t.length; ++n)e += t[n].length; const r = c.allocUnsafe(e); let i = 0; for (n = 0; n < t.length; ++n) { let e = t[n]; if (G(e, Uint8Array)) i + e.length > r.length ? (c.isBuffer(e) || (e = c.from(e)), e.copy(r, i)) : Uint8Array.prototype.set.call(r, e, i); else { if (!c.isBuffer(e)) throw new TypeError('"list" argument must be an Array of Buffers'); e.copy(r, i) } i += e.length } return r }, c.byteLength = g, c.prototype._isBuffer = !0, c.prototype.swap16 = function () { const t = this.length; if (t % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits"); for (let e = 0; e < t; e += 2)b(this, e, e + 1); return this }, c.prototype.swap32 = function () { const t = this.length; if (t % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits"); for (let e = 0; e < t; e += 4)b(this, e, e + 3), b(this, e + 1, e + 2); return this }, c.prototype.swap64 = function () { const t = this.length; if (t % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits"); for (let e = 0; e < t; e += 8)b(this, e, e + 7), b(this, e + 1, e + 6), b(this, e + 2, e + 5), b(this, e + 3, e + 4); return this }, c.prototype.toString = function () { const t = this.length; return 0 === t ? "" : 0 === arguments.length ? S(this, 0, t) : m.apply(this, arguments) }, c.prototype.toLocaleString = c.prototype.toString, c.prototype.equals = function (t) { if (!c.isBuffer(t)) throw new TypeError("Argument must be a Buffer"); return this === t || 0 === c.compare(this, t) }, c.prototype.inspect = function () { let t = ""; const n = e.INSPECT_MAX_BYTES; return t = this.toString("hex", 0, n).replace(/(.{2})/g, "$1 ").trim(), this.length > n && (t += " ... "), "<Buffer " + t + ">" }, a && (c.prototype[a] = c.prototype.inspect), c.prototype.compare = function (t, e, n, r, i) { if (G(t, Uint8Array) && (t = c.from(t, t.offset, t.byteLength)), !c.isBuffer(t)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t); if (void 0 === e && (e = 0), void 0 === n && (n = t ? t.length : 0), void 0 === r && (r = 0), void 0 === i && (i = this.length), e < 0 || n > t.length || r < 0 || i > this.length) throw new RangeError("out of range index"); if (r >= i && e >= n) return 0; if (r >= i) return -1; if (e >= n) return 1; if (this === t) return 0; let a = (i >>>= 0) - (r >>>= 0), s = (n >>>= 0) - (e >>>= 0); const o = Math.min(a, s), l = this.slice(r, i), f = t.slice(e, n); for (let t = 0; t < o; ++t)if (l[t] !== f[t]) { a = l[t], s = f[t]; break } return a < s ? -1 : s < a ? 1 : 0 }, c.prototype.includes = function (t, e, n) { return -1 !== this.indexOf(t, e, n) }, c.prototype.indexOf = function (t, e, n) { return w(this, t, e, n, !0) }, c.prototype.lastIndexOf = function (t, e, n) { return w(this, t, e, n, !1) }, c.prototype.write = function (t, e, n, r) { if (void 0 === e) r = "utf8", n = this.length, e = 0; else if (void 0 === n && "string" == typeof e) r = e, n = this.length, e = 0; else { if (!isFinite(e)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported"); e >>>= 0, isFinite(n) ? (n >>>= 0, void 0 === r && (r = "utf8")) : (r = n, n = void 0) } const i = this.length - e; if ((void 0 === n || n > i) && (n = i), t.length > 0 && (n < 0 || e < 0) || e > this.length) throw new RangeError("Attempt to write outside buffer bounds"); r || (r = "utf8"); let a = !1; for (; ;)switch (r) { case "hex": return v(this, t, e, n); case "utf8": case "utf-8": return _(this, t, e, n); case "ascii": case "latin1": case "binary": return x(this, t, e, n); case "base64": return k(this, t, e, n); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return E(this, t, e, n); default: if (a) throw new TypeError("Unknown encoding: " + r); r = ("" + r).toLowerCase(), a = !0 } }, c.prototype.toJSON = function () { return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) } }; const B = 4096; function z(t, e, n) { let r = ""; n = Math.min(t.length, n); for (let i = e; i < n; ++i)r += String.fromCharCode(127 & t[i]); return r } function C(t, e, n) { let r = ""; n = Math.min(t.length, n); for (let i = e; i < n; ++i)r += String.fromCharCode(t[i]); return r } function U(t, e, n) { const r = t.length; (!e || e < 0) && (e = 0), (!n || n < 0 || n > r) && (n = r); let i = ""; for (let r = e; r < n; ++r)i += J[t[r]]; return i } function I(t, e, n) { const r = t.slice(e, n); let i = ""; for (let t = 0; t < r.length - 1; t += 2)i += String.fromCharCode(r[t] + 256 * r[t + 1]); return i } function T(t, e, n) { if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint"); if (t + e > n) throw new RangeError("Trying to access beyond buffer length") } function N(t, e, n, r, i, a) { if (!c.isBuffer(t)) throw new TypeError('"buffer" argument must be a Buffer instance'); if (e > i || e < a) throw new RangeError('"value" argument is out of bounds'); if (n + r > t.length) throw new RangeError("Index out of range") } function j(t, e, n, r, i) { V(e, r, i, t, n, 7); let a = Number(e & BigInt(4294967295)); t[n++] = a, a >>= 8, t[n++] = a, a >>= 8, t[n++] = a, a >>= 8, t[n++] = a; let s = Number(e >> BigInt(32) & BigInt(4294967295)); return t[n++] = s, s >>= 8, t[n++] = s, s >>= 8, t[n++] = s, s >>= 8, t[n++] = s, n } function O(t, e, n, r, i) { V(e, r, i, t, n, 7); let a = Number(e & BigInt(4294967295)); t[n + 7] = a, a >>= 8, t[n + 6] = a, a >>= 8, t[n + 5] = a, a >>= 8, t[n + 4] = a; let s = Number(e >> BigInt(32) & BigInt(4294967295)); return t[n + 3] = s, s >>= 8, t[n + 2] = s, s >>= 8, t[n + 1] = s, s >>= 8, t[n] = s, n + 8 } function D(t, e, n, r, i, a) { if (n + r > t.length) throw new RangeError("Index out of range"); if (n < 0) throw new RangeError("Index out of range") } function M(t, e, n, r, a) { return e = +e, n >>>= 0, a || D(t, 0, n, 4), i.write(t, e, n, r, 23, 4), n + 4 } function R(t, e, n, r, a) { return e = +e, n >>>= 0, a || D(t, 0, n, 8), i.write(t, e, n, r, 52, 8), n + 8 } c.prototype.slice = function (t, e) { const n = this.length; (t = ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n), (e = void 0 === e ? n : ~~e) < 0 ? (e += n) < 0 && (e = 0) : e > n && (e = n), e < t && (e = t); const r = this.subarray(t, e); return Object.setPrototypeOf(r, c.prototype), r }, c.prototype.readUintLE = c.prototype.readUIntLE = function (t, e, n) { t >>>= 0, e >>>= 0, n || T(t, e, this.length); let r = this[t], i = 1, a = 0; for (; ++a < e && (i *= 256);)r += this[t + a] * i; return r }, c.prototype.readUintBE = c.prototype.readUIntBE = function (t, e, n) { t >>>= 0, e >>>= 0, n || T(t, e, this.length); let r = this[t + --e], i = 1; for (; e > 0 && (i *= 256);)r += this[t + --e] * i; return r }, c.prototype.readUint8 = c.prototype.readUInt8 = function (t, e) { return t >>>= 0, e || T(t, 1, this.length), this[t] }, c.prototype.readUint16LE = c.prototype.readUInt16LE = function (t, e) { return t >>>= 0, e || T(t, 2, this.length), this[t] | this[t + 1] << 8 }, c.prototype.readUint16BE = c.prototype.readUInt16BE = function (t, e) { return t >>>= 0, e || T(t, 2, this.length), this[t] << 8 | this[t + 1] }, c.prototype.readUint32LE = c.prototype.readUInt32LE = function (t, e) { return t >>>= 0, e || T(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3] }, c.prototype.readUint32BE = c.prototype.readUInt32BE = function (t, e) { return t >>>= 0, e || T(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]) }, c.prototype.readBigUInt64LE = X((function (t) { Z(t >>>= 0, "offset"); const e = this[t], n = this[t + 7]; void 0 !== e && void 0 !== n || q(t, this.length - 8); const r = e + 256 * this[++t] + 65536 * this[++t] + this[++t] * 2 ** 24, i = this[++t] + 256 * this[++t] + 65536 * this[++t] + n * 2 ** 24; return BigInt(r) + (BigInt(i) << BigInt(32)) })), c.prototype.readBigUInt64BE = X((function (t) { Z(t >>>= 0, "offset"); const e = this[t], n = this[t + 7]; void 0 !== e && void 0 !== n || q(t, this.length - 8); const r = e * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + this[++t], i = this[++t] * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + n; return (BigInt(r) << BigInt(32)) + BigInt(i) })), c.prototype.readIntLE = function (t, e, n) { t >>>= 0, e >>>= 0, n || T(t, e, this.length); let r = this[t], i = 1, a = 0; for (; ++a < e && (i *= 256);)r += this[t + a] * i; return i *= 128, r >= i && (r -= Math.pow(2, 8 * e)), r }, c.prototype.readIntBE = function (t, e, n) { t >>>= 0, e >>>= 0, n || T(t, e, this.length); let r = e, i = 1, a = this[t + --r]; for (; r > 0 && (i *= 256);)a += this[t + --r] * i; return i *= 128, a >= i && (a -= Math.pow(2, 8 * e)), a }, c.prototype.readInt8 = function (t, e) { return t >>>= 0, e || T(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t] }, c.prototype.readInt16LE = function (t, e) { t >>>= 0, e || T(t, 2, this.length); const n = this[t] | this[t + 1] << 8; return 32768 & n ? 4294901760 | n : n }, c.prototype.readInt16BE = function (t, e) { t >>>= 0, e || T(t, 2, this.length); const n = this[t + 1] | this[t] << 8; return 32768 & n ? 4294901760 | n : n }, c.prototype.readInt32LE = function (t, e) { return t >>>= 0, e || T(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24 }, c.prototype.readInt32BE = function (t, e) { return t >>>= 0, e || T(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3] }, c.prototype.readBigInt64LE = X((function (t) { Z(t >>>= 0, "offset"); const e = this[t], n = this[t + 7]; void 0 !== e && void 0 !== n || q(t, this.length - 8); const r = this[t + 4] + 256 * this[t + 5] + 65536 * this[t + 6] + (n << 24); return (BigInt(r) << BigInt(32)) + BigInt(e + 256 * this[++t] + 65536 * this[++t] + this[++t] * 2 ** 24) })), c.prototype.readBigInt64BE = X((function (t) { Z(t >>>= 0, "offset"); const e = this[t], n = this[t + 7]; void 0 !== e && void 0 !== n || q(t, this.length - 8); const r = (e << 24) + 65536 * this[++t] + 256 * this[++t] + this[++t]; return (BigInt(r) << BigInt(32)) + BigInt(this[++t] * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + n) })), c.prototype.readFloatLE = function (t, e) { return t >>>= 0, e || T(t, 4, this.length), i.read(this, t, !0, 23, 4) }, c.prototype.readFloatBE = function (t, e) { return t >>>= 0, e || T(t, 4, this.length), i.read(this, t, !1, 23, 4) }, c.prototype.readDoubleLE = function (t, e) { return t >>>= 0, e || T(t, 8, this.length), i.read(this, t, !0, 52, 8) }, c.prototype.readDoubleBE = function (t, e) { return t >>>= 0, e || T(t, 8, this.length), i.read(this, t, !1, 52, 8) }, c.prototype.writeUintLE = c.prototype.writeUIntLE = function (t, e, n, r) { if (t = +t, e >>>= 0, n >>>= 0, !r) { N(this, t, e, n, Math.pow(2, 8 * n) - 1, 0) } let i = 1, a = 0; for (this[e] = 255 & t; ++a < n && (i *= 256);)this[e + a] = t / i & 255; return e + n }, c.prototype.writeUintBE = c.prototype.writeUIntBE = function (t, e, n, r) { if (t = +t, e >>>= 0, n >>>= 0, !r) { N(this, t, e, n, Math.pow(2, 8 * n) - 1, 0) } let i = n - 1, a = 1; for (this[e + i] = 255 & t; --i >= 0 && (a *= 256);)this[e + i] = t / a & 255; return e + n }, c.prototype.writeUint8 = c.prototype.writeUInt8 = function (t, e, n) { return t = +t, e >>>= 0, n || N(this, t, e, 1, 255, 0), this[e] = 255 & t, e + 1 }, c.prototype.writeUint16LE = c.prototype.writeUInt16LE = function (t, e, n) { return t = +t, e >>>= 0, n || N(this, t, e, 2, 65535, 0), this[e] = 255 & t, this[e + 1] = t >>> 8, e + 2 }, c.prototype.writeUint16BE = c.prototype.writeUInt16BE = function (t, e, n) { return t = +t, e >>>= 0, n || N(this, t, e, 2, 65535, 0), this[e] = t >>> 8, this[e + 1] = 255 & t, e + 2 }, c.prototype.writeUint32LE = c.prototype.writeUInt32LE = function (t, e, n) { return t = +t, e >>>= 0, n || N(this, t, e, 4, 4294967295, 0), this[e + 3] = t >>> 24, this[e + 2] = t >>> 16, this[e + 1] = t >>> 8, this[e] = 255 & t, e + 4 }, c.prototype.writeUint32BE = c.prototype.writeUInt32BE = function (t, e, n) { return t = +t, e >>>= 0, n || N(this, t, e, 4, 4294967295, 0), this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t, e + 4 }, c.prototype.writeBigUInt64LE = X((function (t, e = 0) { return j(this, t, e, BigInt(0), BigInt("0xffffffffffffffff")) })), c.prototype.writeBigUInt64BE = X((function (t, e = 0) { return O(this, t, e, BigInt(0), BigInt("0xffffffffffffffff")) })), c.prototype.writeIntLE = function (t, e, n, r) { if (t = +t, e >>>= 0, !r) { const r = Math.pow(2, 8 * n - 1); N(this, t, e, n, r - 1, -r) } let i = 0, a = 1, s = 0; for (this[e] = 255 & t; ++i < n && (a *= 256);)t < 0 && 0 === s && 0 !== this[e + i - 1] && (s = 1), this[e + i] = (t / a >> 0) - s & 255; return e + n }, c.prototype.writeIntBE = function (t, e, n, r) { if (t = +t, e >>>= 0, !r) { const r = Math.pow(2, 8 * n - 1); N(this, t, e, n, r - 1, -r) } let i = n - 1, a = 1, s = 0; for (this[e + i] = 255 & t; --i >= 0 && (a *= 256);)t < 0 && 0 === s && 0 !== this[e + i + 1] && (s = 1), this[e + i] = (t / a >> 0) - s & 255; return e + n }, c.prototype.writeInt8 = function (t, e, n) { return t = +t, e >>>= 0, n || N(this, t, e, 1, 127, -128), t < 0 && (t = 255 + t + 1), this[e] = 255 & t, e + 1 }, c.prototype.writeInt16LE = function (t, e, n) { return t = +t, e >>>= 0, n || N(this, t, e, 2, 32767, -32768), this[e] = 255 & t, this[e + 1] = t >>> 8, e + 2 }, c.prototype.writeInt16BE = function (t, e, n) { return t = +t, e >>>= 0, n || N(this, t, e, 2, 32767, -32768), this[e] = t >>> 8, this[e + 1] = 255 & t, e + 2 }, c.prototype.writeInt32LE = function (t, e, n) { return t = +t, e >>>= 0, n || N(this, t, e, 4, 2147483647, -2147483648), this[e] = 255 & t, this[e + 1] = t >>> 8, this[e + 2] = t >>> 16, this[e + 3] = t >>> 24, e + 4 }, c.prototype.writeInt32BE = function (t, e, n) { return t = +t, e >>>= 0, n || N(this, t, e, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t, e + 4 }, c.prototype.writeBigInt64LE = X((function (t, e = 0) { return j(this, t, e, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff")) })), c.prototype.writeBigInt64BE = X((function (t, e = 0) { return O(this, t, e, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff")) })), c.prototype.writeFloatLE = function (t, e, n) { return M(this, t, e, !0, n) }, c.prototype.writeFloatBE = function (t, e, n) { return M(this, t, e, !1, n) }, c.prototype.writeDoubleLE = function (t, e, n) { return R(this, t, e, !0, n) }, c.prototype.writeDoubleBE = function (t, e, n) { return R(this, t, e, !1, n) }, c.prototype.copy = function (t, e, n, r) { if (!c.isBuffer(t)) throw new TypeError("argument should be a Buffer"); if (n || (n = 0), r || 0 === r || (r = this.length), e >= t.length && (e = t.length), e || (e = 0), r > 0 && r < n && (r = n), r === n) return 0; if (0 === t.length || 0 === this.length) return 0; if (e < 0) throw new RangeError("targetStart out of bounds"); if (n < 0 || n >= this.length) throw new RangeError("Index out of range"); if (r < 0) throw new RangeError("sourceEnd out of bounds"); r > this.length && (r = this.length), t.length - e < r - n && (r = t.length - e + n); const i = r - n; return this === t && "function" == typeof Uint8Array.prototype.copyWithin ? this.copyWithin(e, n, r) : Uint8Array.prototype.set.call(t, this.subarray(n, r), e), i }, c.prototype.fill = function (t, e, n, r) { if ("string" == typeof t) { if ("string" == typeof e ? (r = e, e = 0, n = this.length) : "string" == typeof n && (r = n, n = this.length), void 0 !== r && "string" != typeof r) throw new TypeError("encoding must be a string"); if ("string" == typeof r && !c.isEncoding(r)) throw new TypeError("Unknown encoding: " + r); if (1 === t.length) { const e = t.charCodeAt(0); ("utf8" === r && e < 128 || "latin1" === r) && (t = e) } } else "number" == typeof t ? t &= 255 : "boolean" == typeof t && (t = Number(t)); if (e < 0 || this.length < e || this.length < n) throw new RangeError("Out of range index"); if (n <= e) return this; let i; if (e >>>= 0, n = void 0 === n ? this.length : n >>> 0, t || (t = 0), "number" == typeof t) for (i = e; i < n; ++i)this[i] = t; else { const a = c.isBuffer(t) ? t : c.from(t, r), s = a.length; if (0 === s) throw new TypeError('The value "' + t + '" is invalid for argument "value"'); for (i = 0; i < n - e; ++i)this[i + e] = a[i % s] } return this }; const L = {}; function F(t, e, n) { L[t] = class extends n { constructor() { super(), Object.defineProperty(this, "message", { value: e.apply(this, arguments), writable: !0, configurable: !0 }), this.name = `${this.name} [${t}]`, this.stack, delete this.name } get code() { return t } set code(t) { Object.defineProperty(this, "code", { configurable: !0, enumerable: !0, value: t, writable: !0 }) } toString() { return `${this.name} [${t}]: ${this.message}` } } } function P(t) { let e = "", n = t.length; const r = "-" === t[0] ? 1 : 0; for (; n >= r + 4; n -= 3)e = `_${t.slice(n - 3, n)}${e}`; return `${t.slice(0, n)}${e}` } function V(t, e, n, r, i, a) { if (t > n || t < e) { const r = "bigint" == typeof e ? "n" : ""; let i; throw i = a > 3 ? 0 === e || e === BigInt(0) ? `>= 0${r} and < 2${r} ** ${8 * (a + 1)}${r}` : `>= -(2${r} ** ${8 * (a + 1) - 1}${r}) and < 2 ** ${8 * (a + 1) - 1}${r}` : `>= ${e}${r} and <= ${n}${r}`, new L.ERR_OUT_OF_RANGE("value", i, t) } !function (t, e, n) { Z(e, "offset"), void 0 !== t[e] && void 0 !== t[e + n] || q(e, t.length - (n + 1)) }(r, i, a) } function Z(t, e) { if ("number" != typeof t) throw new L.ERR_INVALID_ARG_TYPE(e, "number", t) } function q(t, e, n) { if (Math.floor(t) !== t) throw Z(t, n), new L.ERR_OUT_OF_RANGE(n || "offset", "an integer", t); if (e < 0) throw new L.ERR_BUFFER_OUT_OF_BOUNDS; throw new L.ERR_OUT_OF_RANGE(n || "offset", `>= ${n ? 1 : 0} and <= ${e}`, t) } F("ERR_BUFFER_OUT_OF_BOUNDS", (function (t) { return t ? `${t} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds" }), RangeError), F("ERR_INVALID_ARG_TYPE", (function (t, e) { return `The "${t}" argument must be of type number. Received type ${typeof e}` }), TypeError), F("ERR_OUT_OF_RANGE", (function (t, e, n) { let r = `The value of "${t}" is out of range.`, i = n; return Number.isInteger(n) && Math.abs(n) > 2 ** 32 ? i = P(String(n)) : "bigint" == typeof n && (i = String(n), (n > BigInt(2) ** BigInt(32) || n < -(BigInt(2) ** BigInt(32))) && (i = P(i)), i += "n"), r += ` It must be ${e}. Received ${i}`, r }), RangeError); const H = /[^+/0-9A-Za-z-_]/g; function W(t, e) { let n; e = e || 1 / 0; const r = t.length; let i = null; const a = []; for (let s = 0; s < r; ++s) { if (n = t.charCodeAt(s), n > 55295 && n < 57344) { if (!i) { if (n > 56319) { (e -= 3) > -1 && a.push(239, 191, 189); continue } if (s + 1 === r) { (e -= 3) > -1 && a.push(239, 191, 189); continue } i = n; continue } if (n < 56320) { (e -= 3) > -1 && a.push(239, 191, 189), i = n; continue } n = 65536 + (i - 55296 << 10 | n - 56320) } else i && (e -= 3) > -1 && a.push(239, 191, 189); if (i = null, n < 128) { if ((e -= 1) < 0) break; a.push(n) } else if (n < 2048) { if ((e -= 2) < 0) break; a.push(n >> 6 | 192, 63 & n | 128) } else if (n < 65536) { if ((e -= 3) < 0) break; a.push(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128) } else { if (!(n < 1114112)) throw new Error("Invalid code point"); if ((e -= 4) < 0) break; a.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128) } } return a } function $(t) { return r.toByteArray(function (t) { if ((t = (t = t.split("=")[0]).trim().replace(H, "")).length < 2) return ""; for (; t.length % 4 != 0;)t += "="; return t }(t)) } function Q(t, e, n, r) { let i; for (i = 0; i < r && !(i + n >= e.length || i >= t.length); ++i)e[i + n] = t[i]; return i } function G(t, e) { return t instanceof e || null != t && null != t.constructor && null != t.constructor.name && t.constructor.name === e.name } function K(t) { return t != t } const J = function () { const t = "0123456789abcdef", e = new Array(256); for (let n = 0; n < 16; ++n) { const r = 16 * n; for (let i = 0; i < 16; ++i)e[r + i] = t[n] + t[i] } return e }(); function X(t) { return "undefined" == typeof BigInt ? Y : t } function Y() { throw new Error("BigInt not supported") }
  }, 22215: function (t, e, n) { "use strict"; const r = n(33325), i = n(43281), a = n(87932); t.exports = { XMLParser: i, XMLValidator: r, XMLBuilder: a } }, 44056: function (t, e) { "use strict"; const n = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", r = "[" + n + "][" + (n + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040") + "]*", i = new RegExp("^" + r + "$"); e.isExist = function (t) { return void 0 !== t }, e.isEmptyObject = function (t) { return 0 === Object.keys(t).length }, e.merge = function (t, e, n) { if (e) { const r = Object.keys(e), i = r.length; for (let a = 0; a < i; a++)t[r[a]] = "strict" === n ? [e[r[a]]] : e[r[a]] } }, e.getValue = function (t) { return e.isExist(t) ? t : "" }, e.isName = function (t) { const e = i.exec(t); return !(null == e) }, e.getAllMatches = function (t, e) { const n = []; let r = e.exec(t); for (; r;) { const i = []; i.startIndex = e.lastIndex - r[0].length; const a = r.length; for (let t = 0; t < a; t++)i.push(r[t]); n.push(i), r = e.exec(t) } return n }, e.nameRegexp = r }, 33325: function (t, e, n) { "use strict"; const r = n(44056), i = { allowBooleanAttributes: !1, unpairedTags: [] }; function a(t) { return " " === t || "\t" === t || "\n" === t || "\r" === t } function s(t, e) { const n = e; for (; e < t.length; e++)if ("?" != t[e] && " " != t[e]); else { const r = t.substr(n, e - n); if (e > 5 && "xml" === r) return p("InvalidXml", "XML declaration allowed only at the start of the document.", m(t, e)); if ("?" == t[e] && ">" == t[e + 1]) { e++; break } } return e } function o(t, e) { if (t.length > e + 5 && "-" === t[e + 1] && "-" === t[e + 2]) { for (e += 3; e < t.length; e++)if ("-" === t[e] && "-" === t[e + 1] && ">" === t[e + 2]) { e += 2; break } } else if (t.length > e + 8 && "D" === t[e + 1] && "O" === t[e + 2] && "C" === t[e + 3] && "T" === t[e + 4] && "Y" === t[e + 5] && "P" === t[e + 6] && "E" === t[e + 7]) { let n = 1; for (e += 8; e < t.length; e++)if ("<" === t[e]) n++; else if (">" === t[e] && (n--, 0 === n)) break } else if (t.length > e + 9 && "[" === t[e + 1] && "C" === t[e + 2] && "D" === t[e + 3] && "A" === t[e + 4] && "T" === t[e + 5] && "A" === t[e + 6] && "[" === t[e + 7]) for (e += 8; e < t.length; e++)if ("]" === t[e] && "]" === t[e + 1] && ">" === t[e + 2]) { e += 2; break } return e } e.validate = function (t, e) { e = Object.assign({}, i, e); const n = []; let c = !1, l = !1; "\ufeff" === t[0] && (t = t.substr(1)); for (let i = 0; i < t.length; i++)if ("<" === t[i] && "?" === t[i + 1]) { if (i += 2, i = s(t, i), i.err) return i } else { if ("<" !== t[i]) { if (a(t[i])) continue; return p("InvalidChar", "char '" + t[i] + "' is not expected.", m(t, i)) } { let g = i; if (i++, "!" === t[i]) { i = o(t, i); continue } { let b = !1; "/" === t[i] && (b = !0, i++); let w = ""; for (; i < t.length && ">" !== t[i] && " " !== t[i] && "\t" !== t[i] && "\n" !== t[i] && "\r" !== t[i]; i++)w += t[i]; if (w = w.trim(), "/" === w[w.length - 1] && (w = w.substring(0, w.length - 1), i--), d = w, !r.isName(d)) { let e; return e = 0 === w.trim().length ? "Invalid space after '<'." : "Tag '" + w + "' is an invalid name.", p("InvalidTag", e, m(t, i)) } const y = f(t, i); if (!1 === y) return p("InvalidAttr", "Attributes for '" + w + "' have open quote.", m(t, i)); let v = y.value; if (i = y.index, "/" === v[v.length - 1]) { const n = i - v.length; v = v.substring(0, v.length - 1); const r = u(v, e); if (!0 !== r) return p(r.err.code, r.err.msg, m(t, n + r.err.line)); c = !0 } else if (b) { if (!y.tagClosed) return p("InvalidTag", "Closing tag '" + w + "' doesn't have proper closing.", m(t, i)); if (v.trim().length > 0) return p("InvalidTag", "Closing tag '" + w + "' can't have attributes or invalid starting.", m(t, g)); { const e = n.pop(); if (w !== e.tagName) { let n = m(t, e.tagStartPos); return p("InvalidTag", "Expected closing tag '" + e.tagName + "' (opened in line " + n.line + ", col " + n.col + ") instead of closing tag '" + w + "'.", m(t, g)) } 0 == n.length && (l = !0) } } else { const r = u(v, e); if (!0 !== r) return p(r.err.code, r.err.msg, m(t, i - v.length + r.err.line)); if (!0 === l) return p("InvalidXml", "Multiple possible root nodes found.", m(t, i)); -1 !== e.unpairedTags.indexOf(w) || n.push({ tagName: w, tagStartPos: g }), c = !0 } for (i++; i < t.length; i++)if ("<" === t[i]) { if ("!" === t[i + 1]) { i++, i = o(t, i); continue } if ("?" !== t[i + 1]) break; if (i = s(t, ++i), i.err) return i } else if ("&" === t[i]) { const e = h(t, i); if (-1 == e) return p("InvalidChar", "char '&' is not expected.", m(t, i)); i = e } else if (!0 === l && !a(t[i])) return p("InvalidXml", "Extra text at the end", m(t, i)); "<" === t[i] && i-- } } } var d; return c ? 1 == n.length ? p("InvalidTag", "Unclosed tag '" + n[0].tagName + "'.", m(t, n[0].tagStartPos)) : !(n.length > 0) || p("InvalidXml", "Invalid '" + JSON.stringify(n.map((t => t.tagName)), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 }) : p("InvalidXml", "Start tag expected.", 1) }; const c = '"', l = "'"; function f(t, e) { let n = "", r = "", i = !1; for (; e < t.length; e++) { if (t[e] === c || t[e] === l) "" === r ? r = t[e] : r !== t[e] || (r = ""); else if (">" === t[e] && "" === r) { i = !0; break } n += t[e] } return "" === r && { value: n, index: e, tagClosed: i } } const d = new RegExp("(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['\"])(([\\s\\S])*?)\\5)?", "g"); function u(t, e) { const n = r.getAllMatches(t, d), i = {}; for (let t = 0; t < n.length; t++) { if (0 === n[t][1].length) return p("InvalidAttr", "Attribute '" + n[t][2] + "' has no space in starting.", b(n[t])); if (void 0 !== n[t][3] && void 0 === n[t][4]) return p("InvalidAttr", "Attribute '" + n[t][2] + "' is without value.", b(n[t])); if (void 0 === n[t][3] && !e.allowBooleanAttributes) return p("InvalidAttr", "boolean attribute '" + n[t][2] + "' is not allowed.", b(n[t])); const r = n[t][2]; if (!g(r)) return p("InvalidAttr", "Attribute '" + r + "' is an invalid name.", b(n[t])); if (i.hasOwnProperty(r)) return p("InvalidAttr", "Attribute '" + r + "' is repeated.", b(n[t])); i[r] = 1 } return !0 } function h(t, e) { if (";" === t[++e]) return -1; if ("#" === t[e]) return function (t, e) { let n = /\d/; for ("x" === t[e] && (e++, n = /[\da-fA-F]/); e < t.length; e++) { if (";" === t[e]) return e; if (!t[e].match(n)) break } return -1 }(t, ++e); let n = 0; for (; e < t.length; e++, n++)if (!(t[e].match(/\w/) && n < 20)) { if (";" === t[e]) break; return -1 } return e } function p(t, e, n) { return { err: { code: t, msg: e, line: n.line || n, col: n.col } } } function g(t) { return r.isName(t) } function m(t, e) { const n = t.substring(0, e).split(/\r?\n/); return { line: n.length, col: n[n.length - 1].length + 1 } } function b(t) { return t.startIndex + t[1].length } }, 87932: function (t, e, n) { "use strict"; const r = n(26704), i = { attributeNamePrefix: "@_", attributesGroupName: !1, textNodeName: "#text", ignoreAttributes: !0, cdataPropName: !1, format: !1, indentBy: "  ", suppressEmptyNode: !1, suppressUnpairedNode: !0, suppressBooleanAttributes: !0, tagValueProcessor: function (t, e) { return e }, attributeValueProcessor: function (t, e) { return e }, preserveOrder: !1, commentPropName: !1, unpairedTags: [], entities: [{ regex: new RegExp("&", "g"), val: "&amp;" }, { regex: new RegExp(">", "g"), val: "&gt;" }, { regex: new RegExp("<", "g"), val: "&lt;" }, { regex: new RegExp("'", "g"), val: "&apos;" }, { regex: new RegExp('"', "g"), val: "&quot;" }], processEntities: !0, stopNodes: [], oneListGroup: !1 }; function a(t) { this.options = Object.assign({}, i, t), this.options.ignoreAttributes || this.options.attributesGroupName ? this.isAttribute = function () { return !1 } : (this.attrPrefixLen = this.options.attributeNamePrefix.length, this.isAttribute = c), this.processTextOrObjNode = s, this.options.format ? (this.indentate = o, this.tagEndChar = ">\n", this.newLine = "\n") : (this.indentate = function () { return "" }, this.tagEndChar = ">", this.newLine = "") } function s(t, e, n) { const r = this.j2x(t, n + 1); return void 0 !== t[this.options.textNodeName] && 1 === Object.keys(t).length ? this.buildTextValNode(t[this.options.textNodeName], e, r.attrStr, n) : this.buildObjectNode(r.val, e, r.attrStr, n) } function o(t) { return this.options.indentBy.repeat(t) } function c(t) { return !!t.startsWith(this.options.attributeNamePrefix) && t.substr(this.attrPrefixLen) } a.prototype.build = function (t) { return this.options.preserveOrder ? r(t, this.options) : (Array.isArray(t) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1 && (t = { [this.options.arrayNodeName]: t }), this.j2x(t, 0).val) }, a.prototype.j2x = function (t, e) { let n = "", r = ""; for (let i in t) if (void 0 === t[i]); else if (null === t[i]) "?" === i[0] ? r += this.indentate(e) + "<" + i + "?" + this.tagEndChar : r += this.indentate(e) + "<" + i + "/" + this.tagEndChar; else if (t[i] instanceof Date) r += this.buildTextValNode(t[i], i, "", e); else if ("object" != typeof t[i]) { const a = this.isAttribute(i); if (a) n += this.buildAttrPairStr(a, "" + t[i]); else if (i === this.options.textNodeName) { let e = this.options.tagValueProcessor(i, "" + t[i]); r += this.replaceEntitiesValue(e) } else r += this.buildTextValNode(t[i], i, "", e) } else if (Array.isArray(t[i])) { const n = t[i].length; let a = ""; for (let s = 0; s < n; s++) { const n = t[i][s]; void 0 === n || (null === n ? "?" === i[0] ? r += this.indentate(e) + "<" + i + "?" + this.tagEndChar : r += this.indentate(e) + "<" + i + "/" + this.tagEndChar : "object" == typeof n ? this.options.oneListGroup ? a += this.j2x(n, e + 1).val : a += this.processTextOrObjNode(n, i, e) : a += this.buildTextValNode(n, i, "", e)) } this.options.oneListGroup && (a = this.buildObjectNode(a, i, "", e)), r += a } else if (this.options.attributesGroupName && i === this.options.attributesGroupName) { const e = Object.keys(t[i]), r = e.length; for (let a = 0; a < r; a++)n += this.buildAttrPairStr(e[a], "" + t[i][e[a]]) } else r += this.processTextOrObjNode(t[i], i, e); return { attrStr: n, val: r } }, a.prototype.buildAttrPairStr = function (t, e) { return e = this.options.attributeValueProcessor(t, "" + e), e = this.replaceEntitiesValue(e), this.options.suppressBooleanAttributes && "true" === e ? " " + t : " " + t + '="' + e + '"' }, a.prototype.buildObjectNode = function (t, e, n, r) { if ("" === t) return "?" === e[0] ? this.indentate(r) + "<" + e + n + "?" + this.tagEndChar : this.indentate(r) + "<" + e + n + this.closeTag(e) + this.tagEndChar; { let i = "</" + e + this.tagEndChar, a = ""; return "?" === e[0] && (a = "?", i = ""), n && -1 === t.indexOf("<") ? this.indentate(r) + "<" + e + n + a + ">" + t + i : !1 !== this.options.commentPropName && e === this.options.commentPropName && 0 === a.length ? this.indentate(r) + `\x3c!--${t}--\x3e` + this.newLine : this.indentate(r) + "<" + e + n + a + this.tagEndChar + t + this.indentate(r) + i } }, a.prototype.closeTag = function (t) { let e = ""; return -1 !== this.options.unpairedTags.indexOf(t) ? this.options.suppressUnpairedNode || (e = "/") : e = this.options.suppressEmptyNode ? "/" : `></${t}`, e }, a.prototype.buildTextValNode = function (t, e, n, r) { if (!1 !== this.options.cdataPropName && e === this.options.cdataPropName) return this.indentate(r) + `<![CDATA[${t}]]>` + this.newLine; if (!1 !== this.options.commentPropName && e === this.options.commentPropName) return this.indentate(r) + `\x3c!--${t}--\x3e` + this.newLine; if ("?" === e[0]) return this.indentate(r) + "<" + e + n + "?" + this.tagEndChar; { let i = this.options.tagValueProcessor(e, t); return i = this.replaceEntitiesValue(i), "" === i ? this.indentate(r) + "<" + e + n + this.closeTag(e) + this.tagEndChar : this.indentate(r) + "<" + e + n + ">" + i + "</" + e + this.tagEndChar } }, a.prototype.replaceEntitiesValue = function (t) { if (t && t.length > 0 && this.options.processEntities) for (let e = 0; e < this.options.entities.length; e++) { const n = this.options.entities[e]; t = t.replace(n.regex, n.val) } return t }, t.exports = a }, 26704: function (t) { function e(t, s, o, c) { let l = "", f = !1; for (let d = 0; d < t.length; d++) { const u = t[d], h = n(u); let p = ""; if (p = 0 === o.length ? h : `${o}.${h}`, h === s.textNodeName) { let t = u[h]; i(p, s) || (t = s.tagValueProcessor(h, t), t = a(t, s)), f && (l += c), l += t, f = !1; continue } if (h === s.cdataPropName) { f && (l += c), l += `<![CDATA[${u[h][0][s.textNodeName]}]]>`, f = !1; continue } if (h === s.commentPropName) { l += c + `\x3c!--${u[h][0][s.textNodeName]}--\x3e`, f = !0; continue } if ("?" === h[0]) { const t = r(u[":@"], s), e = "?xml" === h ? "" : c; let n = u[h][0][s.textNodeName]; n = 0 !== n.length ? " " + n : "", l += e + `<${h}${n}${t}?>`, f = !0; continue } let g = c; "" !== g && (g += s.indentBy); const m = c + `<${h}${r(u[":@"], s)}`, b = e(u[h], s, p, g); -1 !== s.unpairedTags.indexOf(h) ? s.suppressUnpairedNode ? l += m + ">" : l += m + "/>" : b && 0 !== b.length || !s.suppressEmptyNode ? b && b.endsWith(">") ? l += m + `>${b}${c}</${h}>` : (l += m + ">", b && "" !== c && (b.includes("/>") || b.includes("</")) ? l += c + s.indentBy + b + c : l += b, l += `</${h}>`) : l += m + "/>", f = !0 } return l } function n(t) { const e = Object.keys(t); for (let t = 0; t < e.length; t++) { const n = e[t]; if (":@" !== n) return n } } function r(t, e) { let n = ""; if (t && !e.ignoreAttributes) for (let r in t) { let i = e.attributeValueProcessor(r, t[r]); i = a(i, e), !0 === i && e.suppressBooleanAttributes ? n += ` ${r.substr(e.attributeNamePrefix.length)}` : n += ` ${r.substr(e.attributeNamePrefix.length)}="${i}"` } return n } function i(t, e) { let n = (t = t.substr(0, t.length - e.textNodeName.length - 1)).substr(t.lastIndexOf(".") + 1); for (let r in e.stopNodes) if (e.stopNodes[r] === t || e.stopNodes[r] === "*." + n) return !0; return !1 } function a(t, e) { if (t && t.length > 0 && e.processEntities) for (let n = 0; n < e.entities.length; n++) { const r = e.entities[n]; t = t.replace(r.regex, r.val) } return t } t.exports = function (t, n) { let r = ""; return n.format && n.indentBy.length > 0 && (r = "\n"), e(t, n, "", r) } }, 13770: function (t) { function e(t, e) { let n = ""; for (; e < t.length && "'" !== t[e] && '"' !== t[e]; e++)n += t[e]; if (n = n.trim(), -1 !== n.indexOf(" ")) throw new Error("External entites are not supported"); const r = t[e++]; let i = ""; for (; e < t.length && t[e] !== r; e++)i += t[e]; return [n, i, e] } function n(t, e) { return "!" === t[e + 1] && "-" === t[e + 2] && "-" === t[e + 3] } function r(t, e) { return "!" === t[e + 1] && "E" === t[e + 2] && "N" === t[e + 3] && "T" === t[e + 4] && "I" === t[e + 5] && "T" === t[e + 6] && "Y" === t[e + 7] } function i(t, e) { return "!" === t[e + 1] && "E" === t[e + 2] && "L" === t[e + 3] && "E" === t[e + 4] && "M" === t[e + 5] && "E" === t[e + 6] && "N" === t[e + 7] && "T" === t[e + 8] } function a(t, e) { return "!" === t[e + 1] && "A" === t[e + 2] && "T" === t[e + 3] && "T" === t[e + 4] && "L" === t[e + 5] && "I" === t[e + 6] && "S" === t[e + 7] && "T" === t[e + 8] } function s(t, e) { return "!" === t[e + 1] && "N" === t[e + 2] && "O" === t[e + 3] && "T" === t[e + 4] && "A" === t[e + 5] && "T" === t[e + 6] && "I" === t[e + 7] && "O" === t[e + 8] && "N" === t[e + 9] } t.exports = function (t, o) { const c = {}; if ("O" !== t[o + 3] || "C" !== t[o + 4] || "T" !== t[o + 5] || "Y" !== t[o + 6] || "P" !== t[o + 7] || "E" !== t[o + 8]) throw new Error("Invalid Tag instead of DOCTYPE"); { o += 9; let l = 1, f = !1, d = !1, u = ""; for (; o < t.length; o++)if ("<" !== t[o] || d) if (">" === t[o]) { if (d ? "-" === t[o - 1] && "-" === t[o - 2] && (d = !1, l--) : l--, 0 === l) break } else "[" === t[o] ? f = !0 : u += t[o]; else { if (f && r(t, o)) o += 7, [entityName, val, o] = e(t, o + 1), -1 === val.indexOf("&") && (c[entityName] = { regx: RegExp(`&${entityName};`, "g"), val: val }); else if (f && i(t, o)) o += 8; else if (f && a(t, o)) o += 8; else if (f && s(t, o)) o += 9; else { if (!n) throw new Error("Invalid DOCTYPE"); d = !0 } l++, u = "" } if (0 !== l) throw new Error("Unclosed DOCTYPE") } return { entities: c, i: o } } }, 14238: function (t, e) { const n = { preserveOrder: !1, attributeNamePrefix: "@_", attributesGroupName: !1, textNodeName: "#text", ignoreAttributes: !0, removeNSPrefix: !1, allowBooleanAttributes: !1, parseTagValue: !0, parseAttributeValue: !1, trimValues: !0, cdataPropName: !1, numberParseOptions: { hex: !0, leadingZeros: !0, eNotation: !0 }, tagValueProcessor: function (t, e) { return e }, attributeValueProcessor: function (t, e) { return e }, stopNodes: [], alwaysCreateTextNode: !1, isArray: () => !1, commentPropName: !1, unpairedTags: [], processEntities: !0, htmlEntities: !1, ignoreDeclaration: !1, ignorePiTags: !1, transformTagName: !1, transformAttributeName: !1, updateTag: function (t, e, n) { return t } }; e.buildOptions = function (t) { return Object.assign({}, n, t) }, e.defaultOptions = n }, 22848: function (t, e, n) { "use strict"; const r = n(44056), i = n(14499), a = n(13770), s = n(85580); "<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)".replace(/NAME/g, r.nameRegexp); function o(t) { const e = Object.keys(t); for (let n = 0; n < e.length; n++) { const r = e[n]; this.lastEntities[r] = { regex: new RegExp("&" + r + ";", "g"), val: t[r] } } } function c(t, e, n, r, i, a, s) { if (void 0 !== t && (this.options.trimValues && !r && (t = t.trim()), t.length > 0)) { s || (t = this.replaceEntitiesValue(t)); const r = this.options.tagValueProcessor(e, t, n, i, a); if (null == r) return t; if (typeof r != typeof t || r !== t) return r; if (this.options.trimValues) return v(t, this.options.parseTagValue, this.options.numberParseOptions); return t.trim() === t ? v(t, this.options.parseTagValue, this.options.numberParseOptions) : t } } function l(t) { if (this.options.removeNSPrefix) { const e = t.split(":"), n = "/" === t.charAt(0) ? "/" : ""; if ("xmlns" === e[0]) return ""; 2 === e.length && (t = n + e[1]) } return t } const f = new RegExp("([^\\s=]+)\\s*(=\\s*(['\"])([\\s\\S]*?)\\3)?", "gm"); function d(t, e, n) { if (!this.options.ignoreAttributes && "string" == typeof t) { const n = r.getAllMatches(t, f), i = n.length, a = {}; for (let t = 0; t < i; t++) { const r = this.resolveNameSpace(n[t][1]); let i = n[t][4], s = this.options.attributeNamePrefix + r; if (r.length) if (this.options.transformAttributeName && (s = this.options.transformAttributeName(s)), "__proto__" === s && (s = "#__proto__"), void 0 !== i) { this.options.trimValues && (i = i.trim()), i = this.replaceEntitiesValue(i); const t = this.options.attributeValueProcessor(r, i, e); a[s] = null == t ? i : typeof t != typeof i || t !== i ? t : v(i, this.options.parseAttributeValue, this.options.numberParseOptions) } else this.options.allowBooleanAttributes && (a[s] = !0) } if (!Object.keys(a).length) return; if (this.options.attributesGroupName) { const t = {}; return t[this.options.attributesGroupName] = a, t } return a } } const u = function (t) { t = t.replace(/\r\n?/g, "\n"); const e = new i("!xml"); let n = e, r = "", s = ""; for (let o = 0; o < t.length; o++) { if ("<" === t[o]) if ("/" === t[o + 1]) { const e = b(t, ">", o, "Closing Tag is not closed."); let i = t.substring(o + 2, e).trim(); if (this.options.removeNSPrefix) { const t = i.indexOf(":"); -1 !== t && (i = i.substr(t + 1)) } this.options.transformTagName && (i = this.options.transformTagName(i)), n && (r = this.saveTextToParentTag(r, n, s)), s = s.substr(0, s.lastIndexOf(".")), n = this.tagsNodeStack.pop(), r = "", o = e } else if ("?" === t[o + 1]) { let e = w(t, o, !1, "?>"); if (!e) throw new Error("Pi Tag is not closed."); if (r = this.saveTextToParentTag(r, n, s), this.options.ignoreDeclaration && "?xml" === e.tagName || this.options.ignorePiTags); else { const t = new i(e.tagName); t.add(this.options.textNodeName, ""), e.tagName !== e.tagExp && e.attrExpPresent && (t[":@"] = this.buildAttributesMap(e.tagExp, s, e.tagName)), this.addChild(n, t, s) } o = e.closeIndex + 1 } else if ("!--" === t.substr(o + 1, 3)) { const e = b(t, "--\x3e", o + 4, "Comment is not closed."); if (this.options.commentPropName) { const i = t.substring(o + 4, e - 2); r = this.saveTextToParentTag(r, n, s), n.add(this.options.commentPropName, [{ [this.options.textNodeName]: i }]) } o = e } else if ("!D" === t.substr(o + 1, 2)) { const e = a(t, o); this.docTypeEntities = e.entities, o = e.i } else if ("![" === t.substr(o + 1, 2)) { const e = b(t, "]]>", o, "CDATA is not closed.") - 2, i = t.substring(o + 9, e); if (r = this.saveTextToParentTag(r, n, s), this.options.cdataPropName) n.add(this.options.cdataPropName, [{ [this.options.textNodeName]: i }]); else { let t = this.parseTextData(i, n.tagname, s, !0, !1, !0); null == t && (t = ""), n.add(this.options.textNodeName, t) } o = e + 2 } else { let a = w(t, o, this.options.removeNSPrefix), c = a.tagName, l = a.tagExp, f = a.attrExpPresent, d = a.closeIndex; this.options.transformTagName && (c = this.options.transformTagName(c)), n && r && "!xml" !== n.tagname && (r = this.saveTextToParentTag(r, n, s, !1)), c !== e.tagname && (s += s ? "." + c : c); const u = n; if (u && -1 !== this.options.unpairedTags.indexOf(u.tagname) && (n = this.tagsNodeStack.pop()), this.isItStopNode(this.options.stopNodes, s, c)) { let e = ""; if (l.length > 0 && l.lastIndexOf("/") === l.length - 1) o = a.closeIndex; else if (-1 !== this.options.unpairedTags.indexOf(c)) o = a.closeIndex; else { const n = this.readStopNodeData(t, c, d + 1); if (!n) throw new Error(`Unexpected end of ${c}`); o = n.i, e = n.tagContent } const r = new i(c); c !== l && f && (r[":@"] = this.buildAttributesMap(l, s, c)), e && (e = this.parseTextData(e, c, s, !0, f, !0, !0)), s = s.substr(0, s.lastIndexOf(".")), r.add(this.options.textNodeName, e), this.addChild(n, r, s) } else { if (l.length > 0 && l.lastIndexOf("/") === l.length - 1) { "/" === c[c.length - 1] ? (c = c.substr(0, c.length - 1), l = c) : l = l.substr(0, l.length - 1), this.options.transformTagName && (c = this.options.transformTagName(c)); const t = new i(c); c !== l && f && (t[":@"] = this.buildAttributesMap(l, s, c)), s = s.substr(0, s.lastIndexOf(".")), this.addChild(n, t, s) } else { const t = new i(c); this.tagsNodeStack.push(n), c !== l && f && (t[":@"] = this.buildAttributesMap(l, s, c)), this.addChild(n, t, s), n = t } r = "", o = d } } else r += t[o] } return e.child }; function h(t, e, n) { const r = this.options.updateTag(e.tagname, n, e[":@"]); !1 === r || ("string" == typeof r ? (e.tagname = r, t.addChild(e)) : t.addChild(e)) } const p = function (t) { if (this.options.processEntities) { for (let e in this.docTypeEntities) { const n = this.docTypeEntities[e]; t = t.replace(n.regx, n.val) } for (let e in this.lastEntities) { const n = this.lastEntities[e]; t = t.replace(n.regex, n.val) } if (this.options.htmlEntities) for (let e in this.htmlEntities) { const n = this.htmlEntities[e]; t = t.replace(n.regex, n.val) } t = t.replace(this.ampEntity.regex, this.ampEntity.val) } return t }; function g(t, e, n, r) { return t && (void 0 === r && (r = 0 === Object.keys(e.child).length), void 0 !== (t = this.parseTextData(t, e.tagname, n, !1, !!e[":@"] && 0 !== Object.keys(e[":@"]).length, r)) && "" !== t && e.add(this.options.textNodeName, t), t = ""), t } function m(t, e, n) { const r = "*." + n; for (const n in t) { const i = t[n]; if (r === i || e === i) return !0 } return !1 } function b(t, e, n, r) { const i = t.indexOf(e, n); if (-1 === i) throw new Error(r); return i + e.length - 1 } function w(t, e, n, r = ">") { const i = function (t, e, n = ">") { let r, i = ""; for (let a = e; a < t.length; a++) { let e = t[a]; if (r) e === r && (r = ""); else if ('"' === e || "'" === e) r = e; else if (e === n[0]) { if (!n[1]) return { data: i, index: a }; if (t[a + 1] === n[1]) return { data: i, index: a } } else "\t" === e && (e = " "); i += e } }(t, e + 1, r); if (!i) return; let a = i.data; const s = i.index, o = a.search(/\s/); let c = a, l = !0; if (-1 !== o && (c = a.substr(0, o).replace(/\s\s*$/, ""), a = a.substr(o + 1)), n) { const t = c.indexOf(":"); -1 !== t && (c = c.substr(t + 1), l = c !== i.data.substr(t + 1)) } return { tagName: c, tagExp: a, closeIndex: s, attrExpPresent: l } } function y(t, e, n) { const r = n; let i = 1; for (; n < t.length; n++)if ("<" === t[n]) if ("/" === t[n + 1]) { const a = b(t, ">", n, `${e} is not closed`); if (t.substring(n + 2, a).trim() === e && (i--, 0 === i)) return { tagContent: t.substring(r, n), i: a }; n = a } else if ("?" === t[n + 1]) { n = b(t, "?>", n + 1, "StopNode is not closed.") } else if ("!--" === t.substr(n + 1, 3)) { n = b(t, "--\x3e", n + 3, "StopNode is not closed.") } else if ("![" === t.substr(n + 1, 2)) { n = b(t, "]]>", n, "StopNode is not closed.") - 2 } else { const r = w(t, n, ">"); if (r) { (r && r.tagName) === e && "/" !== r.tagExp[r.tagExp.length - 1] && i++, n = r.closeIndex } } } function v(t, e, n) { if (e && "string" == typeof t) { const e = t.trim(); return "true" === e || "false" !== e && s(t, n) } return r.isExist(t) ? t : "" } t.exports = class { constructor(t) { this.options = t, this.currentNode = null, this.tagsNodeStack = [], this.docTypeEntities = {}, this.lastEntities = { apos: { regex: /&(apos|#39|#x27);/g, val: "'" }, gt: { regex: /&(gt|#62|#x3E);/g, val: ">" }, lt: { regex: /&(lt|#60|#x3C);/g, val: "<" }, quot: { regex: /&(quot|#34|#x22);/g, val: '"' } }, this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" }, this.htmlEntities = { space: { regex: /&(nbsp|#160);/g, val: " " }, cent: { regex: /&(cent|#162);/g, val: "" }, pound: { regex: /&(pound|#163);/g, val: "" }, yen: { regex: /&(yen|#165);/g, val: "" }, euro: { regex: /&(euro|#8364);/g, val: "" }, copyright: { regex: /&(copy|#169);/g, val: "" }, reg: { regex: /&(reg|#174);/g, val: "" }, inr: { regex: /&(inr|#8377);/g, val: "" } }, this.addExternalEntities = o, this.parseXml = u, this.parseTextData = c, this.resolveNameSpace = l, this.buildAttributesMap = d, this.isItStopNode = m, this.replaceEntitiesValue = p, this.readStopNodeData = y, this.saveTextToParentTag = g, this.addChild = h } } }, 43281: function (t, e, n) { const { buildOptions: r } = n(14238), i = n(22848), { prettify: a } = n(64416), s = n(33325); t.exports = class { constructor(t) { this.externalEntities = {}, this.options = r(t) } parse(t, e) { if ("string" == typeof t); else { if (!t.toString) throw new Error("XML data is accepted in String or Bytes[] form."); t = t.toString() } if (e) { !0 === e && (e = {}); const n = s.validate(t, e); if (!0 !== n) throw Error(`${n.err.msg}:${n.err.line}:${n.err.col}`) } const n = new i(this.options); n.addExternalEntities(this.externalEntities); const r = n.parseXml(t); return this.options.preserveOrder || void 0 === r ? r : a(r, this.options) } addEntity(t, e) { if (-1 !== e.indexOf("&")) throw new Error("Entity value can't have '&'"); if (-1 !== t.indexOf("&") || -1 !== t.indexOf(";")) throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'"); if ("&" === e) throw new Error("An entity with value '&' is not permitted"); this.externalEntities[t] = e } } }, 64416: function (t, e) { "use strict"; function n(t, e, s) { let o; const c = {}; for (let l = 0; l < t.length; l++) { const f = t[l], d = r(f); let u = ""; if (u = void 0 === s ? d : s + "." + d, d === e.textNodeName) void 0 === o ? o = f[d] : o += "" + f[d]; else { if (void 0 === d) continue; if (f[d]) { let t = n(f[d], e, u); const r = a(t, e); f[":@"] ? i(t, f[":@"], u, e) : 1 !== Object.keys(t).length || void 0 === t[e.textNodeName] || e.alwaysCreateTextNode ? 0 === Object.keys(t).length && (e.alwaysCreateTextNode ? t[e.textNodeName] = "" : t = "") : t = t[e.textNodeName], void 0 !== c[d] && c.hasOwnProperty(d) ? (Array.isArray(c[d]) || (c[d] = [c[d]]), c[d].push(t)) : e.isArray(d, u, r) ? c[d] = [t] : c[d] = t } } } return "string" == typeof o ? o.length > 0 && (c[e.textNodeName] = o) : void 0 !== o && (c[e.textNodeName] = o), c } function r(t) { const e = Object.keys(t); for (let t = 0; t < e.length; t++) { const n = e[t]; if (":@" !== n) return n } } function i(t, e, n, r) { if (e) { const i = Object.keys(e), a = i.length; for (let s = 0; s < a; s++) { const a = i[s]; r.isArray(a, n + "." + a, !0, !0) ? t[a] = [e[a]] : t[a] = e[a] } } } function a(t, e) { const { textNodeName: n } = e, r = Object.keys(t).length; return 0 === r || !(1 !== r || !t[n] && "boolean" != typeof t[n] && 0 !== t[n]) } e.prettify = function (t, e) { return n(t, e) } }, 14499: function (t) { "use strict"; t.exports = class { constructor(t) { this.tagname = t, this.child = [], this[":@"] = {} } add(t, e) { "__proto__" === t && (t = "#__proto__"), this.child.push({ [t]: e }) } addChild(t) { "__proto__" === t.tagname && (t.tagname = "#__proto__"), t[":@"] && Object.keys(t[":@"]).length > 0 ? this.child.push({ [t.tagname]: t.child, ":@": t[":@"] }) : this.child.push({ [t.tagname]: t.child }) } } }, 15756: function (t, e, n) { "use strict"; var r = n(27654).Buffer; e._dbcs = f; for (var i = -1, a = -2, s = -10, o = -1e3, c = new Array(256), l = 0; l < 256; l++)c[l] = i; function f(t, e) { if (this.encodingName = t.encodingName, !t) throw new Error("DBCS codec is called without the data."); if (!t.table) throw new Error("Encoding '" + this.encodingName + "' has no data."); var n = t.table(); this.decodeTables = [], this.decodeTables[0] = c.slice(0), this.decodeTableSeq = []; for (var r = 0; r < n.length; r++)this._addDecodeChunk(n[r]); if ("function" == typeof t.gb18030) { this.gb18030 = t.gb18030(); var s = this.decodeTables.length; this.decodeTables.push(c.slice(0)); var l = this.decodeTables.length; this.decodeTables.push(c.slice(0)); var f = this.decodeTables[0]; for (r = 129; r <= 254; r++)for (var d = this.decodeTables[o - f[r]], u = 48; u <= 57; u++) { if (d[u] === i) d[u] = o - s; else if (d[u] > o) throw new Error("gb18030 decode tables conflict at byte 2"); for (var h = this.decodeTables[o - d[u]], p = 129; p <= 254; p++) { if (h[p] === i) h[p] = o - l; else { if (h[p] === o - l) continue; if (h[p] > o) throw new Error("gb18030 decode tables conflict at byte 3") } for (var g = this.decodeTables[o - h[p]], m = 48; m <= 57; m++)g[m] === i && (g[m] = a) } } } this.defaultCharUnicode = e.defaultCharUnicode, this.encodeTable = [], this.encodeTableSeq = []; var b = {}; if (t.encodeSkipVals) for (r = 0; r < t.encodeSkipVals.length; r++) { var w = t.encodeSkipVals[r]; if ("number" == typeof w) b[w] = !0; else for (u = w.from; u <= w.to; u++)b[u] = !0 } if (this._fillEncodeTable(0, 0, b), t.encodeAdd) for (var y in t.encodeAdd) Object.prototype.hasOwnProperty.call(t.encodeAdd, y) && this._setEncodeChar(y.charCodeAt(0), t.encodeAdd[y]); this.defCharSB = this.encodeTable[0][e.defaultCharSingleByte.charCodeAt(0)], this.defCharSB === i && (this.defCharSB = this.encodeTable[0]["?"]), this.defCharSB === i && (this.defCharSB = "?".charCodeAt(0)) } function d(t, e) { this.leadSurrogate = -1, this.seqObj = void 0, this.encodeTable = e.encodeTable, this.encodeTableSeq = e.encodeTableSeq, this.defaultCharSingleByte = e.defCharSB, this.gb18030 = e.gb18030 } function u(t, e) { this.nodeIdx = 0, this.prevBytes = [], this.decodeTables = e.decodeTables, this.decodeTableSeq = e.decodeTableSeq, this.defaultCharUnicode = e.defaultCharUnicode, this.gb18030 = e.gb18030 } function h(t, e) { if (t[0] > e) return -1; for (var n = 0, r = t.length; n < r - 1;) { var i = n + (r - n + 1 >> 1); t[i] <= e ? n = i : r = i } return n } f.prototype.encoder = d, f.prototype.decoder = u, f.prototype._getDecodeTrieNode = function (t) { for (var e = []; t > 0; t >>>= 8)e.push(255 & t); 0 == e.length && e.push(0); for (var n = this.decodeTables[0], r = e.length - 1; r > 0; r--) { var a = n[e[r]]; if (a == i) n[e[r]] = o - this.decodeTables.length, this.decodeTables.push(n = c.slice(0)); else { if (!(a <= o)) throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + t.toString(16)); n = this.decodeTables[o - a] } } return n }, f.prototype._addDecodeChunk = function (t) { var e = parseInt(t[0], 16), n = this._getDecodeTrieNode(e); e &= 255; for (var r = 1; r < t.length; r++) { var i = t[r]; if ("string" == typeof i) for (var a = 0; a < i.length;) { var o = i.charCodeAt(a++); if (55296 <= o && o < 56320) { var c = i.charCodeAt(a++); if (!(56320 <= c && c < 57344)) throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + t[0]); n[e++] = 65536 + 1024 * (o - 55296) + (c - 56320) } else if (4080 < o && o <= 4095) { for (var l = 4095 - o + 2, f = [], d = 0; d < l; d++)f.push(i.charCodeAt(a++)); n[e++] = s - this.decodeTableSeq.length, this.decodeTableSeq.push(f) } else n[e++] = o } else { if ("number" != typeof i) throw new Error("Incorrect type '" + typeof i + "' given in " + this.encodingName + " at chunk " + t[0]); var u = n[e - 1] + 1; for (a = 0; a < i; a++)n[e++] = u++ } } if (e > 255) throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + t[0] + ": too long" + e) }, f.prototype._getEncodeBucket = function (t) { var e = t >> 8; return void 0 === this.encodeTable[e] && (this.encodeTable[e] = c.slice(0)), this.encodeTable[e] }, f.prototype._setEncodeChar = function (t, e) { var n = this._getEncodeBucket(t), r = 255 & t; n[r] <= s ? this.encodeTableSeq[s - n[r]][-1] = e : n[r] == i && (n[r] = e) }, f.prototype._setEncodeSequence = function (t, e) { var n, r = t[0], a = this._getEncodeBucket(r), o = 255 & r; a[o] <= s ? n = this.encodeTableSeq[s - a[o]] : (n = {}, a[o] !== i && (n[-1] = a[o]), a[o] = s - this.encodeTableSeq.length, this.encodeTableSeq.push(n)); for (var c = 1; c < t.length - 1; c++) { var l = n[r]; "object" == typeof l ? n = l : (n = n[r] = {}, void 0 !== l && (n[-1] = l)) } n[r = t[t.length - 1]] = e }, f.prototype._fillEncodeTable = function (t, e, n) { for (var r = this.decodeTables[t], i = !1, a = {}, c = 0; c < 256; c++) { var l = r[c], f = e + c; if (!n[f]) if (l >= 0) this._setEncodeChar(l, f), i = !0; else if (l <= o) { var d = o - l; if (!a[d]) { var u = f << 8 >>> 0; this._fillEncodeTable(d, u, n) ? i = !0 : a[d] = !0 } } else l <= s && (this._setEncodeSequence(this.decodeTableSeq[s - l], f), i = !0) } return i }, d.prototype.write = function (t) { for (var e = r.alloc(t.length * (this.gb18030 ? 4 : 3)), n = this.leadSurrogate, a = this.seqObj, o = -1, c = 0, l = 0; ;) { if (-1 === o) { if (c == t.length) break; var f = t.charCodeAt(c++) } else { f = o; o = -1 } if (55296 <= f && f < 57344) if (f < 56320) { if (-1 === n) { n = f; continue } n = f, f = i } else -1 !== n ? (f = 65536 + 1024 * (n - 55296) + (f - 56320), n = -1) : f = i; else -1 !== n && (o = f, f = i, n = -1); var d = i; if (void 0 !== a && f != i) { var u = a[f]; if ("object" == typeof u) { a = u; continue } "number" == typeof u ? d = u : null == u && void 0 !== (u = a[-1]) && (d = u, o = f), a = void 0 } else if (f >= 0) { var p = this.encodeTable[f >> 8]; if (void 0 !== p && (d = p[255 & f]), d <= s) { a = this.encodeTableSeq[s - d]; continue } if (d == i && this.gb18030) { var g = h(this.gb18030.uChars, f); if (-1 != g) { d = this.gb18030.gbChars[g] + (f - this.gb18030.uChars[g]); e[l++] = 129 + Math.floor(d / 12600), d %= 12600, e[l++] = 48 + Math.floor(d / 1260), d %= 1260, e[l++] = 129 + Math.floor(d / 10), d %= 10, e[l++] = 48 + d; continue } } } d === i && (d = this.defaultCharSingleByte), d < 256 ? e[l++] = d : d < 65536 ? (e[l++] = d >> 8, e[l++] = 255 & d) : d < 16777216 ? (e[l++] = d >> 16, e[l++] = d >> 8 & 255, e[l++] = 255 & d) : (e[l++] = d >>> 24, e[l++] = d >>> 16 & 255, e[l++] = d >>> 8 & 255, e[l++] = 255 & d) } return this.seqObj = a, this.leadSurrogate = n, e.slice(0, l) }, d.prototype.end = function () { if (-1 !== this.leadSurrogate || void 0 !== this.seqObj) { var t = r.alloc(10), e = 0; if (this.seqObj) { var n = this.seqObj[-1]; void 0 !== n && (n < 256 ? t[e++] = n : (t[e++] = n >> 8, t[e++] = 255 & n)), this.seqObj = void 0 } return -1 !== this.leadSurrogate && (t[e++] = this.defaultCharSingleByte, this.leadSurrogate = -1), t.slice(0, e) } }, d.prototype.findIdx = h, u.prototype.write = function (t) { for (var e = r.alloc(2 * t.length), n = this.nodeIdx, c = this.prevBytes, l = this.prevBytes.length, f = -this.prevBytes.length, d = 0, u = 0; d < t.length; d++) { var p, g = d >= 0 ? t[d] : c[d + l]; if ((p = this.decodeTables[n][g]) >= 0); else if (p === i) p = this.defaultCharUnicode.charCodeAt(0), d = f; else if (p === a) { if (d >= 3) var m = 12600 * (t[d - 3] - 129) + 1260 * (t[d - 2] - 48) + 10 * (t[d - 1] - 129) + (g - 48); else m = 12600 * (c[d - 3 + l] - 129) + 1260 * ((d - 2 >= 0 ? t[d - 2] : c[d - 2 + l]) - 48) + 10 * ((d - 1 >= 0 ? t[d - 1] : c[d - 1 + l]) - 129) + (g - 48); var b = h(this.gb18030.gbChars, m); p = this.gb18030.uChars[b] + m - this.gb18030.gbChars[b] } else { if (p <= o) { n = o - p; continue } if (!(p <= s)) throw new Error("iconv-lite internal error: invalid decoding table value " + p + " at " + n + "/" + g); for (var w = this.decodeTableSeq[s - p], y = 0; y < w.length - 1; y++)p = w[y], e[u++] = 255 & p, e[u++] = p >> 8; p = w[w.length - 1] } if (p >= 65536) { var v = 55296 | (p -= 65536) >> 10; e[u++] = 255 & v, e[u++] = v >> 8, p = 56320 | 1023 & p } e[u++] = 255 & p, e[u++] = p >> 8, n = 0, f = d + 1 } return this.nodeIdx = n, this.prevBytes = f >= 0 ? Array.prototype.slice.call(t, f) : c.slice(f + l).concat(Array.prototype.slice.call(t)), e.slice(0, u).toString("ucs2") }, u.prototype.end = function () { for (var t = ""; this.prevBytes.length > 0;) { t += this.defaultCharUnicode; var e = this.prevBytes.slice(1); this.prevBytes = [], this.nodeIdx = 0, e.length > 0 && (t += this.write(e)) } return this.prevBytes = [], this.nodeIdx = 0, t } }, 22086: function (t, e, n) { "use strict"; t.exports = { shiftjis: { type: "_dbcs", table: function () { return n(39372) }, encodeAdd: { "": 92, "": 126 }, encodeSkipVals: [{ from: 60736, to: 63808 }] }, csshiftjis: "shiftjis", mskanji: "shiftjis", sjis: "shiftjis", windows31j: "shiftjis", ms31j: "shiftjis", xsjis: "shiftjis", windows932: "shiftjis", ms932: "shiftjis", 932: "shiftjis", cp932: "shiftjis", eucjp: { type: "_dbcs", table: function () { return n(39715) }, encodeAdd: { "": 92, "": 126 } }, gb2312: "cp936", gb231280: "cp936", gb23121980: "cp936", csgb2312: "cp936", csiso58gb231280: "cp936", euccn: "cp936", windows936: "cp936", ms936: "cp936", 936: "cp936", cp936: { type: "_dbcs", table: function () { return n(39227) } }, gbk: { type: "_dbcs", table: function () { return n(39227).concat(n(41689)) } }, xgbk: "gbk", isoir58: "gbk", gb18030: { type: "_dbcs", table: function () { return n(39227).concat(n(41689)) }, gb18030: function () { return n(41846) }, encodeSkipVals: [128], encodeAdd: { "": 41699 } }, chinese: "gb18030", windows949: "cp949", ms949: "cp949", 949: "cp949", cp949: { type: "_dbcs", table: function () { return n(64359) } }, cseuckr: "cp949", csksc56011987: "cp949", euckr: "cp949", isoir149: "cp949", korean: "cp949", ksc56011987: "cp949", ksc56011989: "cp949", ksc5601: "cp949", windows950: "cp950", ms950: "cp950", 950: "cp950", cp950: { type: "_dbcs", table: function () { return n(76636) } }, big5: "big5hkscs", big5hkscs: { type: "_dbcs", table: function () { return n(76636).concat(n(13802)) }, encodeSkipVals: [36457, 36463, 36478, 36523, 36532, 36557, 36560, 36695, 36713, 36718, 36811, 36862, 36973, 36986, 37060, 37084, 37105, 37311, 37551, 37552, 37553, 37554, 37585, 37959, 38090, 38361, 38652, 39285, 39798, 39800, 39803, 39878, 39902, 39916, 39926, 40002, 40019, 40034, 40040, 40043, 40055, 40124, 40125, 40144, 40279, 40282, 40388, 40431, 40443, 40617, 40687, 40701, 40800, 40907, 41079, 41180, 41183, 36812, 37576, 38468, 38637, 41636, 41637, 41639, 41638, 41676, 41678] }, cnbig5: "big5hkscs", csbig5: "big5hkscs", xxbig5: "big5hkscs" } }, 41481: function (t, e, n) { "use strict"; for (var r = [n(25509), n(13703), n(75283), n(99003), n(70809), n(2587), n(96769), n(15756), n(22086)], i = 0; i < r.length; i++) { var a = r[i]; for (var s in a) Object.prototype.hasOwnProperty.call(a, s) && (e[s] = a[s]) } }, 25509: function (t, e, n) { "use strict"; var r = n(27654).Buffer; function i(t, e) { this.enc = t.encodingName, this.bomAware = t.bomAware, "base64" === this.enc ? this.encoder = c : "cesu8" === this.enc && (this.enc = "utf8", this.encoder = l, "" !== r.from("eda0bdedb2a9", "hex").toString() && (this.decoder = f, this.defaultCharUnicode = e.defaultCharUnicode)) } t.exports = { utf8: { type: "_internal", bomAware: !0 }, cesu8: { type: "_internal", bomAware: !0 }, unicode11utf8: "utf8", ucs2: { type: "_internal", bomAware: !0 }, utf16le: "ucs2", binary: { type: "_internal" }, base64: { type: "_internal" }, hex: { type: "_internal" }, _internal: i }, i.prototype.encoder = o, i.prototype.decoder = s; var a = n(30214).s; function s(t, e) { this.decoder = new a(e.enc) } function o(t, e) { this.enc = e.enc } function c(t, e) { this.prevStr = "" } function l(t, e) { } function f(t, e) { this.acc = 0, this.contBytes = 0, this.accBytes = 0, this.defaultCharUnicode = e.defaultCharUnicode } a.prototype.end || (a.prototype.end = function () { }), s.prototype.write = function (t) { return r.isBuffer(t) || (t = r.from(t)), this.decoder.write(t) }, s.prototype.end = function () { return this.decoder.end() }, o.prototype.write = function (t) { return r.from(t, this.enc) }, o.prototype.end = function () { }, c.prototype.write = function (t) { var e = (t = this.prevStr + t).length - t.length % 4; return this.prevStr = t.slice(e), t = t.slice(0, e), r.from(t, "base64") }, c.prototype.end = function () { return r.from(this.prevStr, "base64") }, l.prototype.write = function (t) { for (var e = r.alloc(3 * t.length), n = 0, i = 0; i < t.length; i++) { var a = t.charCodeAt(i); a < 128 ? e[n++] = a : a < 2048 ? (e[n++] = 192 + (a >>> 6), e[n++] = 128 + (63 & a)) : (e[n++] = 224 + (a >>> 12), e[n++] = 128 + (a >>> 6 & 63), e[n++] = 128 + (63 & a)) } return e.slice(0, n) }, l.prototype.end = function () { }, f.prototype.write = function (t) { for (var e = this.acc, n = this.contBytes, r = this.accBytes, i = "", a = 0; a < t.length; a++) { var s = t[a]; 128 != (192 & s) ? (n > 0 && (i += this.defaultCharUnicode, n = 0), s < 128 ? i += String.fromCharCode(s) : s < 224 ? (e = 31 & s, n = 1, r = 1) : s < 240 ? (e = 15 & s, n = 2, r = 1) : i += this.defaultCharUnicode) : n > 0 ? (e = e << 6 | 63 & s, r++, 0 === --n && (i += 2 === r && e < 128 && e > 0 || 3 === r && e < 2048 ? this.defaultCharUnicode : String.fromCharCode(e))) : i += this.defaultCharUnicode } return this.acc = e, this.contBytes = n, this.accBytes = r, i }, f.prototype.end = function () { var t = 0; return this.contBytes > 0 && (t += this.defaultCharUnicode), t } }, 70809: function (t, e, n) { "use strict"; var r = n(27654).Buffer; function i(t, e) { if (!t) throw new Error("SBCS codec is called without the data."); if (!t.chars || 128 !== t.chars.length && 256 !== t.chars.length) throw new Error("Encoding '" + t.type + "' has incorrect 'chars' (must be of len 128 or 256)"); if (128 === t.chars.length) { for (var n = "", i = 0; i < 128; i++)n += String.fromCharCode(i); t.chars = n + t.chars } this.decodeBuf = r.from(t.chars, "ucs2"); var a = r.alloc(65536, e.defaultCharSingleByte.charCodeAt(0)); for (i = 0; i < t.chars.length; i++)a[t.chars.charCodeAt(i)] = i; this.encodeBuf = a } function a(t, e) { this.encodeBuf = e.encodeBuf } function s(t, e) { this.decodeBuf = e.decodeBuf } e._sbcs = i, i.prototype.encoder = a, i.prototype.decoder = s, a.prototype.write = function (t) { for (var e = r.alloc(t.length), n = 0; n < t.length; n++)e[n] = this.encodeBuf[t.charCodeAt(n)]; return e }, a.prototype.end = function () { }, s.prototype.write = function (t) { for (var e = this.decodeBuf, n = r.alloc(2 * t.length), i = 0, a = 0, s = 0; s < t.length; s++)i = 2 * t[s], n[a = 2 * s] = e[i], n[a + 1] = e[i + 1]; return n.toString("ucs2") }, s.prototype.end = function () { } }, 96769: function (t) { "use strict"; t.exports = { 437: "cp437", 737: "cp737", 775: "cp775", 850: "cp850", 852: "cp852", 855: "cp855", 856: "cp856", 857: "cp857", 858: "cp858", 860: "cp860", 861: "cp861", 862: "cp862", 863: "cp863", 864: "cp864", 865: "cp865", 866: "cp866", 869: "cp869", 874: "windows874", 922: "cp922", 1046: "cp1046", 1124: "cp1124", 1125: "cp1125", 1129: "cp1129", 1133: "cp1133", 1161: "cp1161", 1162: "cp1162", 1163: "cp1163", 1250: "windows1250", 1251: "windows1251", 1252: "windows1252", 1253: "windows1253", 1254: "windows1254", 1255: "windows1255", 1256: "windows1256", 1257: "windows1257", 1258: "windows1258", 28591: "iso88591", 28592: "iso88592", 28593: "iso88593", 28594: "iso88594", 28595: "iso88595", 28596: "iso88596", 28597: "iso88597", 28598: "iso88598", 28599: "iso88599", 28600: "iso885910", 28601: "iso885911", 28603: "iso885913", 28604: "iso885914", 28605: "iso885915", 28606: "iso885916", windows874: { type: "_sbcs", chars: "" }, win874: "windows874", cp874: "windows874", windows1250: { type: "_sbcs", chars: "" }, win1250: "windows1250", cp1250: "windows1250", windows1251: { type: "_sbcs", chars: "" }, win1251: "windows1251", cp1251: "windows1251", windows1252: { type: "_sbcs", chars: "" }, win1252: "windows1252", cp1252: "windows1252", windows1253: { type: "_sbcs", chars: "" }, win1253: "windows1253", cp1253: "windows1253", windows1254: { type: "_sbcs", chars: "" }, win1254: "windows1254", cp1254: "windows1254", windows1255: { type: "_sbcs", chars: "" }, win1255: "windows1255", cp1255: "windows1255", windows1256: { type: "_sbcs", chars: "" }, win1256: "windows1256", cp1256: "windows1256", windows1257: { type: "_sbcs", chars: "" }, win1257: "windows1257", cp1257: "windows1257", windows1258: { type: "_sbcs", chars: "" }, win1258: "windows1258", cp1258: "windows1258", iso88591: { type: "_sbcs", chars: "" }, cp28591: "iso88591", iso88592: { type: "_sbcs", chars: "" }, cp28592: "iso88592", iso88593: { type: "_sbcs", chars: "" }, cp28593: "iso88593", iso88594: { type: "_sbcs", chars: "" }, cp28594: "iso88594", iso88595: { type: "_sbcs", chars: "" }, cp28595: "iso88595", iso88596: { type: "_sbcs", chars: "" }, cp28596: "iso88596", iso88597: { type: "_sbcs", chars: "" }, cp28597: "iso88597", iso88598: { type: "_sbcs", chars: "" }, cp28598: "iso88598", iso88599: { type: "_sbcs", chars: "" }, cp28599: "iso88599", iso885910: { type: "_sbcs", chars: "" }, cp28600: "iso885910", iso885911: { type: "_sbcs", chars: "" }, cp28601: "iso885911", iso885913: { type: "_sbcs", chars: "" }, cp28603: "iso885913", iso885914: { type: "_sbcs", chars: "" }, cp28604: "iso885914", iso885915: { type: "_sbcs", chars: "" }, cp28605: "iso885915", iso885916: { type: "_sbcs", chars: "" }, cp28606: "iso885916", cp437: { type: "_sbcs", chars: "" }, ibm437: "cp437", csibm437: "cp437", cp737: { type: "_sbcs", chars: "" }, ibm737: "cp737", csibm737: "cp737", cp775: { type: "_sbcs", chars: "" }, ibm775: "cp775", csibm775: "cp775", cp850: { type: "_sbcs", chars: "" }, ibm850: "cp850", csibm850: "cp850", cp852: { type: "_sbcs", chars: "" }, ibm852: "cp852", csibm852: "cp852", cp855: { type: "_sbcs", chars: "" }, ibm855: "cp855", csibm855: "cp855", cp856: { type: "_sbcs", chars: "" }, ibm856: "cp856", csibm856: "cp856", cp857: { type: "_sbcs", chars: "" }, ibm857: "cp857", csibm857: "cp857", cp858: { type: "_sbcs", chars: "" }, ibm858: "cp858", csibm858: "cp858", cp860: { type: "_sbcs", chars: "" }, ibm860: "cp860", csibm860: "cp860", cp861: { type: "_sbcs", chars: "" }, ibm861: "cp861", csibm861: "cp861", cp862: { type: "_sbcs", chars: "" }, ibm862: "cp862", csibm862: "cp862", cp863: { type: "_sbcs", chars: "" }, ibm863: "cp863", csibm863: "cp863", cp864: { type: "_sbcs", chars: "\0\b\t\n\v\f\r !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~" }, ibm864: "cp864", csibm864: "cp864", cp865: { type: "_sbcs", chars: "" }, ibm865: "cp865", csibm865: "cp865", cp866: { type: "_sbcs", chars: "" }, ibm866: "cp866", csibm866: "cp866", cp869: { type: "_sbcs", chars: "" }, ibm869: "cp869", csibm869: "cp869", cp922: { type: "_sbcs", chars: "" }, ibm922: "cp922", csibm922: "cp922", cp1046: { type: "_sbcs", chars: "" }, ibm1046: "cp1046", csibm1046: "cp1046", cp1124: { type: "_sbcs", chars: "" }, ibm1124: "cp1124", csibm1124: "cp1124", cp1125: { type: "_sbcs", chars: "" }, ibm1125: "cp1125", csibm1125: "cp1125", cp1129: { type: "_sbcs", chars: "" }, ibm1129: "cp1129", csibm1129: "cp1129", cp1133: { type: "_sbcs", chars: "" }, ibm1133: "cp1133", csibm1133: "cp1133", cp1161: { type: "_sbcs", chars: "" }, ibm1161: "cp1161", csibm1161: "cp1161", cp1162: { type: "_sbcs", chars: "" }, ibm1162: "cp1162", csibm1162: "cp1162", cp1163: { type: "_sbcs", chars: "" }, ibm1163: "cp1163", csibm1163: "cp1163", maccroatian: { type: "_sbcs", chars: "" }, maccyrillic: { type: "_sbcs", chars: "" }, macgreek: { type: "_sbcs", chars: "" }, maciceland: { type: "_sbcs", chars: "" }, macroman: { type: "_sbcs", chars: "" }, macromania: { type: "_sbcs", chars: "" }, macthai: { type: "_sbcs", chars: "\ufeff" }, macturkish: { type: "_sbcs", chars: "" }, macukraine: { type: "_sbcs", chars: "" }, koi8r: { type: "_sbcs", chars: "" }, koi8u: { type: "_sbcs", chars: "" }, koi8ru: { type: "_sbcs", chars: "" }, koi8t: { type: "_sbcs", chars: "" }, armscii8: { type: "_sbcs", chars: ")(.,-" }, rk1048: { type: "_sbcs", chars: "" }, tcvn: { type: "_sbcs", chars: "\0\b\t\n\v\f\r !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~" }, georgianacademy: { type: "_sbcs", chars: "" }, georgianps: { type: "_sbcs", chars: "" }, pt154: { type: "_sbcs", chars: "" }, viscii: { type: "_sbcs", chars: "\0\b\t\n\v\f\r !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~" }, iso646cn: { type: "_sbcs", chars: "\0\b\t\n\v\f\r !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}" }, iso646jp: { type: "_sbcs", chars: "\0\b\t\n\v\f\r !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}" }, hproman8: { type: "_sbcs", chars: "" }, macintosh: { type: "_sbcs", chars: "" }, ascii: { type: "_sbcs", chars: "" }, tis620: { type: "_sbcs", chars: "" } } }, 2587: function (t) { "use strict"; t.exports = { 10029: "maccenteuro", maccenteuro: { type: "_sbcs", chars: "" }, 808: "cp808", ibm808: "cp808", cp808: { type: "_sbcs", chars: "" }, mik: { type: "_sbcs", chars: "" }, cp720: { type: "_sbcs", chars: "" }, ascii8bit: "ascii", usascii: "ascii", ansix34: "ascii", ansix341968: "ascii", ansix341986: "ascii", csascii: "ascii", cp367: "ascii", ibm367: "ascii", isoir6: "ascii", iso646us: "ascii", iso646irv: "ascii", us: "ascii", latin1: "iso88591", latin2: "iso88592", latin3: "iso88593", latin4: "iso88594", latin5: "iso88599", latin6: "iso885910", latin7: "iso885913", latin8: "iso885914", latin9: "iso885915", latin10: "iso885916", csisolatin1: "iso88591", csisolatin2: "iso88592", csisolatin3: "iso88593", csisolatin4: "iso88594", csisolatincyrillic: "iso88595", csisolatinarabic: "iso88596", csisolatingreek: "iso88597", csisolatinhebrew: "iso88598", csisolatin5: "iso88599", csisolatin6: "iso885910", l1: "iso88591", l2: "iso88592", l3: "iso88593", l4: "iso88594", l5: "iso88599", l6: "iso885910", l7: "iso885913", l8: "iso885914", l9: "iso885915", l10: "iso885916", isoir14: "iso646jp", isoir57: "iso646cn", isoir100: "iso88591", isoir101: "iso88592", isoir109: "iso88593", isoir110: "iso88594", isoir144: "iso88595", isoir127: "iso88596", isoir126: "iso88597", isoir138: "iso88598", isoir148: "iso88599", isoir157: "iso885910", isoir166: "tis620", isoir179: "iso885913", isoir199: "iso885914", isoir203: "iso885915", isoir226: "iso885916", cp819: "iso88591", ibm819: "iso88591", cyrillic: "iso88595", arabic: "iso88596", arabic8: "iso88596", ecma114: "iso88596", asmo708: "iso88596", greek: "iso88597", greek8: "iso88597", ecma118: "iso88597", elot928: "iso88597", hebrew: "iso88598", hebrew8: "iso88598", turkish: "iso88599", turkish8: "iso88599", thai: "iso885911", thai8: "iso885911", celtic: "iso885914", celtic8: "iso885914", isoceltic: "iso885914", tis6200: "tis620", tis62025291: "tis620", tis62025330: "tis620", 1e4: "macroman", 10006: "macgreek", 10007: "maccyrillic", 10079: "maciceland", 10081: "macturkish", cspc8codepage437: "cp437", cspc775baltic: "cp775", cspc850multilingual: "cp850", cspcp852: "cp852", cspc862latinhebrew: "cp862", cpgr: "cp869", msee: "cp1250", mscyrl: "cp1251", msansi: "cp1252", msgreek: "cp1253", msturk: "cp1254", mshebr: "cp1255", msarab: "cp1256", winbaltrim: "cp1257", cp20866: "koi8r", 20866: "koi8r", ibm878: "koi8r", cskoi8r: "koi8r", cp21866: "koi8u", 21866: "koi8u", ibm1168: "koi8u", strk10482002: "rk1048", tcvn5712: "tcvn", tcvn57121: "tcvn", gb198880: "iso646cn", cn: "iso646cn", csiso14jisc6220ro: "iso646jp", jisc62201969ro: "iso646jp", jp: "iso646jp", cshproman8: "hproman8", r8: "hproman8", roman8: "hproman8", xroman8: "hproman8", ibm1051: "hproman8", mac: "macintosh", csmacintosh: "macintosh" } }, 75283: function (t, e, n) { "use strict"; var r = n(27654).Buffer; function i() { } function a() { } function s() { this.overflowByte = -1 } function o(t, e) { this.iconv = e } function c(t, e) { void 0 === (t = t || {}).addBOM && (t.addBOM = !0), this.encoder = e.iconv.getEncoder("utf-16le", t) } function l(t, e) { this.decoder = null, this.initialBufs = [], this.initialBufsLen = 0, this.options = t || {}, this.iconv = e.iconv } function f(t, e) { var n = [], r = 0, i = 0, a = 0; t: for (var s = 0; s < t.length; s++)for (var o = t[s], c = 0; c < o.length; c++)if (n.push(o[c]), 2 === n.length) { if (0 === r) { if (255 === n[0] && 254 === n[1]) return "utf-16le"; if (254 === n[0] && 255 === n[1]) return "utf-16be" } if (0 === n[0] && 0 !== n[1] && a++, 0 !== n[0] && 0 === n[1] && i++, n.length = 0, ++r >= 100) break t } return a > i ? "utf-16be" : a < i ? "utf-16le" : e || "utf-16le" } e.utf16be = i, i.prototype.encoder = a, i.prototype.decoder = s, i.prototype.bomAware = !0, a.prototype.write = function (t) { for (var e = r.from(t, "ucs2"), n = 0; n < e.length; n += 2) { var i = e[n]; e[n] = e[n + 1], e[n + 1] = i } return e }, a.prototype.end = function () { }, s.prototype.write = function (t) { if (0 == t.length) return ""; var e = r.alloc(t.length + 1), n = 0, i = 0; for (-1 !== this.overflowByte && (e[0] = t[0], e[1] = this.overflowByte, n = 1, i = 2); n < t.length - 1; n += 2, i += 2)e[i] = t[n + 1], e[i + 1] = t[n]; return this.overflowByte = n == t.length - 1 ? t[t.length - 1] : -1, e.slice(0, i).toString("ucs2") }, s.prototype.end = function () { this.overflowByte = -1 }, e.utf16 = o, o.prototype.encoder = c, o.prototype.decoder = l, c.prototype.write = function (t) { return this.encoder.write(t) }, c.prototype.end = function () { return this.encoder.end() }, l.prototype.write = function (t) { if (!this.decoder) { if (this.initialBufs.push(t), this.initialBufsLen += t.length, this.initialBufsLen < 16) return ""; var e = f(this.initialBufs, this.options.defaultEncoding); this.decoder = this.iconv.getDecoder(e, this.options); for (var n = "", r = 0; r < this.initialBufs.length; r++)n += this.decoder.write(this.initialBufs[r]); return this.initialBufs.length = this.initialBufsLen = 0, n } return this.decoder.write(t) }, l.prototype.end = function () { if (!this.decoder) { var t = f(this.initialBufs, this.options.defaultEncoding); this.decoder = this.iconv.getDecoder(t, this.options); for (var e = "", n = 0; n < this.initialBufs.length; n++)e += this.decoder.write(this.initialBufs[n]); var r = this.decoder.end(); return r && (e += r), this.initialBufs.length = this.initialBufsLen = 0, e } return this.decoder.end() } }, 13703: function (t, e, n) { "use strict"; var r = n(27654).Buffer; function i(t, e) { this.iconv = e, this.bomAware = !0, this.isLE = t.isLE } function a(t, e) { this.isLE = e.isLE, this.highSurrogate = 0 } function s(t, e) { this.isLE = e.isLE, this.badChar = e.iconv.defaultCharUnicode.charCodeAt(0), this.overflow = [] } function o(t, e, n, r) { if ((n < 0 || n > 1114111) && (n = r), n >= 65536) { var i = 55296 | (n -= 65536) >> 10; t[e++] = 255 & i, t[e++] = i >> 8; n = 56320 | 1023 & n } return t[e++] = 255 & n, t[e++] = n >> 8, e } function c(t, e) { this.iconv = e } function l(t, e) { void 0 === (t = t || {}).addBOM && (t.addBOM = !0), this.encoder = e.iconv.getEncoder(t.defaultEncoding || "utf-32le", t) } function f(t, e) { this.decoder = null, this.initialBufs = [], this.initialBufsLen = 0, this.options = t || {}, this.iconv = e.iconv } function d(t, e) { var n = [], r = 0, i = 0, a = 0, s = 0, o = 0; t: for (var c = 0; c < t.length; c++)for (var l = t[c], f = 0; f < l.length; f++)if (n.push(l[f]), 4 === n.length) { if (0 === r) { if (255 === n[0] && 254 === n[1] && 0 === n[2] && 0 === n[3]) return "utf-32le"; if (0 === n[0] && 0 === n[1] && 254 === n[2] && 255 === n[3]) return "utf-32be" } if ((0 !== n[0] || n[1] > 16) && a++, (0 !== n[3] || n[2] > 16) && i++, 0 !== n[0] || 0 !== n[1] || 0 === n[2] && 0 === n[3] || o++, 0 === n[0] && 0 === n[1] || 0 !== n[2] || 0 !== n[3] || s++, n.length = 0, ++r >= 100) break t } return o - a > s - i ? "utf-32be" : o - a < s - i ? "utf-32le" : e || "utf-32le" } e._utf32 = i, e.utf32le = { type: "_utf32", isLE: !0 }, e.utf32be = { type: "_utf32", isLE: !1 }, e.ucs4le = "utf32le", e.ucs4be = "utf32be", i.prototype.encoder = a, i.prototype.decoder = s, a.prototype.write = function (t) { for (var e = r.from(t, "ucs2"), n = r.alloc(2 * e.length), i = this.isLE ? n.writeUInt32LE : n.writeUInt32BE, a = 0, s = 0; s < e.length; s += 2) { var o = e.readUInt16LE(s), c = 55296 <= o && o < 56320, l = 56320 <= o && o < 57344; if (this.highSurrogate) { if (!c && l) { var f = 65536 + (this.highSurrogate - 55296 << 10 | o - 56320); i.call(n, f, a), a += 4, this.highSurrogate = 0; continue } i.call(n, this.highSurrogate, a), a += 4 } c ? this.highSurrogate = o : (i.call(n, o, a), a += 4, this.highSurrogate = 0) } return a < n.length && (n = n.slice(0, a)), n }, a.prototype.end = function () { if (this.highSurrogate) { var t = r.alloc(4); return this.isLE ? t.writeUInt32LE(this.highSurrogate, 0) : t.writeUInt32BE(this.highSurrogate, 0), this.highSurrogate = 0, t } }, s.prototype.write = function (t) { if (0 === t.length) return ""; var e = 0, n = 0, i = r.alloc(t.length + 4), a = 0, s = this.isLE, c = this.overflow, l = this.badChar; if (c.length > 0) { for (; e < t.length && c.length < 4; e++)c.push(t[e]); 4 === c.length && (n = s ? c[e] | c[e + 1] << 8 | c[e + 2] << 16 | c[e + 3] << 24 : c[e + 3] | c[e + 2] << 8 | c[e + 1] << 16 | c[e] << 24, c.length = 0, a = o(i, a, n, l)) } for (; e < t.length - 3; e += 4)a = o(i, a, n = s ? t[e] | t[e + 1] << 8 | t[e + 2] << 16 | t[e + 3] << 24 : t[e + 3] | t[e + 2] << 8 | t[e + 1] << 16 | t[e] << 24, l); for (; e < t.length; e++)c.push(t[e]); return i.slice(0, a).toString("ucs2") }, s.prototype.end = function () { this.overflow.length = 0 }, e.utf32 = c, e.ucs4 = "utf32", c.prototype.encoder = l, c.prototype.decoder = f, l.prototype.write = function (t) { return this.encoder.write(t) }, l.prototype.end = function () { return this.encoder.end() }, f.prototype.write = function (t) { if (!this.decoder) { if (this.initialBufs.push(t), this.initialBufsLen += t.length, this.initialBufsLen < 32) return ""; var e = d(this.initialBufs, this.options.defaultEncoding); this.decoder = this.iconv.getDecoder(e, this.options); for (var n = "", r = 0; r < this.initialBufs.length; r++)n += this.decoder.write(this.initialBufs[r]); return this.initialBufs.length = this.initialBufsLen = 0, n } return this.decoder.write(t) }, f.prototype.end = function () { if (!this.decoder) { var t = d(this.initialBufs, this.options.defaultEncoding); this.decoder = this.iconv.getDecoder(t, this.options); for (var e = "", n = 0; n < this.initialBufs.length; n++)e += this.decoder.write(this.initialBufs[n]); var r = this.decoder.end(); return r && (e += r), this.initialBufs.length = this.initialBufsLen = 0, e } return this.decoder.end() } }, 99003: function (t, e, n) { "use strict"; var r = n(27654).Buffer; function i(t, e) { this.iconv = e } e.utf7 = i, e.unicode11utf7 = "utf7", i.prototype.encoder = s, i.prototype.decoder = o, i.prototype.bomAware = !0; var a = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g; function s(t, e) { this.iconv = e.iconv } function o(t, e) { this.iconv = e.iconv, this.inBase64 = !1, this.base64Accum = "" } s.prototype.write = function (t) { return r.from(t.replace(a, function (t) { return "+" + ("+" === t ? "" : this.iconv.encode(t, "utf16-be").toString("base64").replace(/=+$/, "")) + "-" }.bind(this))) }, s.prototype.end = function () { }; for (var c = /[A-Za-z0-9\/+]/, l = [], f = 0; f < 256; f++)l[f] = c.test(String.fromCharCode(f)); var d = "+".charCodeAt(0), u = "-".charCodeAt(0), h = "&".charCodeAt(0); function p(t, e) { this.iconv = e } function g(t, e) { this.iconv = e.iconv, this.inBase64 = !1, this.base64Accum = r.alloc(6), this.base64AccumIdx = 0 } function m(t, e) { this.iconv = e.iconv, this.inBase64 = !1, this.base64Accum = "" } o.prototype.write = function (t) { for (var e = "", n = 0, i = this.inBase64, a = this.base64Accum, s = 0; s < t.length; s++)if (i) { if (!l[t[s]]) { if (s == n && t[s] == u) e += "+"; else { var o = a + this.iconv.decode(t.slice(n, s), "ascii"); e += this.iconv.decode(r.from(o, "base64"), "utf16-be") } t[s] != u && s--, n = s + 1, i = !1, a = "" } } else t[s] == d && (e += this.iconv.decode(t.slice(n, s), "ascii"), n = s + 1, i = !0); if (i) { var c = (o = a + this.iconv.decode(t.slice(n), "ascii")).length - o.length % 8; a = o.slice(c), o = o.slice(0, c), e += this.iconv.decode(r.from(o, "base64"), "utf16-be") } else e += this.iconv.decode(t.slice(n), "ascii"); return this.inBase64 = i, this.base64Accum = a, e }, o.prototype.end = function () { var t = ""; return this.inBase64 && this.base64Accum.length > 0 && (t = this.iconv.decode(r.from(this.base64Accum, "base64"), "utf16-be")), this.inBase64 = !1, this.base64Accum = "", t }, e.utf7imap = p, p.prototype.encoder = g, p.prototype.decoder = m, p.prototype.bomAware = !0, g.prototype.write = function (t) { for (var e = this.inBase64, n = this.base64Accum, i = this.base64AccumIdx, a = r.alloc(5 * t.length + 10), s = 0, o = 0; o < t.length; o++) { var c = t.charCodeAt(o); 32 <= c && c <= 126 ? (e && (i > 0 && (s += a.write(n.slice(0, i).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), s), i = 0), a[s++] = u, e = !1), e || (a[s++] = c, c === h && (a[s++] = u))) : (e || (a[s++] = h, e = !0), e && (n[i++] = c >> 8, n[i++] = 255 & c, i == n.length && (s += a.write(n.toString("base64").replace(/\//g, ","), s), i = 0))) } return this.inBase64 = e, this.base64AccumIdx = i, a.slice(0, s) }, g.prototype.end = function () { var t = r.alloc(10), e = 0; return this.inBase64 && (this.base64AccumIdx > 0 && (e += t.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), e), this.base64AccumIdx = 0), t[e++] = u, this.inBase64 = !1), t.slice(0, e) }; var b = l.slice(); b[",".charCodeAt(0)] = !0, m.prototype.write = function (t) { for (var e = "", n = 0, i = this.inBase64, a = this.base64Accum, s = 0; s < t.length; s++)if (i) { if (!b[t[s]]) { if (s == n && t[s] == u) e += "&"; else { var o = a + this.iconv.decode(t.slice(n, s), "ascii").replace(/,/g, "/"); e += this.iconv.decode(r.from(o, "base64"), "utf16-be") } t[s] != u && s--, n = s + 1, i = !1, a = "" } } else t[s] == h && (e += this.iconv.decode(t.slice(n, s), "ascii"), n = s + 1, i = !0); if (i) { var c = (o = a + this.iconv.decode(t.slice(n), "ascii").replace(/,/g, "/")).length - o.length % 8; a = o.slice(c), o = o.slice(0, c), e += this.iconv.decode(r.from(o, "base64"), "utf16-be") } else e += this.iconv.decode(t.slice(n), "ascii"); return this.inBase64 = i, this.base64Accum = a, e }, m.prototype.end = function () { var t = ""; return this.inBase64 && this.base64Accum.length > 0 && (t = this.iconv.decode(r.from(this.base64Accum, "base64"), "utf16-be")), this.inBase64 = !1, this.base64Accum = "", t } }, 67675: function (t, e) { "use strict"; function n(t, e) { this.encoder = t, this.addBOM = !0 } function r(t, e) { this.decoder = t, this.pass = !1, this.options = e || {} } e.PrependBOM = n, n.prototype.write = function (t) { return this.addBOM && (t = "\ufeff" + t, this.addBOM = !1), this.encoder.write(t) }, n.prototype.end = function () { return this.encoder.end() }, e.StripBOM = r, r.prototype.write = function (t) { var e = this.decoder.write(t); return this.pass || !e || ("\ufeff" === e[0] && (e = e.slice(1), "function" == typeof this.options.stripBOM && this.options.stripBOM()), this.pass = !0), e }, r.prototype.end = function () { return this.decoder.end() } }, 44574: function (t, e, n) { "use strict"; var r, i = n(27654).Buffer, a = n(67675), s = t.exports; s.encodings = null, s.defaultCharUnicode = "", s.defaultCharSingleByte = "?", s.encode = function (t, e, n) { t = "" + (t || ""); var r = s.getEncoder(e, n), a = r.write(t), o = r.end(); return o && o.length > 0 ? i.concat([a, o]) : a }, s.decode = function (t, e, n) { "string" == typeof t && (s.skipDecodeWarning || (console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding"), s.skipDecodeWarning = !0), t = i.from("" + (t || ""), "binary")); var r = s.getDecoder(e, n), a = r.write(t), o = r.end(); return o ? a + o : a }, s.encodingExists = function (t) { try { return s.getCodec(t), !0 } catch (t) { return !1 } }, s.toEncoding = s.encode, s.fromEncoding = s.decode, s._codecDataCache = {}, s.getCodec = function (t) { s.encodings || (s.encodings = n(41481)); for (var e = s._canonicalizeEncoding(t), r = {}; ;) { var i = s._codecDataCache[e]; if (i) return i; var a = s.encodings[e]; switch (typeof a) { case "string": e = a; break; case "object": for (var o in a) r[o] = a[o]; r.encodingName || (r.encodingName = e), e = a.type; break; case "function": return r.encodingName || (r.encodingName = e), i = new a(r, s), s._codecDataCache[r.encodingName] = i, i; default: throw new Error("Encoding not recognized: '" + t + "' (searched as: '" + e + "')") } } }, s._canonicalizeEncoding = function (t) { return ("" + t).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "") }, s.getEncoder = function (t, e) { var n = s.getCodec(t), r = new n.encoder(e, n); return n.bomAware && e && e.addBOM && (r = new a.PrependBOM(r, e)), r }, s.getDecoder = function (t, e) { var n = s.getCodec(t), r = new n.decoder(e, n); return !n.bomAware || e && !1 === e.stripBOM || (r = new a.StripBOM(r, e)), r }, s.enableStreamingAPI = function (t) { if (!s.supportsStreams) { var e = n(84225)(t); s.IconvLiteEncoderStream = e.IconvLiteEncoderStream, s.IconvLiteDecoderStream = e.IconvLiteDecoderStream, s.encodeStream = function (t, e) { return new s.IconvLiteEncoderStream(s.getEncoder(t, e), e) }, s.decodeStream = function (t, e) { return new s.IconvLiteDecoderStream(s.getDecoder(t, e), e) }, s.supportsStreams = !0 } }; try { r = n(7105) } catch (t) { } r && r.Transform ? s.enableStreamingAPI(r) : s.encodeStream = s.decodeStream = function () { throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.") } }, 84225: function (t, e, n) { "use strict"; var r = n(27654).Buffer; t.exports = function (t) { var e = t.Transform; function n(t, n) { this.conv = t, (n = n || {}).decodeStrings = !1, e.call(this, n) } function i(t, n) { this.conv = t, (n = n || {}).encoding = this.encoding = "utf8", e.call(this, n) } return n.prototype = Object.create(e.prototype, { constructor: { value: n } }), n.prototype._transform = function (t, e, n) { if ("string" != typeof t) return n(new Error("Iconv encoding stream needs strings as its input.")); try { var r = this.conv.write(t); r && r.length && this.push(r), n() } catch (t) { n(t) } }, n.prototype._flush = function (t) { try { var e = this.conv.end(); e && e.length && this.push(e), t() } catch (e) { t(e) } }, n.prototype.collect = function (t) { var e = []; return this.on("error", t), this.on("data", (function (t) { e.push(t) })), this.on("end", (function () { t(null, r.concat(e)) })), this }, i.prototype = Object.create(e.prototype, { constructor: { value: i } }), i.prototype._transform = function (t, e, n) { if (!(r.isBuffer(t) || t instanceof Uint8Array)) return n(new Error("Iconv decoding stream needs buffers as its input.")); try { var i = this.conv.write(t); i && i.length && this.push(i, this.encoding), n() } catch (t) { n(t) } }, i.prototype._flush = function (t) { try { var e = this.conv.end(); e && e.length && this.push(e, this.encoding), t() } catch (e) { t(e) } }, i.prototype.collect = function (t) { var e = ""; return this.on("error", t), this.on("data", (function (t) { e += t })), this.on("end", (function () { t(null, e) })), this }, { IconvLiteEncoderStream: n, IconvLiteDecoderStream: i } } }, 62333: function (t, e) {
    /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
    e.read = function (t, e, n, r, i) { var a, s, o = 8 * i - r - 1, c = (1 << o) - 1, l = c >> 1, f = -7, d = n ? i - 1 : 0, u = n ? -1 : 1, h = t[e + d]; for (d += u, a = h & (1 << -f) - 1, h >>= -f, f += o; f > 0; a = 256 * a + t[e + d], d += u, f -= 8); for (s = a & (1 << -f) - 1, a >>= -f, f += r; f > 0; s = 256 * s + t[e + d], d += u, f -= 8); if (0 === a) a = 1 - l; else { if (a === c) return s ? NaN : 1 / 0 * (h ? -1 : 1); s += Math.pow(2, r), a -= l } return (h ? -1 : 1) * s * Math.pow(2, a - r) }, e.write = function (t, e, n, r, i, a) { var s, o, c, l = 8 * a - i - 1, f = (1 << l) - 1, d = f >> 1, u = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, h = r ? 0 : a - 1, p = r ? 1 : -1, g = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0; for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (o = isNaN(e) ? 1 : 0, s = f) : (s = Math.floor(Math.log(e) / Math.LN2), e * (c = Math.pow(2, -s)) < 1 && (s--, c *= 2), (e += s + d >= 1 ? u / c : u * Math.pow(2, 1 - d)) * c >= 2 && (s++, c /= 2), s + d >= f ? (o = 0, s = f) : s + d >= 1 ? (o = (e * c - 1) * Math.pow(2, i), s += d) : (o = e * Math.pow(2, d - 1) * Math.pow(2, i), s = 0)); i >= 8; t[n + h] = 255 & o, h += p, o /= 256, i -= 8); for (s = s << i | o, l += i; l > 0; t[n + h] = 255 & s, h += p, s /= 256, l -= 8); t[n + h - p] |= 128 * g }
  }, 41427: function (t, e) { !function (t) { const e = Symbol("newer"), n = Symbol("older"); class r { constructor(t, e) { "number" != typeof t && (e = t, t = 0), this.size = 0, this.limit = t, this.oldest = this.newest = void 0, this._keymap = new Map, e && (this.assign(e), t < 1 && (this.limit = this.size)) } _markEntryAsUsed(t) { t !== this.newest && (t[e] && (t === this.oldest && (this.oldest = t[e]), t[e][n] = t[n]), t[n] && (t[n][e] = t[e]), t[e] = void 0, t[n] = this.newest, this.newest && (this.newest[e] = t), this.newest = t) } assign(t) { let r, a = this.limit || Number.MAX_VALUE; this._keymap.clear(); let s = t[Symbol.iterator](); for (let t = s.next(); !t.done; t = s.next()) { let s = new i(t.value[0], t.value[1]); if (this._keymap.set(s.key, s), r ? (r[e] = s, s[n] = r) : this.oldest = s, r = s, 0 == a--) throw new Error("overflow") } this.newest = r, this.size = this._keymap.size } get(t) { var e = this._keymap.get(t); return e ? (this._markEntryAsUsed(e), e.value) : void 0 } set(t, r) { var a = this._keymap.get(t); return a ? (a.value = r, this._markEntryAsUsed(a), this) : (this._keymap.set(t, a = new i(t, r)), this.newest ? (this.newest[e] = a, a[n] = this.newest) : this.oldest = a, this.newest = a, ++this.size, this.size > this.limit && this.shift(), this) } shift() { var t = this.oldest; if (t) return this.oldest[e] ? (this.oldest = this.oldest[e], this.oldest[n] = void 0) : (this.oldest = void 0, this.newest = void 0), t[e] = t[n] = void 0, this._keymap.delete(t.key), --this.size, [t.key, t.value] } find(t) { let e = this._keymap.get(t); return e ? e.value : void 0 } has(t) { return this._keymap.has(t) } delete(t) { var r = this._keymap.get(t); return r ? (this._keymap.delete(r.key), r[e] && r[n] ? (r[n][e] = r[e], r[e][n] = r[n]) : r[e] ? (r[e][n] = void 0, this.oldest = r[e]) : r[n] ? (r[n][e] = void 0, this.newest = r[n]) : this.oldest = this.newest = void 0, this.size--, r.value) : void 0 } clear() { this.oldest = this.newest = void 0, this.size = 0, this._keymap.clear() } keys() { return new s(this.oldest) } values() { return new o(this.oldest) } entries() { return this } [Symbol.iterator]() { return new a(this.oldest) } forEach(t, n) { "object" != typeof n && (n = this); let r = this.oldest; for (; r;)t.call(n, r.value, r.key, this), r = r[e] } toJSON() { for (var t = new Array(this.size), n = 0, r = this.oldest; r;)t[n++] = { key: r.key, value: r.value }, r = r[e]; return t } toString() { for (var t = "", n = this.oldest; n;)t += String(n.key) + ":" + n.value, (n = n[e]) && (t += " < "); return t } } function i(t, r) { this.key = t, this.value = r, this[e] = void 0, this[n] = void 0 } function a(t) { this.entry = t } function s(t) { this.entry = t } function o(t) { this.entry = t } t.LRUMap = r, a.prototype[Symbol.iterator] = function () { return this }, a.prototype.next = function () { let t = this.entry; return t ? (this.entry = t[e], { done: !1, value: [t.key, t.value] }) : { done: !0, value: void 0 } }, s.prototype[Symbol.iterator] = function () { return this }, s.prototype.next = function () { let t = this.entry; return t ? (this.entry = t[e], { done: !1, value: t.key }) : { done: !0, value: void 0 } }, o.prototype[Symbol.iterator] = function () { return this }, o.prototype.next = function () { let t = this.entry; return t ? (this.entry = t[e], { done: !1, value: t.value }) : { done: !0, value: void 0 } } }(e) }, 32845: function (t, e, n) { "use strict"; var r = {}; (0, n(49761).assign)(r, n(79880), n(21380), n(91271)), t.exports = r }, 79880: function (t, e, n) { "use strict"; var r = n(75789), i = n(49761), a = n(47944), s = n(82950), o = n(20744), c = Object.prototype.toString, l = 0, f = -1, d = 0, u = 8; function h(t) { if (!(this instanceof h)) return new h(t); this.options = i.assign({ level: f, method: u, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: d, to: "" }, t || {}); var e = this.options; e.raw && e.windowBits > 0 ? e.windowBits = -e.windowBits : e.gzip && e.windowBits > 0 && e.windowBits < 16 && (e.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new o, this.strm.avail_out = 0; var n = r.deflateInit2(this.strm, e.level, e.method, e.windowBits, e.memLevel, e.strategy); if (n !== l) throw new Error(s[n]); if (e.header && r.deflateSetHeader(this.strm, e.header), e.dictionary) { var p; if (p = "string" == typeof e.dictionary ? a.string2buf(e.dictionary) : "[object ArrayBuffer]" === c.call(e.dictionary) ? new Uint8Array(e.dictionary) : e.dictionary, (n = r.deflateSetDictionary(this.strm, p)) !== l) throw new Error(s[n]); this._dict_set = !0 } } function p(t, e) { var n = new h(e); if (n.push(t, !0), n.err) throw n.msg || s[n.err]; return n.result } h.prototype.push = function (t, e) { var n, s, o = this.strm, f = this.options.chunkSize; if (this.ended) return !1; s = e === ~~e ? e : !0 === e ? 4 : 0, "string" == typeof t ? o.input = a.string2buf(t) : "[object ArrayBuffer]" === c.call(t) ? o.input = new Uint8Array(t) : o.input = t, o.next_in = 0, o.avail_in = o.input.length; do { if (0 === o.avail_out && (o.output = new i.Buf8(f), o.next_out = 0, o.avail_out = f), 1 !== (n = r.deflate(o, s)) && n !== l) return this.onEnd(n), this.ended = !0, !1; 0 !== o.avail_out && (0 !== o.avail_in || 4 !== s && 2 !== s) || ("string" === this.options.to ? this.onData(a.buf2binstring(i.shrinkBuf(o.output, o.next_out))) : this.onData(i.shrinkBuf(o.output, o.next_out))) } while ((o.avail_in > 0 || 0 === o.avail_out) && 1 !== n); return 4 === s ? (n = r.deflateEnd(this.strm), this.onEnd(n), this.ended = !0, n === l) : 2 !== s || (this.onEnd(l), o.avail_out = 0, !0) }, h.prototype.onData = function (t) { this.chunks.push(t) }, h.prototype.onEnd = function (t) { t === l && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = i.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg }, e.Deflate = h, e.deflate = p, e.deflateRaw = function (t, e) { return (e = e || {}).raw = !0, p(t, e) }, e.gzip = function (t, e) { return (e = e || {}).gzip = !0, p(t, e) } }, 21380: function (t, e, n) { "use strict"; var r = n(35020), i = n(49761), a = n(47944), s = n(91271), o = n(82950), c = n(20744), l = n(7357), f = Object.prototype.toString; function d(t) { if (!(this instanceof d)) return new d(t); this.options = i.assign({ chunkSize: 16384, windowBits: 0, to: "" }, t || {}); var e = this.options; e.raw && e.windowBits >= 0 && e.windowBits < 16 && (e.windowBits = -e.windowBits, 0 === e.windowBits && (e.windowBits = -15)), !(e.windowBits >= 0 && e.windowBits < 16) || t && t.windowBits || (e.windowBits += 32), e.windowBits > 15 && e.windowBits < 48 && 0 == (15 & e.windowBits) && (e.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new c, this.strm.avail_out = 0; var n = r.inflateInit2(this.strm, e.windowBits); if (n !== s.Z_OK) throw new Error(o[n]); if (this.header = new l, r.inflateGetHeader(this.strm, this.header), e.dictionary && ("string" == typeof e.dictionary ? e.dictionary = a.string2buf(e.dictionary) : "[object ArrayBuffer]" === f.call(e.dictionary) && (e.dictionary = new Uint8Array(e.dictionary)), e.raw && (n = r.inflateSetDictionary(this.strm, e.dictionary)) !== s.Z_OK)) throw new Error(o[n]) } function u(t, e) { var n = new d(e); if (n.push(t, !0), n.err) throw n.msg || o[n.err]; return n.result } d.prototype.push = function (t, e) { var n, o, c, l, d, u = this.strm, h = this.options.chunkSize, p = this.options.dictionary, g = !1; if (this.ended) return !1; o = e === ~~e ? e : !0 === e ? s.Z_FINISH : s.Z_NO_FLUSH, "string" == typeof t ? u.input = a.binstring2buf(t) : "[object ArrayBuffer]" === f.call(t) ? u.input = new Uint8Array(t) : u.input = t, u.next_in = 0, u.avail_in = u.input.length; do { if (0 === u.avail_out && (u.output = new i.Buf8(h), u.next_out = 0, u.avail_out = h), (n = r.inflate(u, s.Z_NO_FLUSH)) === s.Z_NEED_DICT && p && (n = r.inflateSetDictionary(this.strm, p)), n === s.Z_BUF_ERROR && !0 === g && (n = s.Z_OK, g = !1), n !== s.Z_STREAM_END && n !== s.Z_OK) return this.onEnd(n), this.ended = !0, !1; u.next_out && (0 !== u.avail_out && n !== s.Z_STREAM_END && (0 !== u.avail_in || o !== s.Z_FINISH && o !== s.Z_SYNC_FLUSH) || ("string" === this.options.to ? (c = a.utf8border(u.output, u.next_out), l = u.next_out - c, d = a.buf2string(u.output, c), u.next_out = l, u.avail_out = h - l, l && i.arraySet(u.output, u.output, c, l, 0), this.onData(d)) : this.onData(i.shrinkBuf(u.output, u.next_out)))), 0 === u.avail_in && 0 === u.avail_out && (g = !0) } while ((u.avail_in > 0 || 0 === u.avail_out) && n !== s.Z_STREAM_END); return n === s.Z_STREAM_END && (o = s.Z_FINISH), o === s.Z_FINISH ? (n = r.inflateEnd(this.strm), this.onEnd(n), this.ended = !0, n === s.Z_OK) : o !== s.Z_SYNC_FLUSH || (this.onEnd(s.Z_OK), u.avail_out = 0, !0) }, d.prototype.onData = function (t) { this.chunks.push(t) }, d.prototype.onEnd = function (t) { t === s.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = i.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg }, e.Inflate = d, e.inflate = u, e.inflateRaw = function (t, e) { return (e = e || {}).raw = !0, u(t, e) }, e.ungzip = u }, 49761: function (t, e) { "use strict"; var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array; function r(t, e) { return Object.prototype.hasOwnProperty.call(t, e) } e.assign = function (t) { for (var e = Array.prototype.slice.call(arguments, 1); e.length;) { var n = e.shift(); if (n) { if ("object" != typeof n) throw new TypeError(n + "must be non-object"); for (var i in n) r(n, i) && (t[i] = n[i]) } } return t }, e.shrinkBuf = function (t, e) { return t.length === e ? t : t.subarray ? t.subarray(0, e) : (t.length = e, t) }; var i = { arraySet: function (t, e, n, r, i) { if (e.subarray && t.subarray) t.set(e.subarray(n, n + r), i); else for (var a = 0; a < r; a++)t[i + a] = e[n + a] }, flattenChunks: function (t) { var e, n, r, i, a, s; for (r = 0, e = 0, n = t.length; e < n; e++)r += t[e].length; for (s = new Uint8Array(r), i = 0, e = 0, n = t.length; e < n; e++)a = t[e], s.set(a, i), i += a.length; return s } }, a = { arraySet: function (t, e, n, r, i) { for (var a = 0; a < r; a++)t[i + a] = e[n + a] }, flattenChunks: function (t) { return [].concat.apply([], t) } }; e.setTyped = function (t) { t ? (e.Buf8 = Uint8Array, e.Buf16 = Uint16Array, e.Buf32 = Int32Array, e.assign(e, i)) : (e.Buf8 = Array, e.Buf16 = Array, e.Buf32 = Array, e.assign(e, a)) }, e.setTyped(n) }, 47944: function (t, e, n) { "use strict"; var r = n(49761), i = !0, a = !0; try { String.fromCharCode.apply(null, [0]) } catch (t) { i = !1 } try { String.fromCharCode.apply(null, new Uint8Array(1)) } catch (t) { a = !1 } for (var s = new r.Buf8(256), o = 0; o < 256; o++)s[o] = o >= 252 ? 6 : o >= 248 ? 5 : o >= 240 ? 4 : o >= 224 ? 3 : o >= 192 ? 2 : 1; function c(t, e) { if (e < 65534 && (t.subarray && a || !t.subarray && i)) return String.fromCharCode.apply(null, r.shrinkBuf(t, e)); for (var n = "", s = 0; s < e; s++)n += String.fromCharCode(t[s]); return n } s[254] = s[254] = 1, e.string2buf = function (t) { var e, n, i, a, s, o = t.length, c = 0; for (a = 0; a < o; a++)55296 == (64512 & (n = t.charCodeAt(a))) && a + 1 < o && 56320 == (64512 & (i = t.charCodeAt(a + 1))) && (n = 65536 + (n - 55296 << 10) + (i - 56320), a++), c += n < 128 ? 1 : n < 2048 ? 2 : n < 65536 ? 3 : 4; for (e = new r.Buf8(c), s = 0, a = 0; s < c; a++)55296 == (64512 & (n = t.charCodeAt(a))) && a + 1 < o && 56320 == (64512 & (i = t.charCodeAt(a + 1))) && (n = 65536 + (n - 55296 << 10) + (i - 56320), a++), n < 128 ? e[s++] = n : n < 2048 ? (e[s++] = 192 | n >>> 6, e[s++] = 128 | 63 & n) : n < 65536 ? (e[s++] = 224 | n >>> 12, e[s++] = 128 | n >>> 6 & 63, e[s++] = 128 | 63 & n) : (e[s++] = 240 | n >>> 18, e[s++] = 128 | n >>> 12 & 63, e[s++] = 128 | n >>> 6 & 63, e[s++] = 128 | 63 & n); return e }, e.buf2binstring = function (t) { return c(t, t.length) }, e.binstring2buf = function (t) { for (var e = new r.Buf8(t.length), n = 0, i = e.length; n < i; n++)e[n] = t.charCodeAt(n); return e }, e.buf2string = function (t, e) { var n, r, i, a, o = e || t.length, l = new Array(2 * o); for (r = 0, n = 0; n < o;)if ((i = t[n++]) < 128) l[r++] = i; else if ((a = s[i]) > 4) l[r++] = 65533, n += a - 1; else { for (i &= 2 === a ? 31 : 3 === a ? 15 : 7; a > 1 && n < o;)i = i << 6 | 63 & t[n++], a--; a > 1 ? l[r++] = 65533 : i < 65536 ? l[r++] = i : (i -= 65536, l[r++] = 55296 | i >> 10 & 1023, l[r++] = 56320 | 1023 & i) } return c(l, r) }, e.utf8border = function (t, e) { var n; for ((e = e || t.length) > t.length && (e = t.length), n = e - 1; n >= 0 && 128 == (192 & t[n]);)n--; return n < 0 || 0 === n ? e : n + s[t[n]] > e ? n : e } }, 95562: function (t) { "use strict"; t.exports = function (t, e, n, r) { for (var i = 65535 & t | 0, a = t >>> 16 & 65535 | 0, s = 0; 0 !== n;) { n -= s = n > 2e3 ? 2e3 : n; do { a = a + (i = i + e[r++] | 0) | 0 } while (--s); i %= 65521, a %= 65521 } return i | a << 16 | 0 } }, 91271: function (t) { "use strict"; t.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 } }, 24299: function (t) { "use strict"; var e = function () { for (var t, e = [], n = 0; n < 256; n++) { t = n; for (var r = 0; r < 8; r++)t = 1 & t ? 3988292384 ^ t >>> 1 : t >>> 1; e[n] = t } return e }(); t.exports = function (t, n, r, i) { var a = e, s = i + r; t ^= -1; for (var o = i; o < s; o++)t = t >>> 8 ^ a[255 & (t ^ n[o])]; return -1 ^ t } }, 75789: function (t, e, n) { "use strict"; var r, i = n(49761), a = n(69564), s = n(95562), o = n(24299), c = n(82950), l = 0, f = 4, d = 0, u = -2, h = -1, p = 4, g = 2, m = 8, b = 9, w = 286, y = 30, v = 19, _ = 2 * w + 1, x = 15, k = 3, E = 258, A = E + k + 1, S = 42, B = 103, z = 113, C = 666, U = 1, I = 2, T = 3, N = 4; function j(t, e) { return t.msg = c[e], e } function O(t) { return (t << 1) - (t > 4 ? 9 : 0) } function D(t) { for (var e = t.length; --e >= 0;)t[e] = 0 } function M(t) { var e = t.state, n = e.pending; n > t.avail_out && (n = t.avail_out), 0 !== n && (i.arraySet(t.output, e.pending_buf, e.pending_out, n, t.next_out), t.next_out += n, e.pending_out += n, t.total_out += n, t.avail_out -= n, e.pending -= n, 0 === e.pending && (e.pending_out = 0)) } function R(t, e) { a._tr_flush_block(t, t.block_start >= 0 ? t.block_start : -1, t.strstart - t.block_start, e), t.block_start = t.strstart, M(t.strm) } function L(t, e) { t.pending_buf[t.pending++] = e } function F(t, e) { t.pending_buf[t.pending++] = e >>> 8 & 255, t.pending_buf[t.pending++] = 255 & e } function P(t, e) { var n, r, i = t.max_chain_length, a = t.strstart, s = t.prev_length, o = t.nice_match, c = t.strstart > t.w_size - A ? t.strstart - (t.w_size - A) : 0, l = t.window, f = t.w_mask, d = t.prev, u = t.strstart + E, h = l[a + s - 1], p = l[a + s]; t.prev_length >= t.good_match && (i >>= 2), o > t.lookahead && (o = t.lookahead); do { if (l[(n = e) + s] === p && l[n + s - 1] === h && l[n] === l[a] && l[++n] === l[a + 1]) { a += 2, n++; do { } while (l[++a] === l[++n] && l[++a] === l[++n] && l[++a] === l[++n] && l[++a] === l[++n] && l[++a] === l[++n] && l[++a] === l[++n] && l[++a] === l[++n] && l[++a] === l[++n] && a < u); if (r = E - (u - a), a = u - E, r > s) { if (t.match_start = e, s = r, r >= o) break; h = l[a + s - 1], p = l[a + s] } } } while ((e = d[e & f]) > c && 0 != --i); return s <= t.lookahead ? s : t.lookahead } function V(t) { var e, n, r, a, c, l, f, d, u, h, p = t.w_size; do { if (a = t.window_size - t.lookahead - t.strstart, t.strstart >= p + (p - A)) { i.arraySet(t.window, t.window, p, p, 0), t.match_start -= p, t.strstart -= p, t.block_start -= p, e = n = t.hash_size; do { r = t.head[--e], t.head[e] = r >= p ? r - p : 0 } while (--n); e = n = p; do { r = t.prev[--e], t.prev[e] = r >= p ? r - p : 0 } while (--n); a += p } if (0 === t.strm.avail_in) break; if (l = t.strm, f = t.window, d = t.strstart + t.lookahead, u = a, h = void 0, (h = l.avail_in) > u && (h = u), n = 0 === h ? 0 : (l.avail_in -= h, i.arraySet(f, l.input, l.next_in, h, d), 1 === l.state.wrap ? l.adler = s(l.adler, f, h, d) : 2 === l.state.wrap && (l.adler = o(l.adler, f, h, d)), l.next_in += h, l.total_in += h, h), t.lookahead += n, t.lookahead + t.insert >= k) for (c = t.strstart - t.insert, t.ins_h = t.window[c], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[c + 1]) & t.hash_mask; t.insert && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[c + k - 1]) & t.hash_mask, t.prev[c & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = c, c++, t.insert--, !(t.lookahead + t.insert < k));); } while (t.lookahead < A && 0 !== t.strm.avail_in) } function Z(t, e) { for (var n, r; ;) { if (t.lookahead < A) { if (V(t), t.lookahead < A && e === l) return U; if (0 === t.lookahead) break } if (n = 0, t.lookahead >= k && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + k - 1]) & t.hash_mask, n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), 0 !== n && t.strstart - n <= t.w_size - A && (t.match_length = P(t, n)), t.match_length >= k) if (r = a._tr_tally(t, t.strstart - t.match_start, t.match_length - k), t.lookahead -= t.match_length, t.match_length <= t.max_lazy_match && t.lookahead >= k) { t.match_length--; do { t.strstart++, t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + k - 1]) & t.hash_mask, n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart } while (0 != --t.match_length); t.strstart++ } else t.strstart += t.match_length, t.match_length = 0, t.ins_h = t.window[t.strstart], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 1]) & t.hash_mask; else r = a._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++; if (r && (R(t, !1), 0 === t.strm.avail_out)) return U } return t.insert = t.strstart < k - 1 ? t.strstart : k - 1, e === f ? (R(t, !0), 0 === t.strm.avail_out ? T : N) : t.last_lit && (R(t, !1), 0 === t.strm.avail_out) ? U : I } function q(t, e) { for (var n, r, i; ;) { if (t.lookahead < A) { if (V(t), t.lookahead < A && e === l) return U; if (0 === t.lookahead) break } if (n = 0, t.lookahead >= k && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + k - 1]) & t.hash_mask, n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), t.prev_length = t.match_length, t.prev_match = t.match_start, t.match_length = k - 1, 0 !== n && t.prev_length < t.max_lazy_match && t.strstart - n <= t.w_size - A && (t.match_length = P(t, n), t.match_length <= 5 && (1 === t.strategy || t.match_length === k && t.strstart - t.match_start > 4096) && (t.match_length = k - 1)), t.prev_length >= k && t.match_length <= t.prev_length) { i = t.strstart + t.lookahead - k, r = a._tr_tally(t, t.strstart - 1 - t.prev_match, t.prev_length - k), t.lookahead -= t.prev_length - 1, t.prev_length -= 2; do { ++t.strstart <= i && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + k - 1]) & t.hash_mask, n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart) } while (0 != --t.prev_length); if (t.match_available = 0, t.match_length = k - 1, t.strstart++, r && (R(t, !1), 0 === t.strm.avail_out)) return U } else if (t.match_available) { if ((r = a._tr_tally(t, 0, t.window[t.strstart - 1])) && R(t, !1), t.strstart++, t.lookahead--, 0 === t.strm.avail_out) return U } else t.match_available = 1, t.strstart++, t.lookahead-- } return t.match_available && (r = a._tr_tally(t, 0, t.window[t.strstart - 1]), t.match_available = 0), t.insert = t.strstart < k - 1 ? t.strstart : k - 1, e === f ? (R(t, !0), 0 === t.strm.avail_out ? T : N) : t.last_lit && (R(t, !1), 0 === t.strm.avail_out) ? U : I } function H(t, e, n, r, i) { this.good_length = t, this.max_lazy = e, this.nice_length = n, this.max_chain = r, this.func = i } function W() { this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = m, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new i.Buf16(2 * _), this.dyn_dtree = new i.Buf16(2 * (2 * y + 1)), this.bl_tree = new i.Buf16(2 * (2 * v + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new i.Buf16(x + 1), this.heap = new i.Buf16(2 * w + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new i.Buf16(2 * w + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0 } function $(t) { var e; return t && t.state ? (t.total_in = t.total_out = 0, t.data_type = g, (e = t.state).pending = 0, e.pending_out = 0, e.wrap < 0 && (e.wrap = -e.wrap), e.status = e.wrap ? S : z, t.adler = 2 === e.wrap ? 0 : 1, e.last_flush = l, a._tr_init(e), d) : j(t, u) } function Q(t) { var e, n = $(t); return n === d && ((e = t.state).window_size = 2 * e.w_size, D(e.head), e.max_lazy_match = r[e.level].max_lazy, e.good_match = r[e.level].good_length, e.nice_match = r[e.level].nice_length, e.max_chain_length = r[e.level].max_chain, e.strstart = 0, e.block_start = 0, e.lookahead = 0, e.insert = 0, e.match_length = e.prev_length = k - 1, e.match_available = 0, e.ins_h = 0), n } function G(t, e, n, r, a, s) { if (!t) return u; var o = 1; if (e === h && (e = 6), r < 0 ? (o = 0, r = -r) : r > 15 && (o = 2, r -= 16), a < 1 || a > b || n !== m || r < 8 || r > 15 || e < 0 || e > 9 || s < 0 || s > p) return j(t, u); 8 === r && (r = 9); var c = new W; return t.state = c, c.strm = t, c.wrap = o, c.gzhead = null, c.w_bits = r, c.w_size = 1 << c.w_bits, c.w_mask = c.w_size - 1, c.hash_bits = a + 7, c.hash_size = 1 << c.hash_bits, c.hash_mask = c.hash_size - 1, c.hash_shift = ~~((c.hash_bits + k - 1) / k), c.window = new i.Buf8(2 * c.w_size), c.head = new i.Buf16(c.hash_size), c.prev = new i.Buf16(c.w_size), c.lit_bufsize = 1 << a + 6, c.pending_buf_size = 4 * c.lit_bufsize, c.pending_buf = new i.Buf8(c.pending_buf_size), c.d_buf = 1 * c.lit_bufsize, c.l_buf = 3 * c.lit_bufsize, c.level = e, c.strategy = s, c.method = n, Q(t) } r = [new H(0, 0, 0, 0, (function (t, e) { var n = 65535; for (n > t.pending_buf_size - 5 && (n = t.pending_buf_size - 5); ;) { if (t.lookahead <= 1) { if (V(t), 0 === t.lookahead && e === l) return U; if (0 === t.lookahead) break } t.strstart += t.lookahead, t.lookahead = 0; var r = t.block_start + n; if ((0 === t.strstart || t.strstart >= r) && (t.lookahead = t.strstart - r, t.strstart = r, R(t, !1), 0 === t.strm.avail_out)) return U; if (t.strstart - t.block_start >= t.w_size - A && (R(t, !1), 0 === t.strm.avail_out)) return U } return t.insert = 0, e === f ? (R(t, !0), 0 === t.strm.avail_out ? T : N) : (t.strstart > t.block_start && (R(t, !1), t.strm.avail_out), U) })), new H(4, 4, 8, 4, Z), new H(4, 5, 16, 8, Z), new H(4, 6, 32, 32, Z), new H(4, 4, 16, 16, q), new H(8, 16, 32, 32, q), new H(8, 16, 128, 128, q), new H(8, 32, 128, 256, q), new H(32, 128, 258, 1024, q), new H(32, 258, 258, 4096, q)], e.deflateInit = function (t, e) { return G(t, e, m, 15, 8, 0) }, e.deflateInit2 = G, e.deflateReset = Q, e.deflateResetKeep = $, e.deflateSetHeader = function (t, e) { return t && t.state ? 2 !== t.state.wrap ? u : (t.state.gzhead = e, d) : u }, e.deflate = function (t, e) { var n, i, s, c; if (!t || !t.state || e > 5 || e < 0) return t ? j(t, u) : u; if (i = t.state, !t.output || !t.input && 0 !== t.avail_in || i.status === C && e !== f) return j(t, 0 === t.avail_out ? -5 : u); if (i.strm = t, n = i.last_flush, i.last_flush = e, i.status === S) if (2 === i.wrap) t.adler = 0, L(i, 31), L(i, 139), L(i, 8), i.gzhead ? (L(i, (i.gzhead.text ? 1 : 0) + (i.gzhead.hcrc ? 2 : 0) + (i.gzhead.extra ? 4 : 0) + (i.gzhead.name ? 8 : 0) + (i.gzhead.comment ? 16 : 0)), L(i, 255 & i.gzhead.time), L(i, i.gzhead.time >> 8 & 255), L(i, i.gzhead.time >> 16 & 255), L(i, i.gzhead.time >> 24 & 255), L(i, 9 === i.level ? 2 : i.strategy >= 2 || i.level < 2 ? 4 : 0), L(i, 255 & i.gzhead.os), i.gzhead.extra && i.gzhead.extra.length && (L(i, 255 & i.gzhead.extra.length), L(i, i.gzhead.extra.length >> 8 & 255)), i.gzhead.hcrc && (t.adler = o(t.adler, i.pending_buf, i.pending, 0)), i.gzindex = 0, i.status = 69) : (L(i, 0), L(i, 0), L(i, 0), L(i, 0), L(i, 0), L(i, 9 === i.level ? 2 : i.strategy >= 2 || i.level < 2 ? 4 : 0), L(i, 3), i.status = z); else { var h = m + (i.w_bits - 8 << 4) << 8; h |= (i.strategy >= 2 || i.level < 2 ? 0 : i.level < 6 ? 1 : 6 === i.level ? 2 : 3) << 6, 0 !== i.strstart && (h |= 32), h += 31 - h % 31, i.status = z, F(i, h), 0 !== i.strstart && (F(i, t.adler >>> 16), F(i, 65535 & t.adler)), t.adler = 1 } if (69 === i.status) if (i.gzhead.extra) { for (s = i.pending; i.gzindex < (65535 & i.gzhead.extra.length) && (i.pending !== i.pending_buf_size || (i.gzhead.hcrc && i.pending > s && (t.adler = o(t.adler, i.pending_buf, i.pending - s, s)), M(t), s = i.pending, i.pending !== i.pending_buf_size));)L(i, 255 & i.gzhead.extra[i.gzindex]), i.gzindex++; i.gzhead.hcrc && i.pending > s && (t.adler = o(t.adler, i.pending_buf, i.pending - s, s)), i.gzindex === i.gzhead.extra.length && (i.gzindex = 0, i.status = 73) } else i.status = 73; if (73 === i.status) if (i.gzhead.name) { s = i.pending; do { if (i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > s && (t.adler = o(t.adler, i.pending_buf, i.pending - s, s)), M(t), s = i.pending, i.pending === i.pending_buf_size)) { c = 1; break } c = i.gzindex < i.gzhead.name.length ? 255 & i.gzhead.name.charCodeAt(i.gzindex++) : 0, L(i, c) } while (0 !== c); i.gzhead.hcrc && i.pending > s && (t.adler = o(t.adler, i.pending_buf, i.pending - s, s)), 0 === c && (i.gzindex = 0, i.status = 91) } else i.status = 91; if (91 === i.status) if (i.gzhead.comment) { s = i.pending; do { if (i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > s && (t.adler = o(t.adler, i.pending_buf, i.pending - s, s)), M(t), s = i.pending, i.pending === i.pending_buf_size)) { c = 1; break } c = i.gzindex < i.gzhead.comment.length ? 255 & i.gzhead.comment.charCodeAt(i.gzindex++) : 0, L(i, c) } while (0 !== c); i.gzhead.hcrc && i.pending > s && (t.adler = o(t.adler, i.pending_buf, i.pending - s, s)), 0 === c && (i.status = B) } else i.status = B; if (i.status === B && (i.gzhead.hcrc ? (i.pending + 2 > i.pending_buf_size && M(t), i.pending + 2 <= i.pending_buf_size && (L(i, 255 & t.adler), L(i, t.adler >> 8 & 255), t.adler = 0, i.status = z)) : i.status = z), 0 !== i.pending) { if (M(t), 0 === t.avail_out) return i.last_flush = -1, d } else if (0 === t.avail_in && O(e) <= O(n) && e !== f) return j(t, -5); if (i.status === C && 0 !== t.avail_in) return j(t, -5); if (0 !== t.avail_in || 0 !== i.lookahead || e !== l && i.status !== C) { var p = 2 === i.strategy ? function (t, e) { for (var n; ;) { if (0 === t.lookahead && (V(t), 0 === t.lookahead)) { if (e === l) return U; break } if (t.match_length = 0, n = a._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++, n && (R(t, !1), 0 === t.strm.avail_out)) return U } return t.insert = 0, e === f ? (R(t, !0), 0 === t.strm.avail_out ? T : N) : t.last_lit && (R(t, !1), 0 === t.strm.avail_out) ? U : I }(i, e) : 3 === i.strategy ? function (t, e) { for (var n, r, i, s, o = t.window; ;) { if (t.lookahead <= E) { if (V(t), t.lookahead <= E && e === l) return U; if (0 === t.lookahead) break } if (t.match_length = 0, t.lookahead >= k && t.strstart > 0 && (r = o[i = t.strstart - 1]) === o[++i] && r === o[++i] && r === o[++i]) { s = t.strstart + E; do { } while (r === o[++i] && r === o[++i] && r === o[++i] && r === o[++i] && r === o[++i] && r === o[++i] && r === o[++i] && r === o[++i] && i < s); t.match_length = E - (s - i), t.match_length > t.lookahead && (t.match_length = t.lookahead) } if (t.match_length >= k ? (n = a._tr_tally(t, 1, t.match_length - k), t.lookahead -= t.match_length, t.strstart += t.match_length, t.match_length = 0) : (n = a._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++), n && (R(t, !1), 0 === t.strm.avail_out)) return U } return t.insert = 0, e === f ? (R(t, !0), 0 === t.strm.avail_out ? T : N) : t.last_lit && (R(t, !1), 0 === t.strm.avail_out) ? U : I }(i, e) : r[i.level].func(i, e); if (p !== T && p !== N || (i.status = C), p === U || p === T) return 0 === t.avail_out && (i.last_flush = -1), d; if (p === I && (1 === e ? a._tr_align(i) : 5 !== e && (a._tr_stored_block(i, 0, 0, !1), 3 === e && (D(i.head), 0 === i.lookahead && (i.strstart = 0, i.block_start = 0, i.insert = 0))), M(t), 0 === t.avail_out)) return i.last_flush = -1, d } return e !== f ? d : i.wrap <= 0 ? 1 : (2 === i.wrap ? (L(i, 255 & t.adler), L(i, t.adler >> 8 & 255), L(i, t.adler >> 16 & 255), L(i, t.adler >> 24 & 255), L(i, 255 & t.total_in), L(i, t.total_in >> 8 & 255), L(i, t.total_in >> 16 & 255), L(i, t.total_in >> 24 & 255)) : (F(i, t.adler >>> 16), F(i, 65535 & t.adler)), M(t), i.wrap > 0 && (i.wrap = -i.wrap), 0 !== i.pending ? d : 1) }, e.deflateEnd = function (t) { var e; return t && t.state ? (e = t.state.status) !== S && 69 !== e && 73 !== e && 91 !== e && e !== B && e !== z && e !== C ? j(t, u) : (t.state = null, e === z ? j(t, -3) : d) : u }, e.deflateSetDictionary = function (t, e) { var n, r, a, o, c, l, f, h, p = e.length; if (!t || !t.state) return u; if (2 === (o = (n = t.state).wrap) || 1 === o && n.status !== S || n.lookahead) return u; for (1 === o && (t.adler = s(t.adler, e, p, 0)), n.wrap = 0, p >= n.w_size && (0 === o && (D(n.head), n.strstart = 0, n.block_start = 0, n.insert = 0), h = new i.Buf8(n.w_size), i.arraySet(h, e, p - n.w_size, n.w_size, 0), e = h, p = n.w_size), c = t.avail_in, l = t.next_in, f = t.input, t.avail_in = p, t.next_in = 0, t.input = e, V(n); n.lookahead >= k;) { r = n.strstart, a = n.lookahead - (k - 1); do { n.ins_h = (n.ins_h << n.hash_shift ^ n.window[r + k - 1]) & n.hash_mask, n.prev[r & n.w_mask] = n.head[n.ins_h], n.head[n.ins_h] = r, r++ } while (--a); n.strstart = r, n.lookahead = k - 1, V(n) } return n.strstart += n.lookahead, n.block_start = n.strstart, n.insert = n.lookahead, n.lookahead = 0, n.match_length = n.prev_length = k - 1, n.match_available = 0, t.next_in = l, t.input = f, t.avail_in = c, n.wrap = o, d }, e.deflateInfo = "pako deflate (from Nodeca project)" }, 7357: function (t) { "use strict"; t.exports = function () { this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1 } }, 24980: function (t) { "use strict"; t.exports = function (t, e) { var n, r, i, a, s, o, c, l, f, d, u, h, p, g, m, b, w, y, v, _, x, k, E, A, S; n = t.state, r = t.next_in, A = t.input, i = r + (t.avail_in - 5), a = t.next_out, S = t.output, s = a - (e - t.avail_out), o = a + (t.avail_out - 257), c = n.dmax, l = n.wsize, f = n.whave, d = n.wnext, u = n.window, h = n.hold, p = n.bits, g = n.lencode, m = n.distcode, b = (1 << n.lenbits) - 1, w = (1 << n.distbits) - 1; t: do { p < 15 && (h += A[r++] << p, p += 8, h += A[r++] << p, p += 8), y = g[h & b]; e: for (; ;) { if (h >>>= v = y >>> 24, p -= v, 0 === (v = y >>> 16 & 255)) S[a++] = 65535 & y; else { if (!(16 & v)) { if (0 == (64 & v)) { y = g[(65535 & y) + (h & (1 << v) - 1)]; continue e } if (32 & v) { n.mode = 12; break t } t.msg = "invalid literal/length code", n.mode = 30; break t } _ = 65535 & y, (v &= 15) && (p < v && (h += A[r++] << p, p += 8), _ += h & (1 << v) - 1, h >>>= v, p -= v), p < 15 && (h += A[r++] << p, p += 8, h += A[r++] << p, p += 8), y = m[h & w]; n: for (; ;) { if (h >>>= v = y >>> 24, p -= v, !(16 & (v = y >>> 16 & 255))) { if (0 == (64 & v)) { y = m[(65535 & y) + (h & (1 << v) - 1)]; continue n } t.msg = "invalid distance code", n.mode = 30; break t } if (x = 65535 & y, p < (v &= 15) && (h += A[r++] << p, (p += 8) < v && (h += A[r++] << p, p += 8)), (x += h & (1 << v) - 1) > c) { t.msg = "invalid distance too far back", n.mode = 30; break t } if (h >>>= v, p -= v, x > (v = a - s)) { if ((v = x - v) > f && n.sane) { t.msg = "invalid distance too far back", n.mode = 30; break t } if (k = 0, E = u, 0 === d) { if (k += l - v, v < _) { _ -= v; do { S[a++] = u[k++] } while (--v); k = a - x, E = S } } else if (d < v) { if (k += l + d - v, (v -= d) < _) { _ -= v; do { S[a++] = u[k++] } while (--v); if (k = 0, d < _) { _ -= v = d; do { S[a++] = u[k++] } while (--v); k = a - x, E = S } } } else if (k += d - v, v < _) { _ -= v; do { S[a++] = u[k++] } while (--v); k = a - x, E = S } for (; _ > 2;)S[a++] = E[k++], S[a++] = E[k++], S[a++] = E[k++], _ -= 3; _ && (S[a++] = E[k++], _ > 1 && (S[a++] = E[k++])) } else { k = a - x; do { S[a++] = S[k++], S[a++] = S[k++], S[a++] = S[k++], _ -= 3 } while (_ > 2); _ && (S[a++] = S[k++], _ > 1 && (S[a++] = S[k++])) } break } } break } } while (r < i && a < o); r -= _ = p >> 3, h &= (1 << (p -= _ << 3)) - 1, t.next_in = r, t.next_out = a, t.avail_in = r < i ? i - r + 5 : 5 - (r - i), t.avail_out = a < o ? o - a + 257 : 257 - (a - o), n.hold = h, n.bits = p } }, 35020: function (t, e, n) { "use strict"; var r = n(49761), i = n(95562), a = n(24299), s = n(24980), o = n(50881), c = 1, l = 2, f = 0, d = -2, u = 1, h = 12, p = 30, g = 852, m = 592; function b(t) { return (t >>> 24 & 255) + (t >>> 8 & 65280) + ((65280 & t) << 8) + ((255 & t) << 24) } function w() { this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new r.Buf16(320), this.work = new r.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0 } function y(t) { var e; return t && t.state ? (e = t.state, t.total_in = t.total_out = e.total = 0, t.msg = "", e.wrap && (t.adler = 1 & e.wrap), e.mode = u, e.last = 0, e.havedict = 0, e.dmax = 32768, e.head = null, e.hold = 0, e.bits = 0, e.lencode = e.lendyn = new r.Buf32(g), e.distcode = e.distdyn = new r.Buf32(m), e.sane = 1, e.back = -1, f) : d } function v(t) { var e; return t && t.state ? ((e = t.state).wsize = 0, e.whave = 0, e.wnext = 0, y(t)) : d } function _(t, e) { var n, r; return t && t.state ? (r = t.state, e < 0 ? (n = 0, e = -e) : (n = 1 + (e >> 4), e < 48 && (e &= 15)), e && (e < 8 || e > 15) ? d : (null !== r.window && r.wbits !== e && (r.window = null), r.wrap = n, r.wbits = e, v(t))) : d } function x(t, e) { var n, r; return t ? (r = new w, t.state = r, r.window = null, (n = _(t, e)) !== f && (t.state = null), n) : d } var k, E, A = !0; function S(t) { if (A) { var e; for (k = new r.Buf32(512), E = new r.Buf32(32), e = 0; e < 144;)t.lens[e++] = 8; for (; e < 256;)t.lens[e++] = 9; for (; e < 280;)t.lens[e++] = 7; for (; e < 288;)t.lens[e++] = 8; for (o(c, t.lens, 0, 288, k, 0, t.work, { bits: 9 }), e = 0; e < 32;)t.lens[e++] = 5; o(l, t.lens, 0, 32, E, 0, t.work, { bits: 5 }), A = !1 } t.lencode = k, t.lenbits = 9, t.distcode = E, t.distbits = 5 } function B(t, e, n, i) { var a, s = t.state; return null === s.window && (s.wsize = 1 << s.wbits, s.wnext = 0, s.whave = 0, s.window = new r.Buf8(s.wsize)), i >= s.wsize ? (r.arraySet(s.window, e, n - s.wsize, s.wsize, 0), s.wnext = 0, s.whave = s.wsize) : ((a = s.wsize - s.wnext) > i && (a = i), r.arraySet(s.window, e, n - i, a, s.wnext), (i -= a) ? (r.arraySet(s.window, e, n - i, i, 0), s.wnext = i, s.whave = s.wsize) : (s.wnext += a, s.wnext === s.wsize && (s.wnext = 0), s.whave < s.wsize && (s.whave += a))), 0 } e.inflateReset = v, e.inflateReset2 = _, e.inflateResetKeep = y, e.inflateInit = function (t) { return x(t, 15) }, e.inflateInit2 = x, e.inflate = function (t, e) { var n, g, m, w, y, v, _, x, k, E, A, z, C, U, I, T, N, j, O, D, M, R, L, F, P = 0, V = new r.Buf8(4), Z = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]; if (!t || !t.state || !t.output || !t.input && 0 !== t.avail_in) return d; (n = t.state).mode === h && (n.mode = 13), y = t.next_out, m = t.output, _ = t.avail_out, w = t.next_in, g = t.input, v = t.avail_in, x = n.hold, k = n.bits, E = v, A = _, R = f; t: for (; ;)switch (n.mode) { case u: if (0 === n.wrap) { n.mode = 13; break } for (; k < 16;) { if (0 === v) break t; v--, x += g[w++] << k, k += 8 } if (2 & n.wrap && 35615 === x) { n.check = 0, V[0] = 255 & x, V[1] = x >>> 8 & 255, n.check = a(n.check, V, 2, 0), x = 0, k = 0, n.mode = 2; break } if (n.flags = 0, n.head && (n.head.done = !1), !(1 & n.wrap) || (((255 & x) << 8) + (x >> 8)) % 31) { t.msg = "incorrect header check", n.mode = p; break } if (8 != (15 & x)) { t.msg = "unknown compression method", n.mode = p; break } if (k -= 4, M = 8 + (15 & (x >>>= 4)), 0 === n.wbits) n.wbits = M; else if (M > n.wbits) { t.msg = "invalid window size", n.mode = p; break } n.dmax = 1 << M, t.adler = n.check = 1, n.mode = 512 & x ? 10 : h, x = 0, k = 0; break; case 2: for (; k < 16;) { if (0 === v) break t; v--, x += g[w++] << k, k += 8 } if (n.flags = x, 8 != (255 & n.flags)) { t.msg = "unknown compression method", n.mode = p; break } if (57344 & n.flags) { t.msg = "unknown header flags set", n.mode = p; break } n.head && (n.head.text = x >> 8 & 1), 512 & n.flags && (V[0] = 255 & x, V[1] = x >>> 8 & 255, n.check = a(n.check, V, 2, 0)), x = 0, k = 0, n.mode = 3; case 3: for (; k < 32;) { if (0 === v) break t; v--, x += g[w++] << k, k += 8 } n.head && (n.head.time = x), 512 & n.flags && (V[0] = 255 & x, V[1] = x >>> 8 & 255, V[2] = x >>> 16 & 255, V[3] = x >>> 24 & 255, n.check = a(n.check, V, 4, 0)), x = 0, k = 0, n.mode = 4; case 4: for (; k < 16;) { if (0 === v) break t; v--, x += g[w++] << k, k += 8 } n.head && (n.head.xflags = 255 & x, n.head.os = x >> 8), 512 & n.flags && (V[0] = 255 & x, V[1] = x >>> 8 & 255, n.check = a(n.check, V, 2, 0)), x = 0, k = 0, n.mode = 5; case 5: if (1024 & n.flags) { for (; k < 16;) { if (0 === v) break t; v--, x += g[w++] << k, k += 8 } n.length = x, n.head && (n.head.extra_len = x), 512 & n.flags && (V[0] = 255 & x, V[1] = x >>> 8 & 255, n.check = a(n.check, V, 2, 0)), x = 0, k = 0 } else n.head && (n.head.extra = null); n.mode = 6; case 6: if (1024 & n.flags && ((z = n.length) > v && (z = v), z && (n.head && (M = n.head.extra_len - n.length, n.head.extra || (n.head.extra = new Array(n.head.extra_len)), r.arraySet(n.head.extra, g, w, z, M)), 512 & n.flags && (n.check = a(n.check, g, z, w)), v -= z, w += z, n.length -= z), n.length)) break t; n.length = 0, n.mode = 7; case 7: if (2048 & n.flags) { if (0 === v) break t; z = 0; do { M = g[w + z++], n.head && M && n.length < 65536 && (n.head.name += String.fromCharCode(M)) } while (M && z < v); if (512 & n.flags && (n.check = a(n.check, g, z, w)), v -= z, w += z, M) break t } else n.head && (n.head.name = null); n.length = 0, n.mode = 8; case 8: if (4096 & n.flags) { if (0 === v) break t; z = 0; do { M = g[w + z++], n.head && M && n.length < 65536 && (n.head.comment += String.fromCharCode(M)) } while (M && z < v); if (512 & n.flags && (n.check = a(n.check, g, z, w)), v -= z, w += z, M) break t } else n.head && (n.head.comment = null); n.mode = 9; case 9: if (512 & n.flags) { for (; k < 16;) { if (0 === v) break t; v--, x += g[w++] << k, k += 8 } if (x !== (65535 & n.check)) { t.msg = "header crc mismatch", n.mode = p; break } x = 0, k = 0 } n.head && (n.head.hcrc = n.flags >> 9 & 1, n.head.done = !0), t.adler = n.check = 0, n.mode = h; break; case 10: for (; k < 32;) { if (0 === v) break t; v--, x += g[w++] << k, k += 8 } t.adler = n.check = b(x), x = 0, k = 0, n.mode = 11; case 11: if (0 === n.havedict) return t.next_out = y, t.avail_out = _, t.next_in = w, t.avail_in = v, n.hold = x, n.bits = k, 2; t.adler = n.check = 1, n.mode = h; case h: if (5 === e || 6 === e) break t; case 13: if (n.last) { x >>>= 7 & k, k -= 7 & k, n.mode = 27; break } for (; k < 3;) { if (0 === v) break t; v--, x += g[w++] << k, k += 8 } switch (n.last = 1 & x, k -= 1, 3 & (x >>>= 1)) { case 0: n.mode = 14; break; case 1: if (S(n), n.mode = 20, 6 === e) { x >>>= 2, k -= 2; break t } break; case 2: n.mode = 17; break; case 3: t.msg = "invalid block type", n.mode = p }x >>>= 2, k -= 2; break; case 14: for (x >>>= 7 & k, k -= 7 & k; k < 32;) { if (0 === v) break t; v--, x += g[w++] << k, k += 8 } if ((65535 & x) != (x >>> 16 ^ 65535)) { t.msg = "invalid stored block lengths", n.mode = p; break } if (n.length = 65535 & x, x = 0, k = 0, n.mode = 15, 6 === e) break t; case 15: n.mode = 16; case 16: if (z = n.length) { if (z > v && (z = v), z > _ && (z = _), 0 === z) break t; r.arraySet(m, g, w, z, y), v -= z, w += z, _ -= z, y += z, n.length -= z; break } n.mode = h; break; case 17: for (; k < 14;) { if (0 === v) break t; v--, x += g[w++] << k, k += 8 } if (n.nlen = 257 + (31 & x), x >>>= 5, k -= 5, n.ndist = 1 + (31 & x), x >>>= 5, k -= 5, n.ncode = 4 + (15 & x), x >>>= 4, k -= 4, n.nlen > 286 || n.ndist > 30) { t.msg = "too many length or distance symbols", n.mode = p; break } n.have = 0, n.mode = 18; case 18: for (; n.have < n.ncode;) { for (; k < 3;) { if (0 === v) break t; v--, x += g[w++] << k, k += 8 } n.lens[Z[n.have++]] = 7 & x, x >>>= 3, k -= 3 } for (; n.have < 19;)n.lens[Z[n.have++]] = 0; if (n.lencode = n.lendyn, n.lenbits = 7, L = { bits: n.lenbits }, R = o(0, n.lens, 0, 19, n.lencode, 0, n.work, L), n.lenbits = L.bits, R) { t.msg = "invalid code lengths set", n.mode = p; break } n.have = 0, n.mode = 19; case 19: for (; n.have < n.nlen + n.ndist;) { for (; T = (P = n.lencode[x & (1 << n.lenbits) - 1]) >>> 16 & 255, N = 65535 & P, !((I = P >>> 24) <= k);) { if (0 === v) break t; v--, x += g[w++] << k, k += 8 } if (N < 16) x >>>= I, k -= I, n.lens[n.have++] = N; else { if (16 === N) { for (F = I + 2; k < F;) { if (0 === v) break t; v--, x += g[w++] << k, k += 8 } if (x >>>= I, k -= I, 0 === n.have) { t.msg = "invalid bit length repeat", n.mode = p; break } M = n.lens[n.have - 1], z = 3 + (3 & x), x >>>= 2, k -= 2 } else if (17 === N) { for (F = I + 3; k < F;) { if (0 === v) break t; v--, x += g[w++] << k, k += 8 } k -= I, M = 0, z = 3 + (7 & (x >>>= I)), x >>>= 3, k -= 3 } else { for (F = I + 7; k < F;) { if (0 === v) break t; v--, x += g[w++] << k, k += 8 } k -= I, M = 0, z = 11 + (127 & (x >>>= I)), x >>>= 7, k -= 7 } if (n.have + z > n.nlen + n.ndist) { t.msg = "invalid bit length repeat", n.mode = p; break } for (; z--;)n.lens[n.have++] = M } } if (n.mode === p) break; if (0 === n.lens[256]) { t.msg = "invalid code -- missing end-of-block", n.mode = p; break } if (n.lenbits = 9, L = { bits: n.lenbits }, R = o(c, n.lens, 0, n.nlen, n.lencode, 0, n.work, L), n.lenbits = L.bits, R) { t.msg = "invalid literal/lengths set", n.mode = p; break } if (n.distbits = 6, n.distcode = n.distdyn, L = { bits: n.distbits }, R = o(l, n.lens, n.nlen, n.ndist, n.distcode, 0, n.work, L), n.distbits = L.bits, R) { t.msg = "invalid distances set", n.mode = p; break } if (n.mode = 20, 6 === e) break t; case 20: n.mode = 21; case 21: if (v >= 6 && _ >= 258) { t.next_out = y, t.avail_out = _, t.next_in = w, t.avail_in = v, n.hold = x, n.bits = k, s(t, A), y = t.next_out, m = t.output, _ = t.avail_out, w = t.next_in, g = t.input, v = t.avail_in, x = n.hold, k = n.bits, n.mode === h && (n.back = -1); break } for (n.back = 0; T = (P = n.lencode[x & (1 << n.lenbits) - 1]) >>> 16 & 255, N = 65535 & P, !((I = P >>> 24) <= k);) { if (0 === v) break t; v--, x += g[w++] << k, k += 8 } if (T && 0 == (240 & T)) { for (j = I, O = T, D = N; T = (P = n.lencode[D + ((x & (1 << j + O) - 1) >> j)]) >>> 16 & 255, N = 65535 & P, !(j + (I = P >>> 24) <= k);) { if (0 === v) break t; v--, x += g[w++] << k, k += 8 } x >>>= j, k -= j, n.back += j } if (x >>>= I, k -= I, n.back += I, n.length = N, 0 === T) { n.mode = 26; break } if (32 & T) { n.back = -1, n.mode = h; break } if (64 & T) { t.msg = "invalid literal/length code", n.mode = p; break } n.extra = 15 & T, n.mode = 22; case 22: if (n.extra) { for (F = n.extra; k < F;) { if (0 === v) break t; v--, x += g[w++] << k, k += 8 } n.length += x & (1 << n.extra) - 1, x >>>= n.extra, k -= n.extra, n.back += n.extra } n.was = n.length, n.mode = 23; case 23: for (; T = (P = n.distcode[x & (1 << n.distbits) - 1]) >>> 16 & 255, N = 65535 & P, !((I = P >>> 24) <= k);) { if (0 === v) break t; v--, x += g[w++] << k, k += 8 } if (0 == (240 & T)) { for (j = I, O = T, D = N; T = (P = n.distcode[D + ((x & (1 << j + O) - 1) >> j)]) >>> 16 & 255, N = 65535 & P, !(j + (I = P >>> 24) <= k);) { if (0 === v) break t; v--, x += g[w++] << k, k += 8 } x >>>= j, k -= j, n.back += j } if (x >>>= I, k -= I, n.back += I, 64 & T) { t.msg = "invalid distance code", n.mode = p; break } n.offset = N, n.extra = 15 & T, n.mode = 24; case 24: if (n.extra) { for (F = n.extra; k < F;) { if (0 === v) break t; v--, x += g[w++] << k, k += 8 } n.offset += x & (1 << n.extra) - 1, x >>>= n.extra, k -= n.extra, n.back += n.extra } if (n.offset > n.dmax) { t.msg = "invalid distance too far back", n.mode = p; break } n.mode = 25; case 25: if (0 === _) break t; if (z = A - _, n.offset > z) { if ((z = n.offset - z) > n.whave && n.sane) { t.msg = "invalid distance too far back", n.mode = p; break } z > n.wnext ? (z -= n.wnext, C = n.wsize - z) : C = n.wnext - z, z > n.length && (z = n.length), U = n.window } else U = m, C = y - n.offset, z = n.length; z > _ && (z = _), _ -= z, n.length -= z; do { m[y++] = U[C++] } while (--z); 0 === n.length && (n.mode = 21); break; case 26: if (0 === _) break t; m[y++] = n.length, _--, n.mode = 21; break; case 27: if (n.wrap) { for (; k < 32;) { if (0 === v) break t; v--, x |= g[w++] << k, k += 8 } if (A -= _, t.total_out += A, n.total += A, A && (t.adler = n.check = n.flags ? a(n.check, m, A, y - A) : i(n.check, m, A, y - A)), A = _, (n.flags ? x : b(x)) !== n.check) { t.msg = "incorrect data check", n.mode = p; break } x = 0, k = 0 } n.mode = 28; case 28: if (n.wrap && n.flags) { for (; k < 32;) { if (0 === v) break t; v--, x += g[w++] << k, k += 8 } if (x !== (4294967295 & n.total)) { t.msg = "incorrect length check", n.mode = p; break } x = 0, k = 0 } n.mode = 29; case 29: R = 1; break t; case p: R = -3; break t; case 31: return -4; default: return d }return t.next_out = y, t.avail_out = _, t.next_in = w, t.avail_in = v, n.hold = x, n.bits = k, (n.wsize || A !== t.avail_out && n.mode < p && (n.mode < 27 || 4 !== e)) && B(t, t.output, t.next_out, A - t.avail_out) ? (n.mode = 31, -4) : (E -= t.avail_in, A -= t.avail_out, t.total_in += E, t.total_out += A, n.total += A, n.wrap && A && (t.adler = n.check = n.flags ? a(n.check, m, A, t.next_out - A) : i(n.check, m, A, t.next_out - A)), t.data_type = n.bits + (n.last ? 64 : 0) + (n.mode === h ? 128 : 0) + (20 === n.mode || 15 === n.mode ? 256 : 0), (0 === E && 0 === A || 4 === e) && R === f && (R = -5), R) }, e.inflateEnd = function (t) { if (!t || !t.state) return d; var e = t.state; return e.window && (e.window = null), t.state = null, f }, e.inflateGetHeader = function (t, e) { var n; return t && t.state ? 0 == (2 & (n = t.state).wrap) ? d : (n.head = e, e.done = !1, f) : d }, e.inflateSetDictionary = function (t, e) { var n, r = e.length; return t && t.state ? 0 !== (n = t.state).wrap && 11 !== n.mode ? d : 11 === n.mode && i(1, e, r, 0) !== n.check ? -3 : B(t, e, r, r) ? (n.mode = 31, -4) : (n.havedict = 1, f) : d }, e.inflateInfo = "pako inflate (from Nodeca project)" }, 50881: function (t, e, n) { "use strict"; var r = n(49761), i = 15, a = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], s = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], o = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], c = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]; t.exports = function (t, e, n, l, f, d, u, h) { var p, g, m, b, w, y, v, _, x, k = h.bits, E = 0, A = 0, S = 0, B = 0, z = 0, C = 0, U = 0, I = 0, T = 0, N = 0, j = null, O = 0, D = new r.Buf16(16), M = new r.Buf16(16), R = null, L = 0; for (E = 0; E <= i; E++)D[E] = 0; for (A = 0; A < l; A++)D[e[n + A]]++; for (z = k, B = i; B >= 1 && 0 === D[B]; B--); if (z > B && (z = B), 0 === B) return f[d++] = 20971520, f[d++] = 20971520, h.bits = 1, 0; for (S = 1; S < B && 0 === D[S]; S++); for (z < S && (z = S), I = 1, E = 1; E <= i; E++)if (I <<= 1, (I -= D[E]) < 0) return -1; if (I > 0 && (0 === t || 1 !== B)) return -1; for (M[1] = 0, E = 1; E < i; E++)M[E + 1] = M[E] + D[E]; for (A = 0; A < l; A++)0 !== e[n + A] && (u[M[e[n + A]]++] = A); if (0 === t ? (j = R = u, y = 19) : 1 === t ? (j = a, O -= 257, R = s, L -= 257, y = 256) : (j = o, R = c, y = -1), N = 0, A = 0, E = S, w = d, C = z, U = 0, m = -1, b = (T = 1 << z) - 1, 1 === t && T > 852 || 2 === t && T > 592) return 1; for (; ;) { v = E - U, u[A] < y ? (_ = 0, x = u[A]) : u[A] > y ? (_ = R[L + u[A]], x = j[O + u[A]]) : (_ = 96, x = 0), p = 1 << E - U, S = g = 1 << C; do { f[w + (N >> U) + (g -= p)] = v << 24 | _ << 16 | x | 0 } while (0 !== g); for (p = 1 << E - 1; N & p;)p >>= 1; if (0 !== p ? (N &= p - 1, N += p) : N = 0, A++, 0 == --D[E]) { if (E === B) break; E = e[n + u[A]] } if (E > z && (N & b) !== m) { for (0 === U && (U = z), w += S, I = 1 << (C = E - U); C + U < B && !((I -= D[C + U]) <= 0);)C++, I <<= 1; if (T += 1 << C, 1 === t && T > 852 || 2 === t && T > 592) return 1; f[m = N & b] = z << 24 | C << 16 | w - d | 0 } } return 0 !== N && (f[w + N] = E - U << 24 | 64 << 16 | 0), h.bits = z, 0 } }, 82950: function (t) { "use strict"; t.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" } }, 69564: function (t, e, n) { "use strict"; var r = n(49761), i = 0, a = 1; function s(t) { for (var e = t.length; --e >= 0;)t[e] = 0 } var o = 0, c = 29, l = 256, f = l + 1 + c, d = 30, u = 19, h = 2 * f + 1, p = 15, g = 16, m = 7, b = 256, w = 16, y = 17, v = 18, _ = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], x = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], k = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], E = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], A = new Array(2 * (f + 2)); s(A); var S = new Array(2 * d); s(S); var B = new Array(512); s(B); var z = new Array(256); s(z); var C = new Array(c); s(C); var U, I, T, N = new Array(d); function j(t, e, n, r, i) { this.static_tree = t, this.extra_bits = e, this.extra_base = n, this.elems = r, this.max_length = i, this.has_stree = t && t.length } function O(t, e) { this.dyn_tree = t, this.max_code = 0, this.stat_desc = e } function D(t) { return t < 256 ? B[t] : B[256 + (t >>> 7)] } function M(t, e) { t.pending_buf[t.pending++] = 255 & e, t.pending_buf[t.pending++] = e >>> 8 & 255 } function R(t, e, n) { t.bi_valid > g - n ? (t.bi_buf |= e << t.bi_valid & 65535, M(t, t.bi_buf), t.bi_buf = e >> g - t.bi_valid, t.bi_valid += n - g) : (t.bi_buf |= e << t.bi_valid & 65535, t.bi_valid += n) } function L(t, e, n) { R(t, n[2 * e], n[2 * e + 1]) } function F(t, e) { var n = 0; do { n |= 1 & t, t >>>= 1, n <<= 1 } while (--e > 0); return n >>> 1 } function P(t, e, n) { var r, i, a = new Array(p + 1), s = 0; for (r = 1; r <= p; r++)a[r] = s = s + n[r - 1] << 1; for (i = 0; i <= e; i++) { var o = t[2 * i + 1]; 0 !== o && (t[2 * i] = F(a[o]++, o)) } } function V(t) { var e; for (e = 0; e < f; e++)t.dyn_ltree[2 * e] = 0; for (e = 0; e < d; e++)t.dyn_dtree[2 * e] = 0; for (e = 0; e < u; e++)t.bl_tree[2 * e] = 0; t.dyn_ltree[2 * b] = 1, t.opt_len = t.static_len = 0, t.last_lit = t.matches = 0 } function Z(t) { t.bi_valid > 8 ? M(t, t.bi_buf) : t.bi_valid > 0 && (t.pending_buf[t.pending++] = t.bi_buf), t.bi_buf = 0, t.bi_valid = 0 } function q(t, e, n, r) { var i = 2 * e, a = 2 * n; return t[i] < t[a] || t[i] === t[a] && r[e] <= r[n] } function H(t, e, n) { for (var r = t.heap[n], i = n << 1; i <= t.heap_len && (i < t.heap_len && q(e, t.heap[i + 1], t.heap[i], t.depth) && i++, !q(e, r, t.heap[i], t.depth));)t.heap[n] = t.heap[i], n = i, i <<= 1; t.heap[n] = r } function W(t, e, n) { var r, i, a, s, o = 0; if (0 !== t.last_lit) do { r = t.pending_buf[t.d_buf + 2 * o] << 8 | t.pending_buf[t.d_buf + 2 * o + 1], i = t.pending_buf[t.l_buf + o], o++, 0 === r ? L(t, i, e) : (L(t, (a = z[i]) + l + 1, e), 0 !== (s = _[a]) && R(t, i -= C[a], s), L(t, a = D(--r), n), 0 !== (s = x[a]) && R(t, r -= N[a], s)) } while (o < t.last_lit); L(t, b, e) } function $(t, e) { var n, r, i, a = e.dyn_tree, s = e.stat_desc.static_tree, o = e.stat_desc.has_stree, c = e.stat_desc.elems, l = -1; for (t.heap_len = 0, t.heap_max = h, n = 0; n < c; n++)0 !== a[2 * n] ? (t.heap[++t.heap_len] = l = n, t.depth[n] = 0) : a[2 * n + 1] = 0; for (; t.heap_len < 2;)a[2 * (i = t.heap[++t.heap_len] = l < 2 ? ++l : 0)] = 1, t.depth[i] = 0, t.opt_len--, o && (t.static_len -= s[2 * i + 1]); for (e.max_code = l, n = t.heap_len >> 1; n >= 1; n--)H(t, a, n); i = c; do { n = t.heap[1], t.heap[1] = t.heap[t.heap_len--], H(t, a, 1), r = t.heap[1], t.heap[--t.heap_max] = n, t.heap[--t.heap_max] = r, a[2 * i] = a[2 * n] + a[2 * r], t.depth[i] = (t.depth[n] >= t.depth[r] ? t.depth[n] : t.depth[r]) + 1, a[2 * n + 1] = a[2 * r + 1] = i, t.heap[1] = i++, H(t, a, 1) } while (t.heap_len >= 2); t.heap[--t.heap_max] = t.heap[1], function (t, e) { var n, r, i, a, s, o, c = e.dyn_tree, l = e.max_code, f = e.stat_desc.static_tree, d = e.stat_desc.has_stree, u = e.stat_desc.extra_bits, g = e.stat_desc.extra_base, m = e.stat_desc.max_length, b = 0; for (a = 0; a <= p; a++)t.bl_count[a] = 0; for (c[2 * t.heap[t.heap_max] + 1] = 0, n = t.heap_max + 1; n < h; n++)(a = c[2 * c[2 * (r = t.heap[n]) + 1] + 1] + 1) > m && (a = m, b++), c[2 * r + 1] = a, r > l || (t.bl_count[a]++, s = 0, r >= g && (s = u[r - g]), o = c[2 * r], t.opt_len += o * (a + s), d && (t.static_len += o * (f[2 * r + 1] + s))); if (0 !== b) { do { for (a = m - 1; 0 === t.bl_count[a];)a--; t.bl_count[a]--, t.bl_count[a + 1] += 2, t.bl_count[m]--, b -= 2 } while (b > 0); for (a = m; 0 !== a; a--)for (r = t.bl_count[a]; 0 !== r;)(i = t.heap[--n]) > l || (c[2 * i + 1] !== a && (t.opt_len += (a - c[2 * i + 1]) * c[2 * i], c[2 * i + 1] = a), r--) } }(t, e), P(a, l, t.bl_count) } function Q(t, e, n) { var r, i, a = -1, s = e[1], o = 0, c = 7, l = 4; for (0 === s && (c = 138, l = 3), e[2 * (n + 1) + 1] = 65535, r = 0; r <= n; r++)i = s, s = e[2 * (r + 1) + 1], ++o < c && i === s || (o < l ? t.bl_tree[2 * i] += o : 0 !== i ? (i !== a && t.bl_tree[2 * i]++, t.bl_tree[2 * w]++) : o <= 10 ? t.bl_tree[2 * y]++ : t.bl_tree[2 * v]++, o = 0, a = i, 0 === s ? (c = 138, l = 3) : i === s ? (c = 6, l = 3) : (c = 7, l = 4)) } function G(t, e, n) { var r, i, a = -1, s = e[1], o = 0, c = 7, l = 4; for (0 === s && (c = 138, l = 3), r = 0; r <= n; r++)if (i = s, s = e[2 * (r + 1) + 1], !(++o < c && i === s)) { if (o < l) do { L(t, i, t.bl_tree) } while (0 != --o); else 0 !== i ? (i !== a && (L(t, i, t.bl_tree), o--), L(t, w, t.bl_tree), R(t, o - 3, 2)) : o <= 10 ? (L(t, y, t.bl_tree), R(t, o - 3, 3)) : (L(t, v, t.bl_tree), R(t, o - 11, 7)); o = 0, a = i, 0 === s ? (c = 138, l = 3) : i === s ? (c = 6, l = 3) : (c = 7, l = 4) } } s(N); var K = !1; function J(t, e, n, i) { R(t, (o << 1) + (i ? 1 : 0), 3), function (t, e, n, i) { Z(t), i && (M(t, n), M(t, ~n)), r.arraySet(t.pending_buf, t.window, e, n, t.pending), t.pending += n }(t, e, n, !0) } e._tr_init = function (t) { K || (!function () { var t, e, n, r, i, a = new Array(p + 1); for (n = 0, r = 0; r < c - 1; r++)for (C[r] = n, t = 0; t < 1 << _[r]; t++)z[n++] = r; for (z[n - 1] = r, i = 0, r = 0; r < 16; r++)for (N[r] = i, t = 0; t < 1 << x[r]; t++)B[i++] = r; for (i >>= 7; r < d; r++)for (N[r] = i << 7, t = 0; t < 1 << x[r] - 7; t++)B[256 + i++] = r; for (e = 0; e <= p; e++)a[e] = 0; for (t = 0; t <= 143;)A[2 * t + 1] = 8, t++, a[8]++; for (; t <= 255;)A[2 * t + 1] = 9, t++, a[9]++; for (; t <= 279;)A[2 * t + 1] = 7, t++, a[7]++; for (; t <= 287;)A[2 * t + 1] = 8, t++, a[8]++; for (P(A, f + 1, a), t = 0; t < d; t++)S[2 * t + 1] = 5, S[2 * t] = F(t, 5); U = new j(A, _, l + 1, f, p), I = new j(S, x, 0, d, p), T = new j(new Array(0), k, 0, u, m) }(), K = !0), t.l_desc = new O(t.dyn_ltree, U), t.d_desc = new O(t.dyn_dtree, I), t.bl_desc = new O(t.bl_tree, T), t.bi_buf = 0, t.bi_valid = 0, V(t) }, e._tr_stored_block = J, e._tr_flush_block = function (t, e, n, r) { var s, o, c = 0; t.level > 0 ? (2 === t.strm.data_type && (t.strm.data_type = function (t) { var e, n = 4093624447; for (e = 0; e <= 31; e++, n >>>= 1)if (1 & n && 0 !== t.dyn_ltree[2 * e]) return i; if (0 !== t.dyn_ltree[18] || 0 !== t.dyn_ltree[20] || 0 !== t.dyn_ltree[26]) return a; for (e = 32; e < l; e++)if (0 !== t.dyn_ltree[2 * e]) return a; return i }(t)), $(t, t.l_desc), $(t, t.d_desc), c = function (t) { var e; for (Q(t, t.dyn_ltree, t.l_desc.max_code), Q(t, t.dyn_dtree, t.d_desc.max_code), $(t, t.bl_desc), e = u - 1; e >= 3 && 0 === t.bl_tree[2 * E[e] + 1]; e--); return t.opt_len += 3 * (e + 1) + 5 + 5 + 4, e }(t), s = t.opt_len + 3 + 7 >>> 3, (o = t.static_len + 3 + 7 >>> 3) <= s && (s = o)) : s = o = n + 5, n + 4 <= s && -1 !== e ? J(t, e, n, r) : 4 === t.strategy || o === s ? (R(t, 2 + (r ? 1 : 0), 3), W(t, A, S)) : (R(t, 4 + (r ? 1 : 0), 3), function (t, e, n, r) { var i; for (R(t, e - 257, 5), R(t, n - 1, 5), R(t, r - 4, 4), i = 0; i < r; i++)R(t, t.bl_tree[2 * E[i] + 1], 3); G(t, t.dyn_ltree, e - 1), G(t, t.dyn_dtree, n - 1) }(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, c + 1), W(t, t.dyn_ltree, t.dyn_dtree)), V(t), r && Z(t) }, e._tr_tally = function (t, e, n) { return t.pending_buf[t.d_buf + 2 * t.last_lit] = e >>> 8 & 255, t.pending_buf[t.d_buf + 2 * t.last_lit + 1] = 255 & e, t.pending_buf[t.l_buf + t.last_lit] = 255 & n, t.last_lit++, 0 === e ? t.dyn_ltree[2 * n]++ : (t.matches++, e--, t.dyn_ltree[2 * (z[n] + l + 1)]++, t.dyn_dtree[2 * D(e)]++), t.last_lit === t.lit_bufsize - 1 }, e._tr_align = function (t) { R(t, 2, 3), L(t, b, A), function (t) { 16 === t.bi_valid ? (M(t, t.bi_buf), t.bi_buf = 0, t.bi_valid = 0) : t.bi_valid >= 8 && (t.pending_buf[t.pending++] = 255 & t.bi_buf, t.bi_buf >>= 8, t.bi_valid -= 8) }(t) } }, 20744: function (t) { "use strict"; t.exports = function () { this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0 } }, 35562: function (t) {
    var e; window, e = function () {
      return function (t) { var e = {}; function n(r) { if (e[r]) return e[r].exports; var i = e[r] = { i: r, l: !1, exports: {} }; return t[r].call(i.exports, i, i.exports, n), i.l = !0, i.exports } return n.m = t, n.c = e, n.d = function (t, e, r) { n.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: r }) }, n.r = function (t) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }) }, n.t = function (t, e) { if (1 & e && (t = n(t)), 8 & e) return t; if (4 & e && "object" == typeof t && t && t.__esModule) return t; var r = Object.create(null); if (n.r(r), Object.defineProperty(r, "default", { enumerable: !0, value: t }), 2 & e && "string" != typeof t) for (var i in t) n.d(r, i, function (e) { return t[e] }.bind(null, i)); return r }, n.n = function (t) { var e = t && t.__esModule ? function () { return t.default } : function () { return t }; return n.d(e, "a", e), e }, n.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e) }, n.p = "", n(n.s = 0) }({
        "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: default */function (t, e, n) { "use strict"; n.r(e), n(/*! ./sass/index.scss */"./src/sass/index.scss"); var r = n(/*! ./js/init */"./src/js/init.js").default.init; "undefined" != typeof window && (window.printJS = r), e.default = r }, "./src/js/browser.js":
/*!***************************!*\
  !*** ./src/js/browser.js ***!
  \***************************/
/*! exports provided: default */function (t, e, n) { "use strict"; n.r(e); var r = { isFirefox: function () { return "undefined" != typeof InstallTrigger }, isIE: function () { return -1 !== navigator.userAgent.indexOf("MSIE") || !!document.documentMode }, isEdge: function () { return !r.isIE() && !!window.StyleMedia }, isChrome: function () { return !!(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : window).chrome }, isSafari: function () { return Object.prototype.toString.call(window.HTMLElement).indexOf("Constructor") > 0 || -1 !== navigator.userAgent.toLowerCase().indexOf("safari") }, isIOSChrome: function () { return -1 !== navigator.userAgent.toLowerCase().indexOf("crios") } }; e.default = r }, "./src/js/functions.js":
/*!*****************************!*\
  !*** ./src/js/functions.js ***!
  \*****************************/
/*! exports provided: addWrapper, capitalizePrint, collectStyles, addHeader, cleanUp, isRawHTML */function (t, e, n) { "use strict"; n.r(e), n.d(e, "addWrapper", (function () { return s })), n.d(e, "capitalizePrint", (function () { return o })), n.d(e, "collectStyles", (function () { return c })), n.d(e, "addHeader", (function () { return f })), n.d(e, "cleanUp", (function () { return d })), n.d(e, "isRawHTML", (function () { return u })); var r = n(/*! ./modal */"./src/js/modal.js"), i = n(/*! ./browser */"./src/js/browser.js"); function a(t) { return a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, a(t) } function s(t, e) { return '<div style="font-family:' + e.font + " !important; font-size: " + e.font_size + ' !important; width:100%;">' + t + "</div>" } function o(t) { return t.charAt(0).toUpperCase() + t.slice(1) } function c(t, e) { for (var n = "", r = (document.defaultView || window).getComputedStyle(t, ""), i = 0; i < r.length; i++)(-1 !== e.targetStyles.indexOf("*") || -1 !== e.targetStyle.indexOf(r[i]) || l(e.targetStyles, r[i])) && r.getPropertyValue(r[i]) && (n += r[i] + ":" + r.getPropertyValue(r[i]) + ";"); return n += "max-width: " + e.maxWidth + "px !important; font-size: " + e.font_size + " !important;" } function l(t, e) { for (var n = 0; n < t.length; n++)if ("object" === a(e) && -1 !== e.indexOf(t[n])) return !0; return !1 } function f(t, e) { var n = document.createElement("div"); if (u(e.header)) n.innerHTML = e.header; else { var r = document.createElement("h1"), i = document.createTextNode(e.header); r.appendChild(i), r.setAttribute("style", e.headerStyle), n.appendChild(r) } t.insertBefore(n, t.childNodes[0]) } function d(t) { t.showModal && r.default.close(), t.onLoadingEnd && t.onLoadingEnd(), (t.showModal || t.onLoadingStart) && window.URL.revokeObjectURL(t.printable); var e = "mouseover"; (i.default.isChrome() || i.default.isFirefox()) && (e = "focus"), window.addEventListener(e, (function n() { window.removeEventListener(e, n), t.onPrintDialogClose(); var r = document.getElementById(t.frameId); r && r.remove() })) } function u(t) { return new RegExp("<([A-Za-z][A-Za-z0-9]*)\\b[^>]*>(.*?)</\\1>").test(t) } }, "./src/js/html.js":
/*!************************!*\
  !*** ./src/js/html.js ***!
  \************************/
/*! exports provided: default */function (t, e, n) { "use strict"; n.r(e); var r = n(/*! ./functions */"./src/js/functions.js"), i = n(/*! ./print */"./src/js/print.js"); function a(t) { return a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, a(t) } function s(t, e) { for (var n = t.cloneNode(), i = Array.prototype.slice.call(t.childNodes), a = 0; a < i.length; a++)if (-1 === e.ignoreElements.indexOf(i[a].id)) { var o = s(i[a], e); n.appendChild(o) } switch (e.scanStyles && 1 === t.nodeType && n.setAttribute("style", Object(r.collectStyles)(t, e)), t.tagName) { case "SELECT": n.value = t.value; break; case "CANVAS": n.getContext("2d").drawImage(t, 0, 0) }return n } e.default = { print: function (t, e) { var n, o = "object" === a(n = t.printable) && n && (n instanceof HTMLElement || 1 === n.nodeType) ? t.printable : document.getElementById(t.printable); o ? (t.printableElement = s(o, t), t.header && Object(r.addHeader)(t.printableElement, t), i.default.send(t, e)) : window.console.error("Invalid HTML element id: " + t.printable) } } }, "./src/js/image.js":
/*!*************************!*\
  !*** ./src/js/image.js ***!
  \*************************/
/*! exports provided: default */function (t, e, n) { "use strict"; n.r(e); var r = n(/*! ./functions */"./src/js/functions.js"), i = n(/*! ./print */"./src/js/print.js"), a = n(/*! ./browser */"./src/js/browser.js"); e.default = { print: function (t, e) { t.printable.constructor !== Array && (t.printable = [t.printable]), t.printableElement = document.createElement("div"), t.printable.forEach((function (e) { var n = document.createElement("img"); if (n.setAttribute("style", t.imageStyle), n.src = e, a.default.isFirefox()) { var r = n.src; n.src = r } var i = document.createElement("div"); i.appendChild(n), t.printableElement.appendChild(i) })), t.header && Object(r.addHeader)(t.printableElement, t), i.default.send(t, e) } } }, "./src/js/init.js":
/*!************************!*\
  !*** ./src/js/init.js ***!
  \************************/
/*! exports provided: default */function (t, e, n) { "use strict"; n.r(e); var r = n(/*! ./browser */"./src/js/browser.js"), i = n(/*! ./modal */"./src/js/modal.js"), a = n(/*! ./pdf */"./src/js/pdf.js"), s = n(/*! ./html */"./src/js/html.js"), o = n(/*! ./raw-html */"./src/js/raw-html.js"), c = n(/*! ./image */"./src/js/image.js"), l = n(/*! ./json */"./src/js/json.js"); function f(t) { return f = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, f(t) } var d = ["pdf", "html", "image", "json", "raw-html"]; e.default = { init: function () { var t = { printable: null, fallbackPrintable: null, type: "pdf", header: null, headerStyle: "font-weight: 300;", maxWidth: 800, properties: null, gridHeaderStyle: "font-weight: bold; padding: 5px; border: 1px solid #dddddd;", gridStyle: "border: 1px solid lightgray; margin-bottom: -1px;", showModal: !1, onError: function (t) { throw t }, onLoadingStart: null, onLoadingEnd: null, onPrintDialogClose: function () { }, onIncompatibleBrowser: function () { }, modalMessage: "Retrieving Document...", frameId: "printJS", printableElement: null, documentTitle: "Document", targetStyle: ["clear", "display", "width", "min-width", "height", "min-height", "max-height"], targetStyles: ["border", "box", "break", "text-decoration"], ignoreElements: [], repeatTableHeader: !0, css: null, style: null, scanStyles: !0, base64: !1, onPdfOpen: null, font: "TimesNewRoman", font_size: "12pt", honorMarginPadding: !0, honorColor: !1, imageStyle: "max-width: 100%;" }, e = arguments[0]; if (void 0 === e) throw new Error("printJS expects at least 1 attribute."); switch (f(e)) { case "string": t.printable = encodeURI(e), t.fallbackPrintable = t.printable, t.type = arguments[1] || t.type; break; case "object": for (var n in t.printable = e.printable, t.fallbackPrintable = void 0 !== e.fallbackPrintable ? e.fallbackPrintable : t.printable, t.fallbackPrintable = t.base64 ? "data:application/pdf;base64,".concat(t.fallbackPrintable) : t.fallbackPrintable, t) "printable" !== n && "fallbackPrintable" !== n && (t[n] = void 0 !== e[n] ? e[n] : t[n]); break; default: throw new Error('Unexpected argument type! Expected "string" or "object", got ' + f(e)) }if (!t.printable) throw new Error("Missing printable information."); if (!t.type || "string" != typeof t.type || -1 === d.indexOf(t.type.toLowerCase())) throw new Error("Invalid print type. Available types are: pdf, html, image and json."); t.showModal && i.default.show(t), t.onLoadingStart && t.onLoadingStart(); var u = document.getElementById(t.frameId); u && u.parentNode.removeChild(u); var h = document.createElement("iframe"); switch (r.default.isFirefox() ? h.setAttribute("style", "width: 1px; height: 100px; position: fixed; left: 0; top: 0; opacity: 0; border-width: 0; margin: 0; padding: 0") : h.setAttribute("style", "visibility: hidden; height: 0; width: 0; position: absolute; border: 0"), h.setAttribute("id", t.frameId), "pdf" !== t.type && (h.srcdoc = "<html><head><title>" + t.documentTitle + "</title>", t.css && (Array.isArray(t.css) || (t.css = [t.css]), t.css.forEach((function (t) { h.srcdoc += '<link rel="stylesheet" href="' + t + '">' }))), h.srcdoc += "</head><body></body></html>"), t.type) { case "pdf": if (r.default.isIE()) try { console.info("Print.js doesn't support PDF printing in Internet Explorer."), window.open(t.fallbackPrintable, "_blank").focus(), t.onIncompatibleBrowser() } catch (e) { t.onError(e) } finally { t.showModal && i.default.close(), t.onLoadingEnd && t.onLoadingEnd() } else a.default.print(t, h); break; case "image": c.default.print(t, h); break; case "html": s.default.print(t, h); break; case "raw-html": o.default.print(t, h); break; case "json": l.default.print(t, h) } } } }, "./src/js/json.js":
/*!************************!*\
  !*** ./src/js/json.js ***!
  \************************/
/*! exports provided: default */function (t, e, n) { "use strict"; n.r(e); var r = n(/*! ./functions */"./src/js/functions.js"), i = n(/*! ./print */"./src/js/print.js"); function a(t) { return a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, a(t) } e.default = { print: function (t, e) { if ("object" !== a(t.printable)) throw new Error("Invalid javascript data object (JSON)."); if ("boolean" != typeof t.repeatTableHeader) throw new Error("Invalid value for repeatTableHeader attribute (JSON)."); if (!t.properties || !Array.isArray(t.properties)) throw new Error("Invalid properties array for your JSON data."); t.properties = t.properties.map((function (e) { return { field: "object" === a(e) ? e.field : e, displayName: "object" === a(e) ? e.displayName : e, columnSize: "object" === a(e) && e.columnSize ? e.columnSize + ";" : 100 / t.properties.length + "%;" } })), t.printableElement = document.createElement("div"), t.header && Object(r.addHeader)(t.printableElement, t), t.printableElement.innerHTML += function (t) { var e = t.printable, n = t.properties, i = '<table style="border-collapse: collapse; width: 100%;">'; t.repeatTableHeader && (i += "<thead>"), i += "<tr>"; for (var a = 0; a < n.length; a++)i += '<th style="width:' + n[a].columnSize + ";" + t.gridHeaderStyle + '">' + Object(r.capitalizePrint)(n[a].displayName) + "</th>"; i += "</tr>", t.repeatTableHeader && (i += "</thead>"), i += "<tbody>"; for (var s = 0; s < e.length; s++) { i += "<tr>"; for (var o = 0; o < n.length; o++) { var c = e[s], l = n[o].field.split("."); if (l.length > 1) for (var f = 0; f < l.length; f++)c = c[l[f]]; else c = c[n[o].field]; i += '<td style="width:' + n[o].columnSize + t.gridStyle + '">' + c + "</td>" } i += "</tr>" } return i += "</tbody></table>" }(t), i.default.send(t, e) } } }, "./src/js/modal.js":
/*!*************************!*\
  !*** ./src/js/modal.js ***!
  \*************************/
/*! exports provided: default */function (t, e, n) { "use strict"; n.r(e); var r = { show: function (t) { var e = document.createElement("div"); e.setAttribute("style", "font-family:sans-serif; display:table; text-align:center; font-weight:300; font-size:30px; left:0; top:0;position:fixed; z-index: 9990;color: #0460B5; width: 100%; height: 100%; background-color:rgba(255,255,255,.9);transition: opacity .3s ease;"), e.setAttribute("id", "printJS-Modal"); var n = document.createElement("div"); n.setAttribute("style", "display:table-cell; vertical-align:middle; padding-bottom:100px;"); var i = document.createElement("div"); i.setAttribute("class", "printClose"), i.setAttribute("id", "printClose"), n.appendChild(i); var a = document.createElement("span"); a.setAttribute("class", "printSpinner"), n.appendChild(a); var s = document.createTextNode(t.modalMessage); n.appendChild(s), e.appendChild(n), document.getElementsByTagName("body")[0].appendChild(e), document.getElementById("printClose").addEventListener("click", (function () { r.close() })) }, close: function () { var t = document.getElementById("printJS-Modal"); t && t.parentNode.removeChild(t) } }; e.default = r }, "./src/js/pdf.js":
/*!***********************!*\
  !*** ./src/js/pdf.js ***!
  \***********************/
/*! exports provided: default */function (t, e, n) { "use strict"; n.r(e); var r = n(/*! ./print */"./src/js/print.js"), i = n(/*! ./functions */"./src/js/functions.js"); function a(t, e, n) { var i = new window.Blob([n], { type: "application/pdf" }); i = window.URL.createObjectURL(i), e.setAttribute("src", i), r.default.send(t, e) } e.default = { print: function (t, e) { if (t.base64) { var n = Uint8Array.from(atob(t.printable), (function (t) { return t.charCodeAt(0) })); a(t, e, n) } else { t.printable = /^(blob|http|\/\/)/i.test(t.printable) ? t.printable : window.location.origin + ("/" !== t.printable.charAt(0) ? "/" + t.printable : t.printable); var r = new window.XMLHttpRequest; r.responseType = "arraybuffer", r.addEventListener("error", (function () { Object(i.cleanUp)(t), t.onError(r.statusText, r) })), r.addEventListener("load", (function () { if (-1 === [200, 201].indexOf(r.status)) return Object(i.cleanUp)(t), void t.onError(r.statusText, r); a(t, e, r.response) })), r.open("GET", t.printable, !0), r.send() } } } }, "./src/js/print.js":
/*!*************************!*\
  !*** ./src/js/print.js ***!
  \*************************/
/*! exports provided: default */function (t, e, n) { "use strict"; n.r(e); var r = n(/*! ./browser */"./src/js/browser.js"), i = n(/*! ./functions */"./src/js/functions.js"), a = { send: function (t, e) { document.getElementsByTagName("body")[0].appendChild(e); var n = document.getElementById(t.frameId); n.onload = function () { if ("pdf" !== t.type) { var e = n.contentWindow || n.contentDocument; if (e.document && (e = e.document), e.body.appendChild(t.printableElement), "pdf" !== t.type && t.style) { var i = document.createElement("style"); i.innerHTML = t.style, e.head.appendChild(i) } var a = e.getElementsByTagName("img"); a.length > 0 ? function (t) { var e = t.map((function (t) { if (t.src && t.src !== window.location.href) return function (t) { return new Promise((function (e) { !function n() { t && void 0 !== t.naturalWidth && 0 !== t.naturalWidth && t.complete ? e() : setTimeout(n, 500) }() })) }(t) })); return Promise.all(e) }(Array.from(a)).then((function () { return s(n, t) })) : s(n, t) } else r.default.isFirefox() ? setTimeout((function () { return s(n, t) }), 1e3) : s(n, t) } } }; function s(t, e) { try { if (t.focus(), r.default.isEdge() || r.default.isIE()) try { t.contentWindow.document.execCommand("print", !1, null) } catch (e) { t.contentWindow.print() } else t.contentWindow.print() } catch (t) { e.onError(t) } finally { r.default.isFirefox() && (t.style.visibility = "hidden", t.style.left = "-1px"), Object(i.cleanUp)(e) } } e.default = a }, "./src/js/raw-html.js":
/*!****************************!*\
  !*** ./src/js/raw-html.js ***!
  \****************************/
/*! exports provided: default */function (t, e, n) { "use strict"; n.r(e); var r = n(/*! ./print */"./src/js/print.js"); e.default = { print: function (t, e) { t.printableElement = document.createElement("div"), t.printableElement.setAttribute("style", "width:100%"), t.printableElement.innerHTML = t.printable, r.default.send(t, e) } } }, "./src/sass/index.scss":
/*!*****************************!*\
  !*** ./src/sass/index.scss ***!
  \*****************************/
/*! no static exports found */function (t, e, n) { }, 0:
/*!****************************!*\
  !*** multi ./src/index.js ***!
  \****************************/
/*! no static exports found */function (t, e, n) { t.exports = n(/*! ./src/index.js */"./src/index.js") }
      }).default
    }, t.exports = e()
  }, 34406: function (t) { var e, n, r = t.exports = {}; function i() { throw new Error("setTimeout has not been defined") } function a() { throw new Error("clearTimeout has not been defined") } function s(t) { if (e === setTimeout) return setTimeout(t, 0); if ((e === i || !e) && setTimeout) return e = setTimeout, setTimeout(t, 0); try { return e(t, 0) } catch (n) { try { return e.call(null, t, 0) } catch (n) { return e.call(this, t, 0) } } } !function () { try { e = "function" == typeof setTimeout ? setTimeout : i } catch (t) { e = i } try { n = "function" == typeof clearTimeout ? clearTimeout : a } catch (t) { n = a } }(); var o, c = [], l = !1, f = -1; function d() { l && o && (l = !1, o.length ? c = o.concat(c) : f = -1, c.length && u()) } function u() { if (!l) { var t = s(d); l = !0; for (var e = c.length; e;) { for (o = c, c = []; ++f < e;)o && o[f].run(); f = -1, e = c.length } o = null, l = !1, function (t) { if (n === clearTimeout) return clearTimeout(t); if ((n === a || !n) && clearTimeout) return n = clearTimeout, clearTimeout(t); try { return n(t) } catch (e) { try { return n.call(null, t) } catch (e) { return n.call(this, t) } } }(t) } } function h(t, e) { this.fun = t, this.array = e } function p() { } r.nextTick = function (t) { var e = new Array(arguments.length - 1); if (arguments.length > 1) for (var n = 1; n < arguments.length; n++)e[n - 1] = arguments[n]; c.push(new h(t, e)), 1 !== c.length || l || s(u) }, h.prototype.run = function () { this.fun.apply(null, this.array) }, r.title = "browser", r.browser = !0, r.env = {}, r.argv = [], r.version = "", r.versions = {}, r.on = p, r.addListener = p, r.once = p, r.off = p, r.removeListener = p, r.removeAllListeners = p, r.emit = p, r.prependListener = p, r.prependOnceListener = p, r.listeners = function (t) { return [] }, r.binding = function (t) { throw new Error("process.binding is not supported") }, r.cwd = function () { return "/" }, r.chdir = function (t) { throw new Error("process.chdir is not supported") }, r.umask = function () { return 0 } }, 1738: function (t, e, n) {
    var r, i = n(34406);
/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */!function (t) { !function (e) { var r = "object" == typeof n.g ? n.g : "object" == typeof self ? self : "object" == typeof this ? this : Function("return this;")(), a = s(t); function s(t, e) { return function (n, r) { "function" != typeof t[n] && Object.defineProperty(t, n, { configurable: !0, writable: !0, value: r }), e && e(n, r) } } void 0 === r.Reflect ? r.Reflect = t : a = s(r.Reflect, a), function (t) { var e = Object.prototype.hasOwnProperty, n = "function" == typeof Symbol, r = n && void 0 !== Symbol.toPrimitive ? Symbol.toPrimitive : "@@toPrimitive", a = n && void 0 !== Symbol.iterator ? Symbol.iterator : "@@iterator", s = "function" == typeof Object.create, o = { __proto__: [] } instanceof Array, c = !s && !o, l = { create: s ? function () { return it(Object.create(null)) } : o ? function () { return it({ __proto__: null }) } : function () { return it({}) }, has: c ? function (t, n) { return e.call(t, n) } : function (t, e) { return e in t }, get: c ? function (t, n) { return e.call(t, n) ? t[n] : void 0 } : function (t, e) { return t[e] } }, f = Object.getPrototypeOf(Function), d = "object" == typeof i && { default: { NODE_ENV: "production", ENV_CONFIG: "prod", API_ROOT: "" } } && "true" === { default: { NODE_ENV: "production", ENV_CONFIG: "prod", API_ROOT: "" } }.REFLECT_METADATA_USE_MAP_POLYFILL, u = d || "function" != typeof Map || "function" != typeof Map.prototype.entries ? et() : Map, h = d || "function" != typeof Set || "function" != typeof Set.prototype.entries ? nt() : Set, p = new (d || "function" != typeof WeakMap ? rt() : WeakMap); function g(t, e, n, r) { if (D(n)) { if (!H(t)) throw new TypeError; if (!$(e)) throw new TypeError; return A(t, e) } if (!H(t)) throw new TypeError; if (!L(e)) throw new TypeError; if (!L(r) && !D(r) && !M(r)) throw new TypeError; return M(r) && (r = void 0), S(t, e, n = q(n), r) } function m(t, e) { function n(n, r) { if (!L(n)) throw new TypeError; if (!D(r) && !Q(r)) throw new TypeError; T(t, e, n, r) } return n } function b(t, e, n, r) { if (!L(n)) throw new TypeError; return D(r) || (r = q(r)), T(t, e, n, r) } function w(t, e, n) { if (!L(e)) throw new TypeError; return D(n) || (n = q(n)), z(t, e, n) } function y(t, e, n) { if (!L(e)) throw new TypeError; return D(n) || (n = q(n)), C(t, e, n) } function v(t, e, n) { if (!L(e)) throw new TypeError; return D(n) || (n = q(n)), U(t, e, n) } function _(t, e, n) { if (!L(e)) throw new TypeError; return D(n) || (n = q(n)), I(t, e, n) } function x(t, e) { if (!L(t)) throw new TypeError; return D(e) || (e = q(e)), N(t, e) } function k(t, e) { if (!L(t)) throw new TypeError; return D(e) || (e = q(e)), j(t, e) } function E(t, e, n) { if (!L(e)) throw new TypeError; D(n) || (n = q(n)); var r = B(e, n, !1); if (D(r)) return !1; if (!r.delete(t)) return !1; if (r.size > 0) return !0; var i = p.get(e); return i.delete(n), i.size > 0 || p.delete(e), !0 } function A(t, e) { for (var n = t.length - 1; n >= 0; --n) { var r = (0, t[n])(e); if (!D(r) && !M(r)) { if (!$(r)) throw new TypeError; e = r } } return e } function S(t, e, n, r) { for (var i = t.length - 1; i >= 0; --i) { var a = (0, t[i])(e, n, r); if (!D(a) && !M(a)) { if (!L(a)) throw new TypeError; r = a } } return r } function B(t, e, n) { var r = p.get(t); if (D(r)) { if (!n) return; r = new u, p.set(t, r) } var i = r.get(e); if (D(i)) { if (!n) return; i = new u, r.set(e, i) } return i } function z(t, e, n) { if (C(t, e, n)) return !0; var r = tt(e); return !M(r) && z(t, r, n) } function C(t, e, n) { var r = B(e, n, !1); return !D(r) && V(r.has(t)) } function U(t, e, n) { if (C(t, e, n)) return I(t, e, n); var r = tt(e); return M(r) ? void 0 : U(t, r, n) } function I(t, e, n) { var r = B(e, n, !1); if (!D(r)) return r.get(t) } function T(t, e, n, r) { B(n, r, !0).set(t, e) } function N(t, e) { var n = j(t, e), r = tt(t); if (null === r) return n; var i = N(r, e); if (i.length <= 0) return n; if (n.length <= 0) return i; for (var a = new h, s = [], o = 0, c = n; o < c.length; o++) { var l = c[o]; a.has(l) || (a.add(l), s.push(l)) } for (var f = 0, d = i; f < d.length; f++) { l = d[f]; a.has(l) || (a.add(l), s.push(l)) } return s } function j(t, e) { var n = [], r = B(t, e, !1); if (D(r)) return n; for (var i = K(r.keys()), a = 0; ;) { var s = X(i); if (!s) return n.length = a, n; var o = J(s); try { n[a] = o } catch (t) { try { Y(i) } finally { throw t } } a++ } } function O(t) { if (null === t) return 1; switch (typeof t) { case "undefined": return 0; case "boolean": return 2; case "string": return 3; case "symbol": return 4; case "number": return 5; case "object": return null === t ? 1 : 6; default: return 6 } } function D(t) { return void 0 === t } function M(t) { return null === t } function R(t) { return "symbol" == typeof t } function L(t) { return "object" == typeof t ? null !== t : "function" == typeof t } function F(t, e) { switch (O(t)) { case 0: case 1: case 2: case 3: case 4: case 5: return t }var n = 3 === e ? "string" : 5 === e ? "number" : "default", i = G(t, r); if (void 0 !== i) { var a = i.call(t, n); if (L(a)) throw new TypeError; return a } return P(t, "default" === n ? "number" : n) } function P(t, e) { if ("string" === e) { var n = t.toString; if (W(n)) if (!L(i = n.call(t))) return i; if (W(r = t.valueOf)) if (!L(i = r.call(t))) return i } else { var r; if (W(r = t.valueOf)) if (!L(i = r.call(t))) return i; var i, a = t.toString; if (W(a)) if (!L(i = a.call(t))) return i } throw new TypeError } function V(t) { return !!t } function Z(t) { return "" + t } function q(t) { var e = F(t, 3); return R(e) ? e : Z(e) } function H(t) { return Array.isArray ? Array.isArray(t) : t instanceof Object ? t instanceof Array : "[object Array]" === Object.prototype.toString.call(t) } function W(t) { return "function" == typeof t } function $(t) { return "function" == typeof t } function Q(t) { switch (O(t)) { case 3: case 4: return !0; default: return !1 } } function G(t, e) { var n = t[e]; if (null != n) { if (!W(n)) throw new TypeError; return n } } function K(t) { var e = G(t, a); if (!W(e)) throw new TypeError; var n = e.call(t); if (!L(n)) throw new TypeError; return n } function J(t) { return t.value } function X(t) { var e = t.next(); return !e.done && e } function Y(t) { var e = t.return; e && e.call(t) } function tt(t) { var e = Object.getPrototypeOf(t); if ("function" != typeof t || t === f) return e; if (e !== f) return e; var n = t.prototype, r = n && Object.getPrototypeOf(n); if (null == r || r === Object.prototype) return e; var i = r.constructor; return "function" != typeof i || i === t ? e : i } function et() { var t = {}, e = [], n = function () { function t(t, e, n) { this._index = 0, this._keys = t, this._values = e, this._selector = n } return t.prototype["@@iterator"] = function () { return this }, t.prototype[a] = function () { return this }, t.prototype.next = function () { var t = this._index; if (t >= 0 && t < this._keys.length) { var n = this._selector(this._keys[t], this._values[t]); return t + 1 >= this._keys.length ? (this._index = -1, this._keys = e, this._values = e) : this._index++, { value: n, done: !1 } } return { value: void 0, done: !0 } }, t.prototype.throw = function (t) { throw this._index >= 0 && (this._index = -1, this._keys = e, this._values = e), t }, t.prototype.return = function (t) { return this._index >= 0 && (this._index = -1, this._keys = e, this._values = e), { value: t, done: !0 } }, t }(); return function () { function e() { this._keys = [], this._values = [], this._cacheKey = t, this._cacheIndex = -2 } return Object.defineProperty(e.prototype, "size", { get: function () { return this._keys.length }, enumerable: !0, configurable: !0 }), e.prototype.has = function (t) { return this._find(t, !1) >= 0 }, e.prototype.get = function (t) { var e = this._find(t, !1); return e >= 0 ? this._values[e] : void 0 }, e.prototype.set = function (t, e) { var n = this._find(t, !0); return this._values[n] = e, this }, e.prototype.delete = function (e) { var n = this._find(e, !1); if (n >= 0) { for (var r = this._keys.length, i = n + 1; i < r; i++)this._keys[i - 1] = this._keys[i], this._values[i - 1] = this._values[i]; return this._keys.length--, this._values.length--, e === this._cacheKey && (this._cacheKey = t, this._cacheIndex = -2), !0 } return !1 }, e.prototype.clear = function () { this._keys.length = 0, this._values.length = 0, this._cacheKey = t, this._cacheIndex = -2 }, e.prototype.keys = function () { return new n(this._keys, this._values, r) }, e.prototype.values = function () { return new n(this._keys, this._values, i) }, e.prototype.entries = function () { return new n(this._keys, this._values, s) }, e.prototype["@@iterator"] = function () { return this.entries() }, e.prototype[a] = function () { return this.entries() }, e.prototype._find = function (t, e) { return this._cacheKey !== t && (this._cacheIndex = this._keys.indexOf(this._cacheKey = t)), this._cacheIndex < 0 && e && (this._cacheIndex = this._keys.length, this._keys.push(t), this._values.push(void 0)), this._cacheIndex }, e }(); function r(t, e) { return t } function i(t, e) { return e } function s(t, e) { return [t, e] } } function nt() { return function () { function t() { this._map = new u } return Object.defineProperty(t.prototype, "size", { get: function () { return this._map.size }, enumerable: !0, configurable: !0 }), t.prototype.has = function (t) { return this._map.has(t) }, t.prototype.add = function (t) { return this._map.set(t, t), this }, t.prototype.delete = function (t) { return this._map.delete(t) }, t.prototype.clear = function () { this._map.clear() }, t.prototype.keys = function () { return this._map.keys() }, t.prototype.values = function () { return this._map.values() }, t.prototype.entries = function () { return this._map.entries() }, t.prototype["@@iterator"] = function () { return this.keys() }, t.prototype[a] = function () { return this.keys() }, t }() } function rt() { var t = 16, n = l.create(), r = i(); return function () { function t() { this._key = i() } return t.prototype.has = function (t) { var e = a(t, !1); return void 0 !== e && l.has(e, this._key) }, t.prototype.get = function (t) { var e = a(t, !1); return void 0 !== e ? l.get(e, this._key) : void 0 }, t.prototype.set = function (t, e) { return a(t, !0)[this._key] = e, this }, t.prototype.delete = function (t) { var e = a(t, !1); return void 0 !== e && delete e[this._key] }, t.prototype.clear = function () { this._key = i() }, t }(); function i() { var t; do { t = "@@WeakMap@@" + c() } while (l.has(n, t)); return n[t] = !0, t } function a(t, n) { if (!e.call(t, r)) { if (!n) return; Object.defineProperty(t, r, { value: l.create() }) } return t[r] } function s(t, e) { for (var n = 0; n < e; ++n)t[n] = 255 * Math.random() | 0; return t } function o(t) { return "function" == typeof Uint8Array ? "undefined" != typeof crypto ? crypto.getRandomValues(new Uint8Array(t)) : "undefined" != typeof msCrypto ? msCrypto.getRandomValues(new Uint8Array(t)) : s(new Uint8Array(t), t) : s(new Array(t), t) } function c() { var e = o(t); e[6] = 79 & e[6] | 64, e[8] = 191 & e[8] | 128; for (var n = "", r = 0; r < t; ++r) { var i = e[r]; 4 !== r && 6 !== r && 8 !== r || (n += "-"), i < 16 && (n += "0"), n += i.toString(16).toLowerCase() } return n } } function it(t) { return t.__ = void 0, delete t.__, t } t("decorate", g), t("metadata", m), t("defineMetadata", b), t("hasMetadata", w), t("hasOwnMetadata", y), t("getMetadata", v), t("getOwnMetadata", _), t("getMetadataKeys", x), t("getOwnMetadataKeys", k), t("deleteMetadata", E) }(a) }() }(r || (r = {}))
  }, 77834: function (t, e, n) {
    /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
    var r = n(48834), i = r.Buffer; function a(t, e) { for (var n in t) e[n] = t[n] } function s(t, e, n) { return i(t, e, n) } i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? t.exports = r : (a(r, e), e.Buffer = s), s.prototype = Object.create(i.prototype), a(i, s), s.from = function (t, e, n) { if ("number" == typeof t) throw new TypeError("Argument must not be a number"); return i(t, e, n) }, s.alloc = function (t, e, n) { if ("number" != typeof t) throw new TypeError("Argument must be a number"); var r = i(t); return void 0 !== e ? "string" == typeof n ? r.fill(e, n) : r.fill(e) : r.fill(0), r }, s.allocUnsafe = function (t) { if ("number" != typeof t) throw new TypeError("Argument must be a number"); return i(t) }, s.allocUnsafeSlow = function (t) { if ("number" != typeof t) throw new TypeError("Argument must be a number"); return r.SlowBuffer(t) }
  }, 27654: function (t, e, n) { "use strict"; var r, i = n(34406), a = n(48834), s = a.Buffer, o = {}; for (r in a) a.hasOwnProperty(r) && "SlowBuffer" !== r && "Buffer" !== r && (o[r] = a[r]); var c = o.Buffer = {}; for (r in s) s.hasOwnProperty(r) && "allocUnsafe" !== r && "allocUnsafeSlow" !== r && (c[r] = s[r]); if (o.Buffer.prototype = s.prototype, c.from && c.from !== Uint8Array.from || (c.from = function (t, e, n) { if ("number" == typeof t) throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof t); if (t && void 0 === t.length) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t); return s(t, e, n) }), c.alloc || (c.alloc = function (t, e, n) { if ("number" != typeof t) throw new TypeError('The "size" argument must be of type number. Received type ' + typeof t); if (t < 0 || t >= 2 * (1 << 30)) throw new RangeError('The value "' + t + '" is invalid for option "size"'); var r = s(t); return e && 0 !== e.length ? "string" == typeof n ? r.fill(e, n) : r.fill(e) : r.fill(0), r }), !o.kStringMaxLength) try { o.kStringMaxLength = i.binding("buffer").kStringMaxLength } catch (t) { } o.constants || (o.constants = { MAX_LENGTH: o.kMaxLength }, o.kStringMaxLength && (o.constants.MAX_STRING_LENGTH = o.kStringMaxLength)), t.exports = o }, 30214: function (t, e, n) { "use strict"; var r = n(77834).Buffer, i = r.isEncoding || function (t) { switch ((t = "" + t) && t.toLowerCase()) { case "hex": case "utf8": case "utf-8": case "ascii": case "binary": case "base64": case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": case "raw": return !0; default: return !1 } }; function a(t) { var e; switch (this.encoding = function (t) { var e = function (t) { if (!t) return "utf8"; for (var e; ;)switch (t) { case "utf8": case "utf-8": return "utf8"; case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return "utf16le"; case "latin1": case "binary": return "latin1"; case "base64": case "ascii": case "hex": return t; default: if (e) return; t = ("" + t).toLowerCase(), e = !0 } }(t); if ("string" != typeof e && (r.isEncoding === i || !i(t))) throw new Error("Unknown encoding: " + t); return e || t }(t), this.encoding) { case "utf16le": this.text = c, this.end = l, e = 4; break; case "utf8": this.fillLast = o, e = 4; break; case "base64": this.text = f, this.end = d, e = 3; break; default: return this.write = u, void (this.end = h) }this.lastNeed = 0, this.lastTotal = 0, this.lastChar = r.allocUnsafe(e) } function s(t) { return t <= 127 ? 0 : t >> 5 == 6 ? 2 : t >> 4 == 14 ? 3 : t >> 3 == 30 ? 4 : t >> 6 == 2 ? -1 : -2 } function o(t) { var e = this.lastTotal - this.lastNeed, n = function (t, e, n) { if (128 != (192 & e[0])) return t.lastNeed = 0, ""; if (t.lastNeed > 1 && e.length > 1) { if (128 != (192 & e[1])) return t.lastNeed = 1, ""; if (t.lastNeed > 2 && e.length > 2 && 128 != (192 & e[2])) return t.lastNeed = 2, "" } }(this, t); return void 0 !== n ? n : this.lastNeed <= t.length ? (t.copy(this.lastChar, e, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (t.copy(this.lastChar, e, 0, t.length), void (this.lastNeed -= t.length)) } function c(t, e) { if ((t.length - e) % 2 == 0) { var n = t.toString("utf16le", e); if (n) { var r = n.charCodeAt(n.length - 1); if (r >= 55296 && r <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1], n.slice(0, -1) } return n } return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t[t.length - 1], t.toString("utf16le", e, t.length - 1) } function l(t) { var e = t && t.length ? this.write(t) : ""; if (this.lastNeed) { var n = this.lastTotal - this.lastNeed; return e + this.lastChar.toString("utf16le", 0, n) } return e } function f(t, e) { var n = (t.length - e) % 3; return 0 === n ? t.toString("base64", e) : (this.lastNeed = 3 - n, this.lastTotal = 3, 1 === n ? this.lastChar[0] = t[t.length - 1] : (this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1]), t.toString("base64", e, t.length - n)) } function d(t) { var e = t && t.length ? this.write(t) : ""; return this.lastNeed ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e } function u(t) { return t.toString(this.encoding) } function h(t) { return t && t.length ? this.write(t) : "" } e.s = a, a.prototype.write = function (t) { if (0 === t.length) return ""; var e, n; if (this.lastNeed) { if (void 0 === (e = this.fillLast(t))) return ""; n = this.lastNeed, this.lastNeed = 0 } else n = 0; return n < t.length ? e ? e + this.text(t, n) : this.text(t, n) : e || "" }, a.prototype.end = function (t) { var e = t && t.length ? this.write(t) : ""; return this.lastNeed ? e + "" : e }, a.prototype.text = function (t, e) { var n = function (t, e, n) { var r = e.length - 1; if (r < n) return 0; var i = s(e[r]); if (i >= 0) return i > 0 && (t.lastNeed = i - 1), i; if (--r < n || -2 === i) return 0; if (i = s(e[r]), i >= 0) return i > 0 && (t.lastNeed = i - 2), i; if (--r < n || -2 === i) return 0; if (i = s(e[r]), i >= 0) return i > 0 && (2 === i ? i = 0 : t.lastNeed = i - 3), i; return 0 }(this, t, e); if (!this.lastNeed) return t.toString("utf8", e); this.lastTotal = n; var r = t.length - (n - this.lastNeed); return t.copy(this.lastChar, 0, r), t.toString("utf8", e, r) }, a.prototype.fillLast = function (t) { if (this.lastNeed <= t.length) return t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal); t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length), this.lastNeed -= t.length } }, 85580: function (t) { const e = /^[-+]?0x[a-fA-F0-9]+$/, n = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/; !Number.parseInt && window.parseInt && (Number.parseInt = window.parseInt), !Number.parseFloat && window.parseFloat && (Number.parseFloat = window.parseFloat); const r = { hex: !0, leadingZeros: !0, decimalPoint: ".", eNotation: !0 }; t.exports = function (t, i = {}) { if (i = Object.assign({}, r, i), !t || "string" != typeof t) return t; let a = t.trim(); if (void 0 !== i.skipLike && i.skipLike.test(a)) return t; if (i.hex && e.test(a)) return Number.parseInt(a, 16); { const e = n.exec(a); if (e) { const n = e[1], r = e[2]; let s = function (t) { if (t && -1 !== t.indexOf(".")) return "." === (t = t.replace(/0+$/, "")) ? t = "0" : "." === t[0] ? t = "0" + t : "." === t[t.length - 1] && (t = t.substr(0, t.length - 1)), t; return t }(e[3]); const o = e[4] || e[6]; if (!i.leadingZeros && r.length > 0 && n && "." !== a[2]) return t; if (!i.leadingZeros && r.length > 0 && !n && "." !== a[1]) return t; { const e = Number(a), c = "" + e; return -1 !== c.search(/[eE]/) || o ? i.eNotation ? e : t : -1 !== a.indexOf(".") ? "0" === c && "" === s || c === s || n && c === "-" + s ? e : t : r ? s === c || n + s === c ? e : t : a === c || a === n + c ? e : t } } return t } } }, 1707: function (t, e, n) { var r = n(34406); !function () { var e = {}; function i() { void 0 === r && console.log.apply(console, arguments) } t.exports = e, function (t, e) { var n, r, a; n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, r = function () { function t(t) { this.message = "JPEG error: " + t } return t.prototype = Error(), t.prototype.name = "JpegError", t.constructor = t }(), a = function () { function t(t, e) { this.message = t, this.g = e } return t.prototype = Error(), t.prototype.name = "DNLMarkerError", t.constructor = t }(), function () { function e() { this.M = null, this.B = -1 } function i(t, e) { for (var n, r, i = 0, a = [], s = 16; 0 < s && !t[s - 1];)s--; a.push({ children: [], index: 0 }); var o, c = a[0]; for (n = 0; n < s; n++) { for (r = 0; r < t[n]; r++) { for ((c = a.pop()).children[c.index] = e[i]; 0 < c.index;)c = a.pop(); for (c.index++, a.push(c); a.length <= n;)a.push(o = { children: [], index: 0 }), c.children[c.index] = o.children, c = o; i++ } n + 1 < s && (a.push(o = { children: [], index: 0 }), c.children[c.index] = o.children, c = o) } return a[0].children } function s(t, e, i, s, o, f, d, u, h) { function p() { if (0 < C) return C--, z >> C & 1; if (255 === (z = t[e++])) { var n = t[e++]; if (n) { if (220 === n && A) { e += 2; var s = t[e++] << 8 | t[e++]; if (0 < s && s !== i.g) throw new a("Found DNL marker (0xFFDC) while parsing scan data", s) } throw new r("unexpected marker " + (z << 8 | n).toString(16)) } } return C = 7, z >>> 7 } function g(t) { for (; ;) { if ("number" == typeof (t = t[p()])) return t; if ("object" !== (void 0 === t ? "undefined" : n(t))) throw new r("invalid huffman sequence") } } function m(t) { for (var e = 0; 0 < t;)e = e << 1 | p(), t--; return e } function b(t) { if (1 === t) return 1 === p() ? 1 : -1; var e = m(t); return e >= 1 << t - 1 ? e : e + (-1 << t) + 1 } for (var w, y, v, _, x, k, E, A = 9 < arguments.length && void 0 !== arguments[9] && arguments[9], S = i.P, B = e, z = 0, C = 0, U = 0, I = 0, T = s.length, N = i.S ? 0 === f ? 0 === u ? function (t, e) { var n = g(t.D); n = 0 === n ? 0 : b(n) << h, t.a[e] = t.m += n } : function (t, e) { t.a[e] |= p() << h } : 0 === u ? function (t, e) { if (0 < U) U--; else for (var n = f; n <= d;) { var r = g(t.o), i = 15 & r; if (r >>= 4, 0 === i) { if (15 > r) { U = m(r) + (1 << r) - 1; break } n += 16 } else n += r, t.a[e + l[n]] = b(i) * (1 << h), n++ } } : function (t, e) { for (var n, i = f, a = 0; i <= d;) { n = e + l[i]; var s = 0 > t.a[n] ? -1 : 1; switch (I) { case 0: if (n = 15 & (a = g(t.o)), a >>= 4, 0 === n) 15 > a ? (U = m(a) + (1 << a), I = 4) : (a = 16, I = 1); else { if (1 !== n) throw new r("invalid ACn encoding"); w = b(n), I = a ? 2 : 3 } continue; case 1: case 2: t.a[n] ? t.a[n] += s * (p() << h) : 0 == --a && (I = 2 === I ? 3 : 0); break; case 3: t.a[n] ? t.a[n] += s * (p() << h) : (t.a[n] = w << h, I = 0); break; case 4: t.a[n] && (t.a[n] += s * (p() << h)) }i++ } 4 === I && 0 == --U && (I = 0) } : function (t, e) { var n = g(t.D); for (n = 0 === n ? 0 : b(n), t.a[e] = t.m += n, n = 1; 64 > n;) { var r = g(t.o), i = 15 & r; if (r >>= 4, 0 === i) { if (15 > r) break; n += 16 } else n += r, t.a[e + l[n]] = b(i), n++ } }, j = 0, O = 1 === T ? s[0].c * s[0].l : S * i.O; j < O;) { var D = o ? Math.min(O - j, o) : O; for (y = 0; y < T; y++)s[y].m = 0; if (U = 0, 1 === T) { var M = s[0]; for (x = 0; x < D; x++)N(M, 64 * ((M.c + 1) * (j / M.c | 0) + j % M.c)), j++ } else for (x = 0; x < D; x++) { for (y = 0; y < T; y++)for (k = (M = s[y]).h, E = M.j, v = 0; v < E; v++)for (_ = 0; _ < k; _++)N(M, 64 * ((M.c + 1) * ((j / S | 0) * M.j + v) + (j % S * M.h + _))); j++ } if (C = 0, (M = c(t, e)) && M.f && ((0, _util.warn)("decodeScan - unexpected MCU data, current marker is: " + M.f), e = M.offset), !(M = M && M.F) || 65280 >= M) throw new r("marker was not found"); if (!(65488 <= M && 65495 >= M)) break; e += 2 } return (M = c(t, e)) && M.f && ((0, _util.warn)("decodeScan - unexpected Scan data, current marker is: " + M.f), e = M.offset), e - B } function o(t, e) { for (var n = e.c, i = e.l, a = new Int16Array(64), s = 0; s < i; s++)for (var o = 0; o < n; o++) { var c = 64 * ((e.c + 1) * s + o), l = a, f = e.G, d = e.a; if (!f) throw new r("missing required Quantization Table."); for (var u = 0; 64 > u; u += 8) { var h = d[c + u], p = d[c + u + 1], g = d[c + u + 2], m = d[c + u + 3], b = d[c + u + 4], w = d[c + u + 5], y = d[c + u + 6], v = d[c + u + 7]; if (h *= f[u], 0 == (p | g | m | b | w | y | v)) h = 5793 * h + 512 >> 10, l[u] = h, l[u + 1] = h, l[u + 2] = h, l[u + 3] = h, l[u + 4] = h, l[u + 5] = h, l[u + 6] = h, l[u + 7] = h; else { p *= f[u + 1], g *= f[u + 2], m *= f[u + 3], b *= f[u + 4], w *= f[u + 5]; var _ = 5793 * h + 128 >> 8, x = 5793 * b + 128 >> 8, k = g, E = y *= f[u + 6]; x = (_ = _ + x + 1 >> 1) - x, h = 3784 * k + 1567 * E + 128 >> 8, k = 1567 * k - 3784 * E + 128 >> 8, w = (b = (b = 2896 * (p - (v *= f[u + 7])) + 128 >> 8) + (w <<= 4) + 1 >> 1) - w, m = (v = (v = 2896 * (p + v) + 128 >> 8) + (m <<= 4) + 1 >> 1) - m, E = (_ = _ + (E = h) + 1 >> 1) - E, k = (x = x + k + 1 >> 1) - k, h = 2276 * b + 3406 * v + 2048 >> 12, b = 3406 * b - 2276 * v + 2048 >> 12, v = h, h = 799 * m + 4017 * w + 2048 >> 12, m = 4017 * m - 799 * w + 2048 >> 12, w = h, l[u] = _ + v, l[u + 7] = _ - v, l[u + 1] = x + w, l[u + 6] = x - w, l[u + 2] = k + m, l[u + 5] = k - m, l[u + 3] = E + b, l[u + 4] = E - b } } for (f = 0; 8 > f; ++f)h = l[f], 0 == ((p = l[f + 8]) | (g = l[f + 16]) | (m = l[f + 24]) | (b = l[f + 32]) | (w = l[f + 40]) | (y = l[f + 48]) | (v = l[f + 56])) ? (h = -2040 > (h = 5793 * h + 8192 >> 14) ? 0 : 2024 <= h ? 255 : h + 2056 >> 4, d[c + f] = h, d[c + f + 8] = h, d[c + f + 16] = h, d[c + f + 24] = h, d[c + f + 32] = h, d[c + f + 40] = h, d[c + f + 48] = h, d[c + f + 56] = h) : (_ = 5793 * h + 2048 >> 12, x = 5793 * b + 2048 >> 12, h = 3784 * (k = g) + 1567 * (E = y) + 2048 >> 12, k = 1567 * k - 3784 * E + 2048 >> 12, E = h, w = (b = (b = 2896 * (p - v) + 2048 >> 12) + w + 1 >> 1) - w, m = (v = (v = 2896 * (p + v) + 2048 >> 12) + m + 1 >> 1) - m, h = 2276 * b + 3406 * v + 2048 >> 12, b = 3406 * b - 2276 * v + 2048 >> 12, v = h, h = 799 * m + 4017 * w + 2048 >> 12, m = 4017 * m - 799 * w + 2048 >> 12, p = (x = (x = (_ = 4112 + (_ + x + 1 >> 1)) - x) + k + 1 >> 1) + (w = h), y = x - w, w = (k = x - k) - m, h = 16 > (h = (_ = _ + E + 1 >> 1) + v) ? 0 : 4080 <= h ? 255 : h >> 4, p = 16 > p ? 0 : 4080 <= p ? 255 : p >> 4, g = 16 > (g = k + m) ? 0 : 4080 <= g ? 255 : g >> 4, m = 16 > (m = (E = _ - E) + b) ? 0 : 4080 <= m ? 255 : m >> 4, b = 16 > (b = E - b) ? 0 : 4080 <= b ? 255 : b >> 4, w = 16 > w ? 0 : 4080 <= w ? 255 : w >> 4, y = 16 > y ? 0 : 4080 <= y ? 255 : y >> 4, v = 16 > (v = _ - v) ? 0 : 4080 <= v ? 255 : v >> 4, d[c + f] = h, d[c + f + 8] = p, d[c + f + 16] = g, d[c + f + 24] = m, d[c + f + 32] = b, d[c + f + 40] = w, d[c + f + 48] = y, d[c + f + 56] = v) } return e.a } function c(t, e) { var n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : e, r = t.length - 1; if (n = n < e ? n : e, e >= r) return null; var i = t[e] << 8 | t[e + 1]; if (65472 <= i && 65534 >= i) return { f: null, F: i, offset: e }; for (var a = t[n] << 8 | t[n + 1]; !(65472 <= a && 65534 >= a);) { if (++n >= r) return null; a = t[n] << 8 | t[n + 1] } return { f: i.toString(16), F: a, offset: n } } var l = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]); e.prototype = { parse: function (t) { function e() { var e = t[h] << 8 | t[h + 1]; return h += 2, e } function n() { var n = e(), r = c(t, n = h + n - 2, h); return r && r.f && ((0, _util.warn)("readDataBlock - incorrect length, current marker is: " + r.f), n = r.offset), n = t.subarray(h, n), h += n.length, n } function f(t) { for (var e = Math.ceil(t.v / 8 / t.s), n = Math.ceil(t.g / 8 / t.u), r = 0; r < t.b.length; r++) { B = t.b[r]; var i = Math.ceil(Math.ceil(t.v / 8) * B.h / t.s), a = Math.ceil(Math.ceil(t.g / 8) * B.j / t.u); B.a = new Int16Array(64 * n * B.j * (e * B.h + 1)), B.c = i, B.l = a } t.P = e, t.O = n } var d = (1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}).N, u = void 0 === d ? null : d, h = 0, p = null, g = 0; d = []; var m = [], b = [], w = e(); if (65496 !== w) throw new r("SOI not found"); for (w = e(); 65497 !== w;) { switch (w) { case 65504: case 65505: case 65506: case 65507: case 65508: case 65509: case 65510: case 65511: case 65512: case 65513: case 65514: case 65515: case 65516: case 65517: case 65518: case 65519: case 65534: var y = n(); 65518 === w && 65 === y[0] && 100 === y[1] && 111 === y[2] && 98 === y[3] && 101 === y[4] && (p = { version: y[5] << 8 | y[6], Y: y[7] << 8 | y[8], Z: y[9] << 8 | y[10], W: y[11] }); break; case 65499: w = e() + h - 2; for (var v; h < w;) { var _ = t[h++], x = new Uint16Array(64); if (0 == _ >> 4) for (y = 0; 64 > y; y++)x[v = l[y]] = t[h++]; else { if (1 != _ >> 4) throw new r("DQT - invalid table spec"); for (y = 0; 64 > y; y++)x[v = l[y]] = e() } d[15 & _] = x } break; case 65472: case 65473: case 65474: if (k) throw new r("Only single frame JPEGs supported"); e(); var k = {}; for (k.X = 65473 === w, k.S = 65474 === w, k.precision = t[h++], w = e(), k.g = u || w, k.v = e(), k.b = [], k.C = {}, y = t[h++], w = x = _ = 0; w < y; w++) { v = t[h]; var E = t[h + 1] >> 4, A = 15 & t[h + 1]; _ < E && (_ = E), x < A && (x = A), E = k.b.push({ h: E, j: A, T: t[h + 2], G: null }), k.C[v] = E - 1, h += 3 } k.s = _, k.u = x, f(k); break; case 65476: for (v = e(), w = 2; w < v;) { for (_ = t[h++], x = new Uint8Array(16), y = E = 0; 16 > y; y++, h++)E += x[y] = t[h]; for (A = new Uint8Array(E), y = 0; y < E; y++, h++)A[y] = t[h]; w += 17 + E, (0 == _ >> 4 ? b : m)[15 & _] = i(x, A) } break; case 65501: e(); var S = e(); break; case 65498: for (y = 1 == ++g && !u, e(), _ = t[h++], v = [], w = 0; w < _; w++) { x = k.C[t[h++]]; var B = k.b[x]; x = t[h++], B.D = b[x >> 4], B.o = m[15 & x], v.push(B) } w = t[h++], _ = t[h++], x = t[h++]; try { var z = s(t, h, k, v, S, w, _, x >> 4, 15 & x, y); h += z } catch (e) { if (e instanceof a) return (0, _util.warn)('Attempting to re-parse JPEG image using "scanLines" parameter found in DNL marker (0xFFDC) segment.'), this.parse(t, { N: e.g }); throw e } break; case 65500: h += 4; break; case 65535: 255 !== t[h] && h--; break; default: if (255 === t[h - 3] && 192 <= t[h - 2] && 254 >= t[h - 2]) h -= 3; else { if (!(y = c(t, h - 2)) || !y.f) throw new r("unknown marker " + w.toString(16)); (0, _util.warn)("JpegImage.parse - unexpected data, current marker is: " + y.f), h = y.offset } }w = e() } for (this.width = k.v, this.height = k.g, this.A = p, this.b = [], w = 0; w < k.b.length; w++)(S = d[(B = k.b[w]).T]) && (B.G = S), this.b.push({ R: o(0, B), U: B.h / k.s, V: B.j / k.u, c: B.c, l: B.l }); this.i = this.b.length }, L: function (t, e) { var n, r, i = this.width / t, a = this.height / e, s = this.b.length, o = t * e * s, c = new Uint8ClampedArray(o), l = new Uint32Array(t); for (r = 0; r < s; r++) { var f = this.b[r], d = f.U * i, u = f.V * a, h = r, p = f.R, g = f.c + 1 << 3; for (n = 0; n < t; n++)f = 0 | n * d, l[n] = (4294967288 & f) << 3 | 7 & f; for (d = 0; d < e; d++)for (f = g * (4294967288 & (f = 0 | d * u)) | (7 & f) << 3, n = 0; n < t; n++)c[h] = p[f + l[n]], h += s } if (a = this.M) for (r = 0; r < o;)for (i = f = 0; f < s; f++, r++, i += 2)c[r] = (c[r] * a[i] >> 8) + a[i + 1]; return c }, w: function () { return this.A ? !!this.A.W : 3 === this.i ? 0 !== this.B : 1 === this.B }, I: function (t) { for (var e, n, r, i = 0, a = t.length; i < a; i += 3)e = t[i], n = t[i + 1], r = t[i + 2], t[i] = e - 179.456 + 1.402 * r, t[i + 1] = e + 135.459 - .344 * n - .714 * r, t[i + 2] = e - 226.816 + 1.772 * n; return t }, K: function (t) { for (var e, n, r, i, a = 0, s = 0, o = t.length; s < o; s += 4)e = t[s], n = t[s + 1], r = t[s + 2], i = t[s + 3], t[a++] = n * (-660635669420364e-19 * n + .000437130475926232 * r - 54080610064599e-18 * e + .00048449797120281 * i - .154362151871126) - 122.67195406894 + r * (-.000957964378445773 * r + .000817076911346625 * e - .00477271405408747 * i + 1.53380253221734) + e * (.000961250184130688 * e - .00266257332283933 * i + .48357088451265) + i * (-.000336197177618394 * i + .484791561490776), t[a++] = 107.268039397724 + n * (219927104525741e-19 * n - .000640992018297945 * r + .000659397001245577 * e + .000426105652938837 * i - .176491792462875) + r * (-.000778269941513683 * r + .00130872261408275 * e + .000770482631801132 * i - .151051492775562) + e * (.00126935368114843 * e - .00265090189010898 * i + .25802910206845) + i * (-.000318913117588328 * i - .213742400323665), t[a++] = n * (-.000570115196973677 * n - 263409051004589e-19 * r + .0020741088115012 * e - .00288260236853442 * i + .814272968359295) - 20.810012546947 + r * (-153496057440975e-19 * r - .000132689043961446 * e + .000560833691242812 * i - .195152027534049) + e * (.00174418132927582 * e - .00255243321439347 * i + .116935020465145) + i * (-.000343531996510555 * i + .24165260232407); return t.subarray(0, a) }, J: function (t) { for (var e, n, r, i = 0, a = t.length; i < a; i += 4)e = t[i], n = t[i + 1], r = t[i + 2], t[i] = 434.456 - e - 1.402 * r, t[i + 1] = 119.541 - e + .344 * n + .714 * r, t[i + 2] = 481.816 - e - 1.772 * n; return t }, H: function (t) { for (var e, n, r, i, a = 0, s = 1 / 255, o = 0, c = t.length; o < c; o += 4)e = t[o] * s, n = t[o + 1] * s, r = t[o + 2] * s, i = t[o + 3] * s, t[a++] = 255 + e * (-4.387332384609988 * e + 54.48615194189176 * n + 18.82290502165302 * r + 212.25662451639585 * i - 285.2331026137004) + n * (1.7149763477362134 * n - 5.6096736904047315 * r - 17.873870861415444 * i - 5.497006427196366) + r * (-2.5217340131683033 * r - 21.248923337353073 * i + 17.5119270841813) - i * (21.86122147463605 * i + 189.48180835922747), t[a++] = 255 + e * (8.841041422036149 * e + 60.118027045597366 * n + 6.871425592049007 * r + 31.159100130055922 * i - 79.2970844816548) + n * (-15.310361306967817 * n + 17.575251261109482 * r + 131.35250912493976 * i - 190.9453302588951) + r * (4.444339102852739 * r + 9.8632861493405 * i - 24.86741582555878) - i * (20.737325471181034 * i + 187.80453709719578), t[a++] = 255 + e * (.8842522430003296 * e + 8.078677503112928 * n + 30.89978309703729 * r - .23883238689178934 * i - 14.183576799673286) + n * (10.49593273432072 * n + 63.02378494754052 * r + 50.606957656360734 * i - 112.23884253719248) + r * (.03296041114873217 * r + 115.60384449646641 * i - 193.58209356861505) - i * (22.33816807309886 * i + 180.12613974708367); return t.subarray(0, a) }, getData: function (t, e, n) { if (4 < this.i) throw new r("Unsupported color mode"); if (t = this.L(t, e), 1 === this.i && n) { n = t.length, e = new Uint8ClampedArray(3 * n); for (var i = 0, a = 0; a < n; a++) { var s = t[a]; e[i++] = s, e[i++] = s, e[i++] = s } return e } if (3 === this.i && this.w()) return this.I(t); if (4 === this.i) { if (this.w()) return n ? this.K(t) : this.J(t); if (n) return this.H(t) } return t } }, t.JpegDecoder = e }(), t.encodeImage = function (e, n, r, i) { var a = { t256: [n], t257: [r], t258: [8, 8, 8, 8], t259: [1], t262: [2], t273: [1e3], t277: [4], t278: [r], t279: [n * r * 4], t282: [1], t283: [1], t284: [1], t286: [0], t287: [0], t296: [1], t305: ["Photopea (UTIF.js)"], t338: [1] }; if (i) for (var s in i) a[s] = i[s]; var o = new Uint8Array(t.encode([a])), c = new Uint8Array(e), l = new Uint8Array(1e3 + n * r * 4); for (s = 0; s < o.length; s++)l[s] = o[s]; for (s = 0; s < c.length; s++)l[1e3 + s] = c[s]; return l.buffer }, t.encode = function (e) { var n = new Uint8Array(2e4), r = 4, i = t._binBE; n[0] = 77, n[1] = 77, n[3] = 42; var a = 8; i.writeUint(n, r, a), r += 4; for (var s = 0; s < e.length; s++) { var o = t._writeIFD(i, n, a, e[s]); a = o[1], s < e.length - 1 && i.writeUint(n, o[0], a) } return n.slice(0, a).buffer }, t.decode = function (e) { t.decode._decodeG3.allow2D = null; var n = new Uint8Array(e), r = 0, i = t._binBE.readASCII(n, r, 2); r += 2; var a = "II" == i ? t._binLE : t._binBE; a.readUshort(n, r); r += 2; var s = a.readUint(n, r); r += 4; for (var o = []; ;) { var c = t._readIFD(a, n, s, o, 0, !1); if (0 == (s = a.readUint(n, c))) break } return o }, t.decodeImage = function (e, n, r) { var a = new Uint8Array(e), s = t._binBE.readASCII(a, 0, 2); if (null != n.t256) { n.isLE = "II" == s, n.width = n.t256[0], n.height = n.t257[0]; var o, c = n.t259 ? n.t259[0] : 1, l = n.t266 ? n.t266[0] : 1; n.t284 && 2 == n.t284[0] && i("PlanarConfiguration 2 should not be used!"), o = n.t258 ? Math.min(32, n.t258[0]) * n.t258.length : n.t277 ? n.t277[0] : 1, 1 == c && null != n.t279 && n.t278 && 32803 == n.t262[0] && (o = Math.round(8 * n.t279[0] / (n.width * n.t278[0]))); var f = 8 * Math.ceil(n.width * o / 8), d = n.t273; null == d && (d = n.t324); var u = n.t279; 1 == c && 1 == d.length && (u = [n.height * (f >>> 3)]), null == u && (u = n.t325); var h = new Uint8Array(n.height * (f >>> 3)), p = 0; if (null != n.t322) { for (var g = n.t322[0], m = n.t323[0], b = Math.floor((n.width + g - 1) / g), w = Math.floor((n.height + m - 1) / m), y = new Uint8Array(0 | Math.ceil(g * m * o / 8)), v = 0; v < w; v++)for (var _ = 0; _ < b; _++) { for (var x = v * b + _, k = 0; k < y.length; k++)y[k] = 0; t.decode._decompress(n, r, a, d[x], u[x], c, y, 0, l), 6 == c ? h = y : t._copyTile(y, 0 | Math.ceil(g * o / 8), m, h, 0 | Math.ceil(n.width * o / 8), n.height, 0 | Math.ceil(_ * g * o / 8), v * m) } p = 8 * h.length } else { var E = n.t278 ? n.t278[0] : n.height; E = Math.min(E, n.height); for (x = 0; x < d.length; x++)t.decode._decompress(n, r, a, d[x], u[x], c, h, 0 | Math.ceil(p / 8), l), p += f * E; p = Math.min(p, 8 * h.length) } n.data = new Uint8Array(h.buffer, 0, 0 | Math.ceil(p / 8)) } }, t.decode._decompress = function (n, r, a, s, o, c, l, f, d) { if (1 == c || o == l.length && 32767 != c) for (var u = 0; u < o; u++)l[f + u] = a[s + u]; else if (3 == c) t.decode._decodeG3(a, s, o, l, f, n.width, d); else if (4 == c) t.decode._decodeG4(a, s, o, l, f, n.width, d); else if (5 == c) t.decode._decodeLZW(a, s, l, f); else if (6 == c) t.decode._decodeOldJPEG(n, a, s, o, l, f); else if (7 == c) t.decode._decodeNewJPEG(n, a, s, o, l, f); else if (8 == c) for (var h = new Uint8Array(a.buffer, s, o), p = e.inflate(h), g = 0; g < p.length; g++)l[f + g] = p[g]; else 32767 == c ? t.decode._decodeARW(n, a, s, o, l, f) : 32773 == c ? t.decode._decodePackBits(a, s, o, l, f) : 32809 == c ? t.decode._decodeThunder(a, s, o, l, f) : 34713 == c ? t.decode._decodeNikon(n, r, a, s, o, l, f) : i("Unknown compression", c); var m = n.t258 ? Math.min(32, n.t258[0]) : 1, b = n.t277 ? n.t277[0] : 1, w = m * b >>> 3, y = n.t278 ? n.t278[0] : n.height, v = Math.ceil(m * b * n.width / 8); if (16 == m && !n.isLE && null == n.t33422) for (var _ = 0; _ < y; _++)for (var x = f + _ * v, k = 1; k < v; k += 2) { var E = l[x + k]; l[x + k] = l[x + k - 1], l[x + k - 1] = E } if (n.t317 && 2 == n.t317[0]) for (_ = 0; _ < y; _++) { var A = f + _ * v; if (16 == m) for (u = w; u < v; u += 2) { var S = (l[A + u + 1] << 8 | l[A + u]) + (l[A + u - w + 1] << 8 | l[A + u - w]); l[A + u] = 255 & S, l[A + u + 1] = S >>> 8 & 255 } else if (3 == b) for (u = 3; u < v; u += 3)l[A + u] = l[A + u] + l[A + u - 3] & 255, l[A + u + 1] = l[A + u + 1] + l[A + u - 2] & 255, l[A + u + 2] = l[A + u + 2] + l[A + u - 1] & 255; else for (u = w; u < v; u++)l[A + u] = l[A + u] + l[A + u - w] & 255 } }, t.decode._ljpeg_diff = function (e, n, r) { var i, a, s = t.decode._getbithuff; return i = s(e, n, r[0], r), 0 == ((a = s(e, n, i, 0)) & 1 << i - 1) && (a -= (1 << i) - 1), a }, t.decode._decodeARW = function (e, n, r, i, a, s) { var o = e.t256[0], c = e.t257[0], l = e.t258[0], f = e.isLE ? t._binLE : t._binBE; if (o * c == i || o * c * 1.5 == i) if (o * c * 1.5 != i) { var d, u, h, p, g, m, b, w, y = new Uint16Array(16), v = new Uint8Array(o + 1); for (z = 0; z < c; z++) { for (var _ = 0; _ < o; _++)v[_] = n[r++]; for (w = 0, B = 0; B < o - 30; w += 16) { for (u = 2047 & (d = f.readUint(v, w)), h = 2047 & d >>> 11, p = 15 & d >>> 22, g = 15 & d >>> 26, m = 0; m < 4 && 128 << m <= u - h; m++); for (b = 30, x = 0; x < 16; x++)x == p ? y[x] = u : x == g ? y[x] = h : (y[x] = ((f.readUshort(v, w + (b >> 3)) >>> (7 & b) & 127) << m) + h, y[x] > 2047 && (y[x] = 2047), b += 7); for (x = 0; x < 16; x++, B += 2) { D = y[x] << 1; t.decode._putsF(a, (z * o + B) * l, D << 16 - l) } B -= 1 & B ? 1 : 31 } } } else for (var x = 0; x < i; x += 3) { var k = n[r + x + 0], E = n[r + x + 1], A = n[r + x + 2]; a[s + x] = E << 4 | k >>> 4, a[s + x + 1] = k << 4 | A >>> 4, a[s + x + 2] = A << 4 | E >>> 4 } else { c += 8; var S, B, z, C = [r, 0, 0, 0], U = new Uint16Array(32770), I = [3857, 3856, 3599, 3342, 3085, 2828, 2571, 2314, 2057, 1800, 1543, 1286, 1029, 772, 771, 768, 514, 513], T = 0, N = t.decode._ljpeg_diff; for (U[0] = 15, S = x = 0; x < 18; x++)for (var j = 32768 >>> (I[x] >>> 8), O = 0; O < j; O++)U[++S] = I[x]; for (B = o; B--;)for (z = 0; z < c + 1; z += 2)if (z == c && (z = 1), T += N(n, C, U), z < c) { var D = 4095 & T; t.decode._putsF(a, (z * o + B) * l, D << 16 - l) } } }, t.decode._decodeNikon = function (e, n, r, i, a, s, o) { var c = [[0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 5, 4, 3, 6, 2, 7, 1, 0, 8, 9, 11, 10, 12], [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 57, 90, 56, 39, 22, 5, 4, 3, 2, 1, 0, 11, 12, 12], [0, 0, 1, 4, 2, 3, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 4, 6, 3, 7, 2, 8, 1, 9, 0, 10, 11, 12], [0, 0, 1, 4, 3, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 5, 6, 4, 7, 8, 3, 9, 2, 1, 0, 10, 11, 12, 13, 14], [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 8, 92, 75, 58, 41, 7, 6, 5, 4, 3, 2, 1, 0, 13, 14], [0, 0, 1, 4, 2, 2, 3, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 7, 6, 8, 5, 9, 4, 10, 3, 11, 12, 2, 0, 1, 13, 14]], l = e.t256[0], f = e.t257[0], d = e.t258[0], u = 0, h = 0, p = t.decode._make_decoder, g = t.decode._getbithuff, m = n[0].exifIFD.makerNote, b = m.t150 ? m.t150 : m.t140, w = 0, y = b[w++], v = b[w++]; 73 != y && 88 != v || (w += 2110), 70 == y && (u = 2), 14 == d && (u += 3); for (var _ = [[0, 0], [0, 0]], x = e.isLE ? t._binLE : t._binBE, k = 0; k < 2; k++)for (var E = 0; E < 2; E++)_[k][E] = x.readShort(b, w), w += 2; var A, S, B, z, C, U = 1 << d & 32767, I = 0, T = x.readShort(b, w); w += 2, T > 1 && (I = Math.floor(U / (T - 1))), 68 == y && 32 == v && I > 0 && (h = x.readShort(b, 562)); var N = [0, 0], j = p(c[u]), O = [i, 0, 0, 0]; for (A = 0; A < f; A++)for (h && A == h && (j = p(c[u + 1])), S = 0; S < l; S++) { k = g(r, O, j[0], j), 0 == ((C = 1 + (g(r, O, (B = 15 & k) - (z = k >>> 4), 0) << 1) << z >>> 1) & 1 << B - 1) && (C -= (1 << B) - (0 == z ? 1 : 0)), S < 2 ? N[S] = _[1 & A][S] += C : N[1 & S] += C; var D = Math.min(Math.max(N[1 & S], 0), (1 << d) - 1), M = (A * l + S) * d; t.decode._putsF(s, M, D << 16 - d) } }, t.decode._putsF = function (t, e, n) { n <<= 8 - (7 & e); var r = e >>> 3; t[r] |= n >>> 16, t[r + 1] |= n >>> 8, t[r + 2] |= n }, t.decode._getbithuff = function (e, n, r, i) { t.decode._get_byte; var a, s = n[0], o = n[1], c = n[2], l = n[3]; if (0 == r || c < 0) return 0; for (; !l && c < r && -1 != (a = e[s++]) && !(l = 0);)o = (o << 8) + a, c += 8; if (a = o << 32 - c >>> 32 - r, i ? (c -= i[a + 1] >>> 8, a = 255 & i[a + 1]) : c -= r, c < 0) throw "e"; return n[0] = s, n[1] = o, n[2] = c, n[3] = l, a }, t.decode._make_decoder = function (t) { var e, n, r, i, a, s = []; for (e = 16; 0 != e && !t[e]; e--); var o = 17; for (s[0] = e, r = n = 1; n <= e; n++)for (i = 0; i < t[n]; i++, ++o)for (a = 0; a < 1 << e - n; a++)r <= 1 << e && (s[r++] = n << 8 | t[o]); return s }, t.decode._decodeNewJPEG = function (e, n, r, i, a, s) { var o = e.t347, c = o ? o.length : 0, l = new Uint8Array(c + i); if (o) { for (var f = 0, d = 0; d < c - 1 && (255 != o[d] || 217 != o[d + 1]); d++)l[f++] = o[d]; var u = n[r], h = n[r + 1]; 255 == u && 216 == h || (l[f++] = u, l[f++] = h); for (d = 2; d < i; d++)l[f++] = n[r + d] } else for (d = 0; d < i; d++)l[d] = n[r + d]; if (32803 == e.t262[0] || 34892 == e.t262[0]) { var p = e.t258[0], g = t.LosslessJpegDecode(l), m = g.length; if (16 == p) if (e.isLE) for (d = 0; d < m; d++)a[s + (d << 1)] = 255 & g[d], a[s + (d << 1) + 1] = g[d] >>> 8; else for (d = 0; d < m; d++)a[s + (d << 1)] = g[d] >>> 8, a[s + (d << 1) + 1] = 255 & g[d]; else { if (14 != p && 12 != p) throw new Error("unsupported bit depth " + p); var b = 16 - p; for (d = 0; d < m; d++)t.decode._putsF(a, d * p, g[d] << b) } } else { var w = new t.JpegDecoder; w.parse(l); var y = w.getData(w.width, w.height); for (d = 0; d < y.length; d++)a[s + d] = y[d] } 6 == e.t262[0] && (e.t262[0] = 2) }, t.decode._decodeOldJPEGInit = function (t, e, n, r) { var a, s, o, c, l, f = 216, d = 0, u = 0, h = !1, p = t.t513, g = p ? p[0] : 0, m = t.t514, b = m ? m[0] : 0, w = t.t324 || t.t273 || p, y = t.t530, v = 0, _ = 0, x = t.t277 ? t.t277[0] : 1, k = t.t515; if (w && (u = w[0], h = w.length > 1), !h) { if (255 == e[n] && e[n + 1] == f) return { jpegOffset: n }; if (null != p && (255 == e[n + g] && e[n + g + 1] == f ? d = n + g : i("JPEGInterchangeFormat does not point to SOI"), null == m ? i("JPEGInterchangeFormatLength field is missing") : (g >= u || g + b <= u) && i("JPEGInterchangeFormatLength field value is invalid"), null != d)) return { jpegOffset: d } } if (null != y && (v = y[0], _ = y[1]), null != p && null != m) if (b >= 2 && g + b <= u) { for (a = 255 == e[n + g + b - 2] && e[n + g + b - 1] == f ? new Uint8Array(b - 2) : new Uint8Array(b), o = 0; o < a.length; o++)a[o] = e[n + g + o]; i("Incorrect JPEG interchange format: using JPEGInterchangeFormat offset to derive tables") } else i("JPEGInterchangeFormat+JPEGInterchangeFormatLength > offset to first strip or tile"); if (null == a) { var E = 0, A = []; A[E++] = 255, A[E++] = f; var S = t.t519; if (null == S) throw new Error("JPEGQTables tag is missing"); for (o = 0; o < S.length; o++)for (A[E++] = 255, A[E++] = 219, A[E++] = 0, A[E++] = 67, A[E++] = o, c = 0; c < 64; c++)A[E++] = e[n + S[o] + c]; for (l = 0; l < 2; l++) { var B = t[0 == l ? "t520" : "t521"]; if (null == B) throw new Error((0 == l ? "JPEGDCTables" : "JPEGACTables") + " tag is missing"); for (o = 0; o < B.length; o++) { A[E++] = 255, A[E++] = 196; var z = 19; for (c = 0; c < 16; c++)z += e[n + B[o] + c]; for (A[E++] = z >>> 8, A[E++] = 255 & z, A[E++] = o | l << 4, c = 0; c < 16; c++)A[E++] = e[n + B[o] + c]; for (c = 0; c < z; c++)A[E++] = e[n + B[o] + 16 + c] } } if (A[E++] = 255, A[E++] = 192, A[E++] = 0, A[E++] = 8 + 3 * x, A[E++] = 8, A[E++] = t.height >>> 8 & 255, A[E++] = 255 & t.height, A[E++] = t.width >>> 8 & 255, A[E++] = 255 & t.width, A[E++] = x, 1 == x) A[E++] = 1, A[E++] = 17, A[E++] = 0; else for (o = 0; o < 3; o++)A[E++] = o + 1, A[E++] = 0 != o ? 17 : (15 & v) << 4 | 15 & _, A[E++] = o; null != k && 0 != k[0] && (A[E++] = 255, A[E++] = 221, A[E++] = 0, A[E++] = 4, A[E++] = k[0] >>> 8 & 255, A[E++] = 255 & k[0]), a = new Uint8Array(A) } var C = -1; for (o = 0; o < a.length - 1;) { if (255 == a[o] && 192 == a[o + 1]) { C = o; break } o++ } if (-1 == C) { var U = new Uint8Array(a.length + 10 + 3 * x); U.set(a); var I = a.length; if (C = a.length, (a = U)[I++] = 255, a[I++] = 192, a[I++] = 0, a[I++] = 8 + 3 * x, a[I++] = 8, a[I++] = t.height >>> 8 & 255, a[I++] = 255 & t.height, a[I++] = t.width >>> 8 & 255, a[I++] = 255 & t.width, a[I++] = x, 1 == x) a[I++] = 1, a[I++] = 17, a[I++] = 0; else for (o = 0; o < 3; o++)a[I++] = o + 1, a[I++] = 0 != o ? 17 : (15 & v) << 4 | 15 & _, a[I++] = o } if (255 == e[u] && 218 == e[u + 1]) { var T = e[u + 2] << 8 | e[u + 3]; for ((s = new Uint8Array(T + 2))[0] = e[u], s[1] = e[u + 1], s[2] = e[u + 2], s[3] = e[u + 3], o = 0; o < T - 2; o++)s[o + 4] = e[u + o + 4] } else { var N = 0; if ((s = new Uint8Array(8 + 2 * x))[N++] = 255, s[N++] = 218, s[N++] = 0, s[N++] = 6 + 2 * x, s[N++] = x, 1 == x) s[N++] = 1, s[N++] = 0; else for (o = 0; o < 3; o++)s[N++] = o + 1, s[N++] = o << 4 | o; s[N++] = 0, s[N++] = 63, s[N++] = 0 } return { jpegOffset: n, tables: a, sosMarker: s, sofPosition: C } }, t.decode._decodeOldJPEG = function (e, n, r, i, a, s) { var o, c, l, f, d = t.decode._decodeOldJPEGInit(e, n, r, i); if (null != d.jpegOffset) for (o = r + i - d.jpegOffset, l = new Uint8Array(o), p = 0; p < o; p++)l[p] = n[d.jpegOffset + p]; else { for (c = d.tables.length, (l = new Uint8Array(c + d.sosMarker.length + i + 2)).set(d.tables), f = c, l[d.sofPosition + 5] = e.height >>> 8 & 255, l[d.sofPosition + 6] = 255 & e.height, l[d.sofPosition + 7] = e.width >>> 8 & 255, l[d.sofPosition + 8] = 255 & e.width, 255 == n[r] && n[r + 1] == SOS || (l.set(d.sosMarker, f), f += sosMarker.length), p = 0; p < i; p++)l[f++] = n[r + p]; l[f++] = 255, l[f++] = EOI } var u = new t.JpegDecoder; u.parse(l); for (var h = u.getData(u.width, u.height), p = 0; p < h.length; p++)a[s + p] = h[p]; e.t262 && 6 == e.t262[0] && (e.t262[0] = 2) }, t.decode._decodePackBits = function (t, e, n, r, i) { for (var a = new Int8Array(t.buffer), s = new Int8Array(r.buffer), o = e + n; e < o;) { var c = a[e]; if (e++, c >= 0 && c < 128) for (var l = 0; l < c + 1; l++)s[i] = a[e], i++, e++; if (c >= -127 && c < 0) { for (l = 0; l < 1 - c; l++)s[i] = a[e], i++; e++ } } }, t.decode._decodeThunder = function (t, e, n, r, i) { for (var a = [0, 1, 0, -1], s = [0, 1, 2, 3, 0, -3, -2, -1], o = e + n, c = 2 * i, l = 0; e < o;) { var f = t[e], d = f >>> 6, u = 63 & f; if (e++, 3 == d && (l = 15 & u, r[c >>> 1] |= l << 4 * (1 - c & 1), c++), 0 == d) for (var h = 0; h < u; h++)r[c >>> 1] |= l << 4 * (1 - c & 1), c++; if (2 == d) for (h = 0; h < 2; h++) { 4 != (p = u >>> 3 * (1 - h) & 7) && (l += s[p], r[c >>> 1] |= l << 4 * (1 - c & 1), c++) } if (1 == d) for (h = 0; h < 3; h++) { var p; 2 != (p = u >>> 2 * (2 - h) & 3) && (l += a[p], r[c >>> 1] |= l << 4 * (1 - c & 1), c++) } } }, t.decode._dmap = { 1: 0, "011": 1, "000011": 2, "0000011": 3, "010": -1, "000010": -2, "0000010": -3 }, t.decode._lens = function () { var t = function (t, e, n, r) { for (var i = 0; i < e.length; i++)t[e[i]] = n + i * r }, e = "00110101,000111,0111,1000,1011,1100,1110,1111,10011,10100,00111,01000,001000,000011,110100,110101,101010,101011,0100111,0001100,0001000,0010111,0000011,0000100,0101000,0101011,0010011,0100100,0011000,00000010,00000011,00011010,00011011,00010010,00010011,00010100,00010101,00010110,00010111,00101000,00101001,00101010,00101011,00101100,00101101,00000100,00000101,00001010,00001011,01010010,01010011,01010100,01010101,00100100,00100101,01011000,01011001,01011010,01011011,01001010,01001011,00110010,00110011,00110100", n = "0000110111,010,11,10,011,0011,0010,00011,000101,000100,0000100,0000101,0000111,00000100,00000111,000011000,0000010111,0000011000,0000001000,00001100111,00001101000,00001101100,00000110111,00000101000,00000010111,00000011000,000011001010,000011001011,000011001100,000011001101,000001101000,000001101001,000001101010,000001101011,000011010010,000011010011,000011010100,000011010101,000011010110,000011010111,000001101100,000001101101,000011011010,000011011011,000001010100,000001010101,000001010110,000001010111,000001100100,000001100101,000001010010,000001010011,000000100100,000000110111,000000111000,000000100111,000000101000,000001011000,000001011001,000000101011,000000101100,000001011010,000001100110,000001100111", r = "11011,10010,010111,0110111,00110110,00110111,01100100,01100101,01101000,01100111,011001100,011001101,011010010,011010011,011010100,011010101,011010110,011010111,011011000,011011001,011011010,011011011,010011000,010011001,010011010,011000,010011011", i = "0000001111,000011001000,000011001001,000001011011,000000110011,000000110100,000000110101,0000001101100,0000001101101,0000001001010,0000001001011,0000001001100,0000001001101,0000001110010,0000001110011,0000001110100,0000001110101,0000001110110,0000001110111,0000001010010,0000001010011,0000001010100,0000001010101,0000001011010,0000001011011,0000001100100,0000001100101", a = "00000001000,00000001100,00000001101,000000010010,000000010011,000000010100,000000010101,000000010110,000000010111,000000011100,000000011101,000000011110,000000011111"; e = e.split(","), n = n.split(","), r = r.split(","), i = i.split(","), a = a.split(","); var s = {}, o = {}; return t(s, e, 0, 1), t(s, r, 64, 64), t(s, a, 1792, 64), t(o, n, 0, 1), t(o, i, 64, 64), t(o, a, 1792, 64), [s, o] }(), t.decode._decodeG4 = function (e, n, r, i, a, s, o) { for (var c = t.decode, l = n << 3, f = 0, d = "", u = [], h = [], p = 0; p < s; p++)h.push(0); h = c._makeDiff(h); for (var g = 0, m = 0, b = 0, w = 0, y = 0, v = 0, _ = "", x = 0, k = 8 * Math.ceil(s / 8); l >>> 3 < n + r;) { b = c._findDiff(h, g + (0 == g ? 0 : 1), 1 - y), w = c._findDiff(h, b, y); var E = 0; if (1 == o && (E = e[l >>> 3] >>> 7 - (7 & l) & 1), 2 == o && (E = e[l >>> 3] >>> (7 & l) & 1), l++, d += E, "H" == _) { if (null != c._lens[y][d]) { var A = c._lens[y][d]; d = "", f += A, A < 64 && (c._addNtimes(u, f, y), g += f, y = 1 - y, f = 0, 0 == --x && (_ = "")) } } else "0001" == d && (d = "", c._addNtimes(u, w - g, y), g = w), "001" == d && (d = "", _ = "H", x = 2), null != c._dmap[d] && (m = b + c._dmap[d], c._addNtimes(u, m - g, y), g = m, d = "", y = 1 - y); u.length == s && "" == _ && (c._writeBits(u, i, 8 * a + v * k), y = 0, v++, g = 0, h = c._makeDiff(u), u = []) } }, t.decode._findDiff = function (t, e, n) { for (var r = 0; r < t.length; r += 2)if (t[r] >= e && t[r + 1] == n) return t[r] }, t.decode._makeDiff = function (t) { var e = []; 1 == t[0] && e.push(0, 1); for (var n = 1; n < t.length; n++)t[n - 1] != t[n] && e.push(n, t[n]); return e.push(t.length, 0, t.length, 1), e }, t.decode._decodeG3 = function (e, n, r, i, a, s, o) { for (var c = t.decode, l = n << 3, f = 0, d = "", u = [], h = [], p = 0; p < s; p++)u.push(0); for (var g = 0, m = 0, b = 0, w = 0, y = 0, v = -1, _ = "", x = 0, k = !1, E = 8 * Math.ceil(s / 8); l >>> 3 < n + r;) { b = c._findDiff(h, g + (0 == g ? 0 : 1), 1 - y), w = c._findDiff(h, b, y); var A = 0; if (1 == o && (A = e[l >>> 3] >>> 7 - (7 & l) & 1), 2 == o && (A = e[l >>> 3] >>> (7 & l) & 1), l++, d += A, k) { if (null != c._lens[y][d]) { var S = c._lens[y][d]; d = "", f += S, S < 64 && (c._addNtimes(u, f, y), y = 1 - y, f = 0) } } else if ("H" == _) { if (null != c._lens[y][d]) { S = c._lens[y][d]; d = "", f += S, S < 64 && (c._addNtimes(u, f, y), g += f, y = 1 - y, f = 0, 0 == --x && (_ = "")) } } else "0001" == d && (d = "", c._addNtimes(u, w - g, y), g = w), "001" == d && (d = "", _ = "H", x = 2), null != c._dmap[d] && (m = b + c._dmap[d], c._addNtimes(u, m - g, y), g = m, d = "", y = 1 - y); d.endsWith("000000000001") && (v >= 0 && c._writeBits(u, i, 8 * a + v * E), 1 == o && (k = 1 == (e[l >>> 3] >>> 7 - (7 & l) & 1)), 2 == o && (k = 1 == (e[l >>> 3] >>> (7 & l) & 1)), l++, null == c._decodeG3.allow2D && (c._decodeG3.allow2D = k), c._decodeG3.allow2D || (k = !0, l--), d = "", y = 0, v++, g = 0, h = c._makeDiff(u), u = []) } u.length == s && c._writeBits(u, i, 8 * a + v * E) }, t.decode._addNtimes = function (t, e, n) { for (var r = 0; r < e; r++)t.push(n) }, t.decode._writeBits = function (t, e, n) { for (var r = 0; r < t.length; r++)e[n + r >>> 3] |= t[r] << 7 - (n + r & 7) }, t.decode._decodeLZW = function (e, n, r, i) { if (null == t.decode._lzwTab) { for (var a = new Uint32Array(65535), s = new Uint16Array(65535), o = new Uint8Array(2e6), c = 0; c < 256; c++)o[c << 2] = c, a[c] = c << 2, s[c] = 1; t.decode._lzwTab = [a, s, o] } for (var l = t.decode._copyData, f = t.decode._lzwTab[0], d = t.decode._lzwTab[1], u = (o = t.decode._lzwTab[2], 258), h = 1032, p = 9, g = n << 3, m = 0, b = 0; m = (e[g >>> 3] << 16 | e[g + 8 >>> 3] << 8 | e[g + 16 >>> 3]) >> 24 - (7 & g) - p & (1 << p) - 1, g += p, 257 != m;) { if (256 == m) { if (p = 9, u = 258, h = 1032, m = (e[g >>> 3] << 16 | e[g + 8 >>> 3] << 8 | e[g + 16 >>> 3]) >> 24 - (7 & g) - p & (1 << p) - 1, g += p, 257 == m) break; r[i] = m, i++ } else if (m < u) { var w = f[m], y = d[m]; if (l(o, w, r, i, y), i += y, b >= u) f[u] = h, o[f[u]] = w[0], d[u] = 1, h = h + 1 + 3 & -4, u++; else f[u] = h, l(o, f[b], o, h, v = d[b]), o[h + v] = o[w], v++, d[u] = v, u++, h = h + v + 3 & -4; u + 1 == 1 << p && p++ } else { var v; if (b >= u) f[u] = h, d[u] = 0, u++; else f[u] = h, l(o, f[b], o, h, v = d[b]), o[h + v] = o[h], v++, d[u] = v, u++, l(o, h, r, i, v), i += v, h = h + v + 3 & -4; u + 1 == 1 << p && p++ } b = m } }, t.decode._copyData = function (t, e, n, r, i) { for (var a = 0; a < i; a += 4)n[r + a] = t[e + a], n[r + a + 1] = t[e + a + 1], n[r + a + 2] = t[e + a + 2], n[r + a + 3] = t[e + a + 3] }, t.tags = {}, t.ttypes = { 256: 3, 257: 3, 258: 3, 259: 3, 262: 3, 273: 4, 274: 3, 277: 3, 278: 4, 279: 4, 282: 5, 283: 5, 284: 3, 286: 5, 287: 5, 296: 3, 305: 2, 306: 2, 338: 3, 513: 4, 514: 4, 34665: 4 }, t._readIFD = function (e, n, r, a, s, o) { var c = e.readUshort(n, r); r += 2; var l = {}; a.push(l), o && i("   ".repeat(s), a.length - 1, ">>>----------------"); for (var f = 0; f < c; f++) { var d = e.readUshort(n, r); r += 2; var u = e.readUshort(n, r); r += 2; var h = e.readUint(n, r); r += 4; var p = e.readUint(n, r); r += 4; var g = []; if (1 != u && 7 != u || (g = new Uint8Array(n.buffer, h < 5 ? r - 4 : p, h)), 2 == u) { var m = h < 5 ? r - 4 : p; n[m] < 128 ? g.push(e.readASCII(n, m, h - 1)) : g = new Uint8Array(n.buffer, m, h - 1) } if (3 == u) for (var b = 0; b < h; b++)g.push(e.readUshort(n, (h < 3 ? r - 4 : p) + 2 * b)); if (4 == u) for (b = 0; b < h; b++)g.push(e.readUint(n, (h < 2 ? r - 4 : p) + 4 * b)); if (5 == u) for (b = 0; b < h; b++)g.push(e.readUint(n, p + 8 * b) / e.readUint(n, p + 8 * b + 4)); if (8 == u) for (b = 0; b < h; b++)g.push(e.readShort(n, (h < 3 ? r - 4 : p) + 2 * b)); if (9 == u) for (b = 0; b < h; b++)g.push(e.readInt(n, (h < 2 ? r - 4 : p) + 4 * b)); if (10 == u) for (b = 0; b < h; b++)g.push(e.readInt(n, p + 8 * b) / e.readInt(n, p + 8 * b + 4)); if (11 == u) for (b = 0; b < h; b++)g.push(e.readFloat(n, p + 4 * b)); if (12 == u) for (b = 0; b < h; b++)g.push(e.readDouble(n, p + 8 * b)); if (l["t" + d] = g, 0 != h && 0 == g.length && i("unknown TIFF tag type: ", u, "num:", h), o && i("   ".repeat(s), d, u, t.tags[d], g), 330 == d && l.t272 && "DSLR-A100" == l.t272[0]); else if (330 == d || 34665 == d || 50740 == d && e.readUshort(n, e.readUint(g, 0)) < 300) { var w = 50740 == d ? [e.readUint(g, 0)] : g, y = []; for (b = 0; b < w.length; b++)t._readIFD(e, n, w[b], y, s + 1, o); 330 == d && (l.subIFD = y), 34665 == d && (l.exifIFD = y[0]), 50740 == d && (l.dngPrvt = y[0]) } if (37500 == d) { var v = g; if ("Nikon" == e.readASCII(v, 0, 5)) l.makerNote = t.decode(v.slice(10).buffer)[0]; else if (e.readUshort(n, p) < 300) { var _ = []; t._readIFD(e, n, p, _, s + 1, o), l.makerNote = _[0] } } } return o && i("   ".repeat(s), "<<<---------------"), r }, t._writeIFD = function (e, n, r, i) { var a = Object.keys(i); e.writeUshort(n, r, a.length); for (var s = (r += 2) + 12 * a.length + 4, o = 0; o < a.length; o++) { var c = a[o], l = parseInt(c.slice(1)), f = t.ttypes[l]; if (null == f) throw new Error("unknown type of tag: " + l); var d = i[c]; 2 == f && (d = d[0] + "\0"); var u = d.length; e.writeUshort(n, r, l), r += 2, e.writeUshort(n, r, f), r += 2, e.writeUint(n, r, u); var h = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][f] * u, p = r += 4; if (h > 4 && (e.writeUint(n, r, s), p = s), 2 == f && e.writeASCII(n, p, d), 3 == f) for (var g = 0; g < u; g++)e.writeUshort(n, p + 2 * g, d[g]); if (4 == f) for (g = 0; g < u; g++)e.writeUint(n, p + 4 * g, d[g]); if (5 == f) for (g = 0; g < u; g++)e.writeUint(n, p + 8 * g, Math.round(1e4 * d[g])), e.writeUint(n, p + 8 * g + 4, 1e4); if (12 == f) for (g = 0; g < u; g++)e.writeDouble(n, p + 8 * g, d[g]); h > 4 && (s += h += 1 & h), r += 4 } return [r, s] }, t.toRGBA8 = function (t) { var e = t.width, n = t.height, r = e * n, a = 4 * r, s = t.data, o = new Uint8Array(4 * r), c = t.t262 ? t.t262[0] : 2, l = t.t258 ? Math.min(32, t.t258[0]) : 1; if (0 == c) for (var f = Math.ceil(l * e / 8), d = 0; d < n; d++) { var u = d * f, h = d * e; if (1 == l) for (var p = 0; p < e; p++) { var g = h + p << 2, m = s[u + (p >> 3)] >> 7 - (7 & p) & 1; o[g] = o[g + 1] = o[g + 2] = 255 * (1 - m), o[g + 3] = 255 } if (4 == l) for (p = 0; p < e; p++) { g = h + p << 2, m = s[u + (p >> 1)] >> 4 - 4 * (1 & p) & 15; o[g] = o[g + 1] = o[g + 2] = 17 * (15 - m), o[g + 3] = 255 } if (8 == l) for (p = 0; p < e; p++) { g = h + p << 2, m = s[u + p]; o[g] = o[g + 1] = o[g + 2] = 255 - m, o[g + 3] = 255 } } else if (1 == c) for (f = Math.ceil(l * e / 8), d = 0; d < n; d++) { u = d * f, h = d * e; if (1 == l) for (p = 0; p < e; p++) { g = h + p << 2, m = s[u + (p >> 3)] >> 7 - (7 & p) & 1; o[g] = o[g + 1] = o[g + 2] = 255 * m, o[g + 3] = 255 } if (2 == l) for (p = 0; p < e; p++) { g = h + p << 2, m = s[u + (p >> 2)] >> 6 - 2 * (3 & p) & 3; o[g] = o[g + 1] = o[g + 2] = 85 * m, o[g + 3] = 255 } if (8 == l) for (p = 0; p < e; p++) { g = h + p << 2, m = s[u + p]; o[g] = o[g + 1] = o[g + 2] = m, o[g + 3] = 255 } if (16 == l) for (p = 0; p < e; p++) { g = h + p << 2, m = s[u + (2 * p + 1)]; o[g] = o[g + 1] = o[g + 2] = Math.min(255, m), o[g + 3] = 255 } } else if (2 == c) { var b = t.t258 ? t.t258.length : 3; if (8 == l) { if (4 == b) for (p = 0; p < a; p++)o[p] = s[p]; if (3 == b) for (p = 0; p < r; p++) { var w = 3 * p; o[g = p << 2] = s[w], o[g + 1] = s[w + 1], o[g + 2] = s[w + 2], o[g + 3] = 255 } } else { if (4 == b) for (p = 0; p < r; p++) { w = 8 * p + 1; o[g = p << 2] = s[w], o[g + 1] = s[w + 2], o[g + 2] = s[w + 4], o[g + 3] = s[w + 6] } if (3 == b) for (p = 0; p < r; p++) { w = 6 * p + 1; o[g = p << 2] = s[w], o[g + 1] = s[w + 2], o[g + 2] = s[w + 4], o[g + 3] = 255 } } } else if (3 == c) { var y = t.t320; for (p = 0; p < r; p++) { g = p << 2; var v = s[p]; o[g] = y[v] >> 8, o[g + 1] = y[256 + v] >> 8, o[g + 2] = y[512 + v] >> 8, o[g + 3] = 255 } } else if (5 == c) { var _ = (b = t.t258 ? t.t258.length : 4) > 4 ? 1 : 0; for (p = 0; p < r; p++) { g = p << 2; var x = p * b, k = 255 - s[x], E = 255 - s[x + 1], A = 255 - s[x + 2], S = (255 - s[x + 3]) * (1 / 255); o[g] = ~~(k * S + .5), o[g + 1] = ~~(E * S + .5), o[g + 2] = ~~(A * S + .5), o[g + 3] = 255 * (1 - _) + s[x + 4] * _ } } else i("Unknown Photometric interpretation: " + c); return o }, t.replaceIMG = function (e) { null == e && (e = document.getElementsByTagName("img")); for (var n = ["tif", "tiff", "dng", "cr2", "nef"], r = 0; r < e.length; r++) { var i = e[r], a = i.getAttribute("src"); if (null != a) { var s = a.split(".").pop().toLowerCase(); if (-1 != n.indexOf(s)) { var o = new XMLHttpRequest; t._xhrs.push(o), t._imgs.push(i), o.open("GET", a), o.responseType = "arraybuffer", o.onload = t._imgLoaded, o.send() } } } }, t._xhrs = [], t._imgs = [], t._imgLoaded = function (e) { var n = e.target.response, r = t.decode(n), i = r, a = 0, s = i[0]; r[0].subIFD && (i = i.concat(r[0].subIFD)); for (var o = 0; o < i.length; o++) { if (!(null == (h = i[o]).t258 || h.t258.length < 3)) { var c = h.t256 * h.t257; c > a && (a = c, s = h) } } t.decodeImage(n, s, r); var l = t.toRGBA8(s), f = s.width, d = s.height, u = t._xhrs.indexOf(e.target), h = t._imgs[u]; t._xhrs.splice(u, 1), t._imgs.splice(u, 1); var p = document.createElement("canvas"); p.width = f, p.height = d; var g = p.getContext("2d"), m = g.createImageData(f, d); for (o = 0; o < l.length; o++)m.data[o] = l[o]; g.putImageData(m, 0, 0), h.setAttribute("src", p.toDataURL()) }, t._binBE = { nextZero: function (t, e) { for (; 0 != t[e];)e++; return e }, readUshort: function (t, e) { return t[e] << 8 | t[e + 1] }, readShort: function (e, n) { var r = t._binBE.ui8; return r[0] = e[n + 1], r[1] = e[n + 0], t._binBE.i16[0] }, readInt: function (e, n) { var r = t._binBE.ui8; return r[0] = e[n + 3], r[1] = e[n + 2], r[2] = e[n + 1], r[3] = e[n + 0], t._binBE.i32[0] }, readUint: function (e, n) { var r = t._binBE.ui8; return r[0] = e[n + 3], r[1] = e[n + 2], r[2] = e[n + 1], r[3] = e[n + 0], t._binBE.ui32[0] }, readASCII: function (t, e, n) { for (var r = "", i = 0; i < n; i++)r += String.fromCharCode(t[e + i]); return r }, readFloat: function (e, n) { for (var r = t._binBE.ui8, i = 0; i < 4; i++)r[i] = e[n + 3 - i]; return t._binBE.fl32[0] }, readDouble: function (e, n) { for (var r = t._binBE.ui8, i = 0; i < 8; i++)r[i] = e[n + 7 - i]; return t._binBE.fl64[0] }, writeUshort: function (t, e, n) { t[e] = n >> 8 & 255, t[e + 1] = 255 & n }, writeUint: function (t, e, n) { t[e] = n >> 24 & 255, t[e + 1] = n >> 16 & 255, t[e + 2] = n >> 8 & 255, t[e + 3] = n >> 0 & 255 }, writeASCII: function (t, e, n) { for (var r = 0; r < n.length; r++)t[e + r] = n.charCodeAt(r) }, writeDouble: function (e, n, r) { t._binBE.fl64[0] = r; for (var i = 0; i < 8; i++)e[n + i] = t._binBE.ui8[7 - i] } }, t._binBE.ui8 = new Uint8Array(8), t._binBE.i16 = new Int16Array(t._binBE.ui8.buffer), t._binBE.i32 = new Int32Array(t._binBE.ui8.buffer), t._binBE.ui32 = new Uint32Array(t._binBE.ui8.buffer), t._binBE.fl32 = new Float32Array(t._binBE.ui8.buffer), t._binBE.fl64 = new Float64Array(t._binBE.ui8.buffer), t._binLE = { nextZero: t._binBE.nextZero, readUshort: function (t, e) { return t[e + 1] << 8 | t[e] }, readShort: function (e, n) { var r = t._binBE.ui8; return r[0] = e[n + 0], r[1] = e[n + 1], t._binBE.i16[0] }, readInt: function (e, n) { var r = t._binBE.ui8; return r[0] = e[n + 0], r[1] = e[n + 1], r[2] = e[n + 2], r[3] = e[n + 3], t._binBE.i32[0] }, readUint: function (e, n) { var r = t._binBE.ui8; return r[0] = e[n + 0], r[1] = e[n + 1], r[2] = e[n + 2], r[3] = e[n + 3], t._binBE.ui32[0] }, readASCII: t._binBE.readASCII, readFloat: function (e, n) { for (var r = t._binBE.ui8, i = 0; i < 4; i++)r[i] = e[n + i]; return t._binBE.fl32[0] }, readDouble: function (e, n) { for (var r = t._binBE.ui8, i = 0; i < 8; i++)r[i] = e[n + i]; return t._binBE.fl64[0] } }, t._copyTile = function (t, e, n, r, i, a, s, o) { for (var c = Math.min(e, i - s), l = Math.min(n, a - o), f = 0; f < l; f++)for (var d = (o + f) * i + s, u = f * e, h = 0; h < c; h++)r[d + h] = t[u + h] }, t.LosslessJpegDecode = function () { function t(t) { this.w = t, this.N = 0, this._ = 0, this.G = 0 } t.prototype = { t: function (t) { this.N = Math.max(0, Math.min(this.w.length, t)) }, i: function () { return this.w[this.N++] }, l: function () { var t = this.N; return this.N += 2, this.w[t] << 8 | this.w[t + 1] }, J: function () { return 0 == this._ && (this.G = this.w[this.N], this.N += 1 + (this.G + 1 >>> 8), this._ = 8), this.G >>> --this._ & 1 }, Z: function (t) { var e = this._, n = this.G, r = Math.min(e, t); t -= r; for (var i = n >>> (e -= r) & (1 << r) - 1; t > 0;)n = this.w[this.N], this.N += 1 + (n + 1 >>> 8), t -= r = Math.min(8, t), i <<= r, i |= n >>> (e = 8 - r) & (1 << r) - 1; return this._ = e, this.G = n, i } }; var e = {}; function n(e) { this.z = new t(e), this.D(this.z) } return e.X = function () { return [0, 0, -1] }, e.s = function (t, n, r) { t[e.Y(t, 0, r) + 2] = n }, e.Y = function (t, n, r) { if (-1 != t[n + 2]) return 0; if (0 == r) return n; for (var i = 0; i < 2; i++) { 0 == t[n + i] && (t[n + i] = t.length, t.push(0), t.push(0), t.push(-1)); var a = e.Y(t, t[n + i], r - 1); if (0 != a) return a } return 0 }, e.B = function (t, e) { for (var n = 0, r = 0, i = e._, a = e.G, s = e.N; ;)if (0 == i && (s += 1 + ((a = e.w[s]) + 1 >>> 8), i = 8), -1 != (r = t[(n = t[n + (a >>> --i & 1)]) + 2])) return e._ = i, e.G = a, e.N = s, r; return -1 }, n.prototype = { $: function (t, e) { this.Q = t.i(), this.F = t.l(), this.o = t.l(); var n = this.O = t.i(); this.L = []; for (var r = 0; r < n; r++) { var i = t.i(); t.i(); t.i(), this.L[i] = r } t.t(t.N + e - (6 + 3 * n)) }, e: function () { var t = 0, n = this.z.i(); null == this.H && (this.H = {}); for (var r = this.H[n] = e.X(), i = [], a = 0; a < 16; a++)i[a] = this.z.i(), t += i[a]; for (a = 0; a < 16; a++)for (var s = 0; s < i[a]; s++)e.s(r, this.z.i(), a + 1); return t + 17 }, W: function (t) { for (; t > 0;)t -= this.e() }, p: function (t, e) { var n = t.i(); this.U || (this.U = []); for (var r = 0; r < n; r++) { var i = t.i(), a = t.i(); this.U[this.L[i]] = this.H[a >>> 4] } this.g = t.i(), t.t(t.N + e - (2 + 2 * n)) }, D: function (t) { var e = !1; if ((r = t.l()) === n.q) do { var r = t.l(), i = t.l() - 2; switch (r) { case n.m: this.$(t, i); break; case n.K: this.W(i); break; case n.V: this.p(t, i), e = !0; break; default: t.t(t.N + i) } } while (!e) }, I: function (t, n) { var r = e.B(n, t); if (16 == r) return -32768; var i = t.Z(r); return 0 == (i & 1 << r - 1) && (i -= (1 << r) - 1), i }, B: function (t, e) { for (var n = this.z, r = this.O, i = this.F, a = this.I, s = this.g, o = this.o * r, c = this.U, l = 0; l < r; l++)t[l] = a(n, c[l]) + (1 << this.Q - 1); for (var f = r; f < o; f += r)for (l = 0; l < r; l++)t[f + l] = a(n, c[l]) + t[f + l - r]; for (var d = e, u = 1; u < i; u++) { for (l = 0; l < r; l++)t[d + l] = a(n, c[l]) + t[d + l - e]; for (f = r; f < o; f += r)for (l = 0; l < r; l++) { var h = d + f + l, p = t[h - r]; 6 == s && (p = t[h - e] + (p - t[h - r - e] >>> 1)), t[h] = p + a(n, c[l]) } d += e } } }, n.m = 65475, n.K = 65476, n.q = 65496, n.V = 65498, function (t) { var e = new n(t), r = new (e.Q > 8 ? Uint16Array : Uint8Array)(e.o * e.F * e.O), i = e.o * e.O; return e.B(r, i), r } }() }(e, n(32845)) }() }, 74783: function (t, e, n) { "use strict"; var r = n(25618), i = Object.create(null), a = "undefined" == typeof document, s = Array.prototype.forEach; function o() { } function c(t, e) { if (!e) { if (!t.href) return; e = t.href.split("?")[0] } if (d(e) && !1 !== t.isLoaded && e && e.indexOf(".css") > -1) { t.visited = !0; var n = t.cloneNode(); n.isLoaded = !1, n.addEventListener("load", (function () { n.isLoaded || (n.isLoaded = !0, t.parentNode.removeChild(t)) })), n.addEventListener("error", (function () { n.isLoaded || (n.isLoaded = !0, t.parentNode.removeChild(t)) })), n.href = "".concat(e, "?").concat(Date.now()), t.nextSibling ? t.parentNode.insertBefore(n, t.nextSibling) : t.parentNode.appendChild(n) } } function l(t) { if (!t) return !1; var e = document.querySelectorAll("link"), n = !1; return s.call(e, (function (e) { if (e.href) { var i = function (t, e) { var n; return t = r(t), e.some((function (r) { t.indexOf(e) > -1 && (n = r) })), n }(e.href, t); d(i) && !0 !== e.visited && i && (c(e, i), n = !0) } })), n } function f() { var t = document.querySelectorAll("link"); s.call(t, (function (t) { !0 !== t.visited && c(t) })) } function d(t) { return !!/^[a-zA-Z][a-zA-Z\d+\-.]*:/.test(t) } t.exports = function (t, e) { if (a) return console.log("no window.document found, will not HMR CSS"), o; var n, s, c, d = function (t) { var e = i[t]; if (!e) { if (document.currentScript) e = document.currentScript.src; else { var n = document.getElementsByTagName("script"), a = n[n.length - 1]; a && (e = a.src) } i[t] = e } return function (t) { if (!e) return null; var n = e.split(/([^\\/]+)\.js$/), i = n && n[1]; return i && t ? t.split(",").map((function (t) { var n = new RegExp("".concat(i, "\\.js$"), "g"); return r(e.replace(n, "".concat(t.replace(/{fileName}/g, i), ".css"))) })) : [e.replace(".js", ".css")] } }(t); return n = function () { var t = d(e.filename), n = l(t); if (e.locals) return console.log("[HMR] Detected local css modules. Reload all css"), void f(); n ? console.log("[HMR] css reload %s", t.join(" ")) : (console.log("[HMR] Reload all css"), f()) }, s = 50, c = 0, function () { var t = this, e = arguments; clearTimeout(c), c = setTimeout((function () { return n.apply(t, e) }), s) } } }, 25618: function (t) { "use strict"; t.exports = function (t) { if (t = t.trim(), /^data:/i.test(t)) return t; var e = -1 !== t.indexOf("//") ? t.split("//")[0] + "//" : "", n = t.replace(new RegExp(e, "i"), "").split("/"), r = n[0].toLowerCase().replace(/\.$/, ""); return n[0] = "", e + r + n.reduce((function (t, e) { switch (e) { case "..": t.pop(); break; case ".": break; default: t.push(e) }return t }), []).join("/") } }, 73148: function (t, e, n) { "use strict"; n.d(e, { Nt: function () { return Pe }, R: function () { return an }, pE: function () { return rn }, Ej: function () { return Oe }, I8: function () { return sn }, QV: function () { return De }, fs: function () { return jr } }); const r = 15, i = 256, a = 573, s = 256, o = -2, c = -5; function l(t) { return f(t.map((([t, e]) => new Array(t).fill(e, 0, t)))) } function f(t) { return t.reduce(((t, e) => t.concat(Array.isArray(e) ? f(e) : e)), []) } const d = [0, 1, 2, 3].concat(...l([[2, 4], [2, 5], [4, 6], [4, 7], [8, 8], [8, 9], [16, 10], [16, 11], [32, 12], [32, 13], [64, 14], [64, 15], [2, 0], [1, 16], [1, 17], [2, 18], [2, 19], [4, 20], [4, 21], [8, 22], [8, 23], [16, 24], [16, 25], [32, 26], [32, 27], [64, 28], [64, 29]])); function u() { const t = this; function e(t, e) { let n = 0; do { n |= 1 & t, t >>>= 1, n <<= 1 } while (--e > 0); return n >>> 1 } t.build_tree = function (n) { const i = t.dyn_tree, s = t.stat_desc.static_tree, o = t.stat_desc.elems; let c, l, f, d = -1; for (n.heap_len = 0, n.heap_max = a, c = 0; c < o; c++)0 !== i[2 * c] ? (n.heap[++n.heap_len] = d = c, n.depth[c] = 0) : i[2 * c + 1] = 0; for (; n.heap_len < 2;)f = n.heap[++n.heap_len] = d < 2 ? ++d : 0, i[2 * f] = 1, n.depth[f] = 0, n.opt_len--, s && (n.static_len -= s[2 * f + 1]); for (t.max_code = d, c = Math.floor(n.heap_len / 2); c >= 1; c--)n.pqdownheap(i, c); f = o; do { c = n.heap[1], n.heap[1] = n.heap[n.heap_len--], n.pqdownheap(i, 1), l = n.heap[1], n.heap[--n.heap_max] = c, n.heap[--n.heap_max] = l, i[2 * f] = i[2 * c] + i[2 * l], n.depth[f] = Math.max(n.depth[c], n.depth[l]) + 1, i[2 * c + 1] = i[2 * l + 1] = f, n.heap[1] = f++, n.pqdownheap(i, 1) } while (n.heap_len >= 2); n.heap[--n.heap_max] = n.heap[1], function (e) { const n = t.dyn_tree, i = t.stat_desc.static_tree, s = t.stat_desc.extra_bits, o = t.stat_desc.extra_base, c = t.stat_desc.max_length; let l, f, d, u, h, p, g = 0; for (u = 0; u <= r; u++)e.bl_count[u] = 0; for (n[2 * e.heap[e.heap_max] + 1] = 0, l = e.heap_max + 1; l < a; l++)f = e.heap[l], u = n[2 * n[2 * f + 1] + 1] + 1, u > c && (u = c, g++), n[2 * f + 1] = u, f > t.max_code || (e.bl_count[u]++, h = 0, f >= o && (h = s[f - o]), p = n[2 * f], e.opt_len += p * (u + h), i && (e.static_len += p * (i[2 * f + 1] + h))); if (0 !== g) { do { for (u = c - 1; 0 === e.bl_count[u];)u--; e.bl_count[u]--, e.bl_count[u + 1] += 2, e.bl_count[c]--, g -= 2 } while (g > 0); for (u = c; 0 !== u; u--)for (f = e.bl_count[u]; 0 !== f;)d = e.heap[--l], d > t.max_code || (n[2 * d + 1] != u && (e.opt_len += (u - n[2 * d + 1]) * n[2 * d], n[2 * d + 1] = u), f--) } }(n), function (t, n, i) { const a = []; let s, o, c, l = 0; for (s = 1; s <= r; s++)a[s] = l = l + i[s - 1] << 1; for (o = 0; o <= n; o++)c = t[2 * o + 1], 0 !== c && (t[2 * o] = e(a[c]++, c)) }(i, t.max_code, n.bl_count) } } function h(t, e, n, r, i) { const a = this; a.static_tree = t, a.extra_bits = e, a.extra_base = n, a.elems = r, a.max_length = i } u._length_code = [0, 1, 2, 3, 4, 5, 6, 7].concat(...l([[2, 8], [2, 9], [2, 10], [2, 11], [4, 12], [4, 13], [4, 14], [4, 15], [8, 16], [8, 17], [8, 18], [8, 19], [16, 20], [16, 21], [16, 22], [16, 23], [32, 24], [32, 25], [32, 26], [31, 27], [1, 28]])), u.base_length = [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0], u.base_dist = [0, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384, 24576], u.d_code = function (t) { return t < 256 ? d[t] : d[256 + (t >>> 7)] }, u.extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], u.extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], u.extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], u.bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]; const p = l([[144, 8], [112, 9], [24, 7], [8, 8]]); h.static_ltree = f([12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82, 210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161, 97, 225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 19, 275, 147, 403, 83, 339, 211, 467, 51, 307, 179, 435, 115, 371, 243, 499, 11, 267, 139, 395, 75, 331, 203, 459, 43, 299, 171, 427, 107, 363, 235, 491, 27, 283, 155, 411, 91, 347, 219, 475, 59, 315, 187, 443, 123, 379, 251, 507, 7, 263, 135, 391, 71, 327, 199, 455, 39, 295, 167, 423, 103, 359, 231, 487, 23, 279, 151, 407, 87, 343, 215, 471, 55, 311, 183, 439, 119, 375, 247, 503, 15, 271, 143, 399, 79, 335, 207, 463, 47, 303, 175, 431, 111, 367, 239, 495, 31, 287, 159, 415, 95, 351, 223, 479, 63, 319, 191, 447, 127, 383, 255, 511, 0, 64, 32, 96, 16, 80, 48, 112, 8, 72, 40, 104, 24, 88, 56, 120, 4, 68, 36, 100, 20, 84, 52, 116, 3, 131, 67, 195, 35, 163, 99, 227].map(((t, e) => [t, p[e]]))); const g = l([[30, 5]]); h.static_dtree = f([0, 16, 8, 24, 4, 20, 12, 28, 2, 18, 10, 26, 6, 22, 14, 30, 1, 17, 9, 25, 5, 21, 13, 29, 3, 19, 11, 27, 7, 23].map(((t, e) => [t, g[e]]))), h.static_l_desc = new h(h.static_ltree, u.extra_lbits, 257, 286, r), h.static_d_desc = new h(h.static_dtree, u.extra_dbits, 0, 30, r), h.static_bl_desc = new h(null, u.extra_blbits, 0, 19, 7); function m(t, e, n, r, i) { const a = this; a.good_length = t, a.max_lazy = e, a.nice_length = n, a.max_chain = r, a.func = i } const b = [new m(0, 0, 0, 0, 0), new m(4, 4, 8, 4, 1), new m(4, 5, 16, 8, 1), new m(4, 6, 32, 32, 1), new m(4, 4, 16, 16, 2), new m(8, 16, 32, 32, 2), new m(8, 16, 128, 128, 2), new m(8, 32, 128, 256, 2), new m(32, 128, 258, 1024, 2), new m(32, 258, 258, 4096, 2)], w = ["need dictionary", "stream end", "", "", "stream error", "data error", "", "buffer error", "", ""], y = 113, v = 666, _ = 258, x = 262; function k(t, e, n, r) { const i = t[2 * e], a = t[2 * n]; return i < a || i == a && r[e] <= r[n] } function E() { const t = this; let e, n, r, a, l, f, d, p, g, m, E, A, S, B, z, C, U, I, T, N, j, O, D, M, R, L, F, P, V, Z, q, H, W; const $ = new u, Q = new u, G = new u; let K, J, X, Y, tt, et; function nt() { let e; for (e = 0; e < 286; e++)q[2 * e] = 0; for (e = 0; e < 30; e++)H[2 * e] = 0; for (e = 0; e < 19; e++)W[2 * e] = 0; q[512] = 1, t.opt_len = t.static_len = 0, J = X = 0 } function rt(t, e) { let n, r = -1, i = t[1], a = 0, s = 7, o = 4; 0 === i && (s = 138, o = 3), t[2 * (e + 1) + 1] = 65535; for (let c = 0; c <= e; c++)n = i, i = t[2 * (c + 1) + 1], ++a < s && n == i || (a < o ? W[2 * n] += a : 0 !== n ? (n != r && W[2 * n]++, W[32]++) : a <= 10 ? W[34]++ : W[36]++, a = 0, r = n, 0 === i ? (s = 138, o = 3) : n == i ? (s = 6, o = 3) : (s = 7, o = 4)) } function it(e) { t.pending_buf[t.pending++] = e } function at(t) { it(255 & t), it(t >>> 8 & 255) } function st(t, e) { let n; const r = e; et > 16 - r ? (n = t, tt |= n << et & 65535, at(tt), tt = n >>> 16 - et, et += r - 16) : (tt |= t << et & 65535, et += r) } function ot(t, e) { const n = 2 * t; st(65535 & e[n], 65535 & e[n + 1]) } function ct(t, e) { let n, r, i = -1, a = t[1], s = 0, o = 7, c = 4; for (0 === a && (o = 138, c = 3), n = 0; n <= e; n++)if (r = a, a = t[2 * (n + 1) + 1], !(++s < o && r == a)) { if (s < c) do { ot(r, W) } while (0 != --s); else 0 !== r ? (r != i && (ot(r, W), s--), ot(16, W), st(s - 3, 2)) : s <= 10 ? (ot(17, W), st(s - 3, 3)) : (ot(18, W), st(s - 11, 7)); s = 0, i = r, 0 === a ? (o = 138, c = 3) : r == a ? (o = 6, c = 3) : (o = 7, c = 4) } } function lt() { 16 == et ? (at(tt), tt = 0, et = 0) : et >= 8 && (it(255 & tt), tt >>>= 8, et -= 8) } function ft(e, n) { let r, a, s; if (t.dist_buf[J] = e, t.lc_buf[J] = 255 & n, J++, 0 === e ? q[2 * n]++ : (X++, e--, q[2 * (u._length_code[n] + i + 1)]++, H[2 * u.d_code(e)]++), 0 == (8191 & J) && F > 2) { for (r = 8 * J, a = j - U, s = 0; s < 30; s++)r += H[2 * s] * (5 + u.extra_dbits[s]); if (r >>>= 3, X < Math.floor(J / 2) && r < Math.floor(a / 2)) return !0 } return J == K - 1 } function dt(e, n) { let r, a, o, c, l = 0; if (0 !== J) do { r = t.dist_buf[l], a = t.lc_buf[l], l++, 0 === r ? ot(a, e) : (o = u._length_code[a], ot(o + i + 1, e), c = u.extra_lbits[o], 0 !== c && (a -= u.base_length[o], st(a, c)), r--, o = u.d_code(r), ot(o, n), c = u.extra_dbits[o], 0 !== c && (r -= u.base_dist[o], st(r, c))) } while (l < J); ot(s, e), Y = e[513] } function ut() { et > 8 ? at(tt) : et > 0 && it(255 & tt), tt = 0, et = 0 } function ht(e, n, r) { st(0 + (r ? 1 : 0), 3), function (e, n, r) { ut(), Y = 8, r && (at(n), at(~n)), t.pending_buf.set(p.subarray(e, e + n), t.pending), t.pending += n }(e, n, !0) } function pt(e, n, r) { let i, a, s = 0; F > 0 ? ($.build_tree(t), Q.build_tree(t), s = function () { let e; for (rt(q, $.max_code), rt(H, Q.max_code), G.build_tree(t), e = 18; e >= 3 && 0 === W[2 * u.bl_order[e] + 1]; e--); return t.opt_len += 3 * (e + 1) + 5 + 5 + 4, e }(), i = t.opt_len + 3 + 7 >>> 3, a = t.static_len + 3 + 7 >>> 3, a <= i && (i = a)) : i = a = n + 5, n + 4 <= i && -1 != e ? ht(e, n, r) : a == i ? (st(2 + (r ? 1 : 0), 3), dt(h.static_ltree, h.static_dtree)) : (st(4 + (r ? 1 : 0), 3), function (t, e, n) { let r; for (st(t - 257, 5), st(e - 1, 5), st(n - 4, 4), r = 0; r < n; r++)st(W[2 * u.bl_order[r] + 1], 3); ct(q, t - 1), ct(H, e - 1) }($.max_code + 1, Q.max_code + 1, s + 1), dt(q, H)), nt(), r && ut() } function gt(t) { pt(U >= 0 ? U : -1, j - U, t), U = j, e.flush_pending() } function mt() { let t, n, r, i; do { if (i = g - D - j, 0 === i && 0 === j && 0 === D) i = l; else if (-1 == i) i--; else if (j >= l + l - x) { p.set(p.subarray(l, l + l), 0), O -= l, j -= l, U -= l, t = S, r = t; do { n = 65535 & E[--r], E[r] = n >= l ? n - l : 0 } while (0 != --t); t = l, r = t; do { n = 65535 & m[--r], m[r] = n >= l ? n - l : 0 } while (0 != --t); i += l } if (0 === e.avail_in) return; t = e.read_buf(p, j + D, i), D += t, D >= 3 && (A = 255 & p[j], A = (A << C ^ 255 & p[j + 1]) & z) } while (D < x && 0 !== e.avail_in) } function bt(t) { let e, n, r = R, i = j, a = M; const s = j > l - x ? j - (l - x) : 0; let o = Z; const c = d, f = j + _; let u = p[i + a - 1], h = p[i + a]; M >= V && (r >>= 2), o > D && (o = D); do { if (e = t, p[e + a] == h && p[e + a - 1] == u && p[e] == p[i] && p[++e] == p[i + 1]) { i += 2, e++; do { } while (p[++i] == p[++e] && p[++i] == p[++e] && p[++i] == p[++e] && p[++i] == p[++e] && p[++i] == p[++e] && p[++i] == p[++e] && p[++i] == p[++e] && p[++i] == p[++e] && i < f); if (n = _ - (f - i), i = f - _, n > a) { if (O = t, a = n, n >= o) break; u = p[i + a - 1], h = p[i + a] } } } while ((t = 65535 & m[t & c]) > s && 0 != --r); return a <= D ? a : D } function wt(e) { return e.total_in = e.total_out = 0, e.msg = null, t.pending = 0, t.pending_out = 0, n = y, a = 0, $.dyn_tree = q, $.stat_desc = h.static_l_desc, Q.dyn_tree = H, Q.stat_desc = h.static_d_desc, G.dyn_tree = W, G.stat_desc = h.static_bl_desc, tt = 0, et = 0, Y = 8, nt(), function () { g = 2 * l, E[S - 1] = 0; for (let t = 0; t < S - 1; t++)E[t] = 0; L = b[F].max_lazy, V = b[F].good_length, Z = b[F].nice_length, R = b[F].max_chain, j = 0, U = 0, D = 0, I = M = 2, N = 0, A = 0 }(), 0 } t.depth = [], t.bl_count = [], t.heap = [], q = [], H = [], W = [], t.pqdownheap = function (e, n) { const r = t.heap, i = r[n]; let a = n << 1; for (; a <= t.heap_len && (a < t.heap_len && k(e, r[a + 1], r[a], t.depth) && a++, !k(e, i, r[a], t.depth));)r[n] = r[a], n = a, a <<= 1; r[n] = i }, t.deflateInit = function (e, n, i, a, s, c) { return a || (a = 8), s || (s = 8), c || (c = 0), e.msg = null, -1 == n && (n = 6), s < 1 || s > 9 || 8 != a || i < 9 || i > 15 || n < 0 || n > 9 || c < 0 || c > 2 ? o : (e.dstate = t, f = i, l = 1 << f, d = l - 1, B = s + 7, S = 1 << B, z = S - 1, C = Math.floor((B + 3 - 1) / 3), p = new Uint8Array(2 * l), m = [], E = [], K = 1 << s + 6, t.pending_buf = new Uint8Array(4 * K), r = 4 * K, t.dist_buf = new Uint16Array(K), t.lc_buf = new Uint8Array(K), F = n, P = c, wt(e)) }, t.deflateEnd = function () { return 42 != n && n != y && n != v ? o : (t.lc_buf = null, t.dist_buf = null, t.pending_buf = null, E = null, m = null, p = null, t.dstate = null, n == y ? -3 : 0) }, t.deflateParams = function (t, e, n) { let r = 0; return -1 == e && (e = 6), e < 0 || e > 9 || n < 0 || n > 2 ? o : (b[F].func != b[e].func && 0 !== t.total_in && (r = t.deflate(1)), F != e && (F = e, L = b[F].max_lazy, V = b[F].good_length, Z = b[F].nice_length, R = b[F].max_chain), P = n, r) }, t.deflateSetDictionary = function (t, e, r) { let i, a = r, s = 0; if (!e || 42 != n) return o; if (a < 3) return 0; for (a > l - x && (a = l - x, s = r - a), p.set(e.subarray(s, s + a), 0), j = a, U = a, A = 255 & p[0], A = (A << C ^ 255 & p[1]) & z, i = 0; i <= a - 3; i++)A = (A << C ^ 255 & p[i + 2]) & z, m[i & d] = E[A], E[A] = i; return 0 }, t.deflate = function (i, u) { let g, _, k, B, R; if (u > 4 || u < 0) return o; if (!i.next_out || !i.next_in && 0 !== i.avail_in || n == v && 4 != u) return i.msg = w[4], o; if (0 === i.avail_out) return i.msg = w[7], c; var V; if (e = i, B = a, a = u, 42 == n && (_ = 8 + (f - 8 << 4) << 8, k = (F - 1 & 255) >> 1, k > 3 && (k = 3), _ |= k << 6, 0 !== j && (_ |= 32), _ += 31 - _ % 31, n = y, it((V = _) >> 8 & 255), it(255 & V)), 0 !== t.pending) { if (e.flush_pending(), 0 === e.avail_out) return a = -1, 0 } else if (0 === e.avail_in && u <= B && 4 != u) return e.msg = w[7], c; if (n == v && 0 !== e.avail_in) return i.msg = w[7], c; if (0 !== e.avail_in || 0 !== D || 0 != u && n != v) { switch (R = -1, b[F].func) { case 0: R = function (t) { let n, i = 65535; for (i > r - 5 && (i = r - 5); ;) { if (D <= 1) { if (mt(), 0 === D && 0 == t) return 0; if (0 === D) break } if (j += D, D = 0, n = U + i, (0 === j || j >= n) && (D = j - n, j = n, gt(!1), 0 === e.avail_out)) return 0; if (j - U >= l - x && (gt(!1), 0 === e.avail_out)) return 0 } return gt(4 == t), 0 === e.avail_out ? 4 == t ? 2 : 0 : 4 == t ? 3 : 1 }(u); break; case 1: R = function (t) { let n, r = 0; for (; ;) { if (D < x) { if (mt(), D < x && 0 == t) return 0; if (0 === D) break } if (D >= 3 && (A = (A << C ^ 255 & p[j + 2]) & z, r = 65535 & E[A], m[j & d] = E[A], E[A] = j), 0 !== r && (j - r & 65535) <= l - x && 2 != P && (I = bt(r)), I >= 3) if (n = ft(j - O, I - 3), D -= I, I <= L && D >= 3) { I--; do { j++, A = (A << C ^ 255 & p[j + 2]) & z, r = 65535 & E[A], m[j & d] = E[A], E[A] = j } while (0 != --I); j++ } else j += I, I = 0, A = 255 & p[j], A = (A << C ^ 255 & p[j + 1]) & z; else n = ft(0, 255 & p[j]), D--, j++; if (n && (gt(!1), 0 === e.avail_out)) return 0 } return gt(4 == t), 0 === e.avail_out ? 4 == t ? 2 : 0 : 4 == t ? 3 : 1 }(u); break; case 2: R = function (t) { let n, r, i = 0; for (; ;) { if (D < x) { if (mt(), D < x && 0 == t) return 0; if (0 === D) break } if (D >= 3 && (A = (A << C ^ 255 & p[j + 2]) & z, i = 65535 & E[A], m[j & d] = E[A], E[A] = j), M = I, T = O, I = 2, 0 !== i && M < L && (j - i & 65535) <= l - x && (2 != P && (I = bt(i)), I <= 5 && (1 == P || 3 == I && j - O > 4096) && (I = 2)), M >= 3 && I <= M) { r = j + D - 3, n = ft(j - 1 - T, M - 3), D -= M - 1, M -= 2; do { ++j <= r && (A = (A << C ^ 255 & p[j + 2]) & z, i = 65535 & E[A], m[j & d] = E[A], E[A] = j) } while (0 != --M); if (N = 0, I = 2, j++, n && (gt(!1), 0 === e.avail_out)) return 0 } else if (0 !== N) { if (n = ft(0, 255 & p[j - 1]), n && gt(!1), j++, D--, 0 === e.avail_out) return 0 } else N = 1, j++, D-- } return 0 !== N && (n = ft(0, 255 & p[j - 1]), N = 0), gt(4 == t), 0 === e.avail_out ? 4 == t ? 2 : 0 : 4 == t ? 3 : 1 }(u) }if (2 != R && 3 != R || (n = v), 0 == R || 2 == R) return 0 === e.avail_out && (a = -1), 0; if (1 == R) { if (1 == u) st(2, 3), ot(s, h.static_ltree), lt(), 1 + Y + 10 - et < 9 && (st(2, 3), ot(s, h.static_ltree), lt()), Y = 7; else if (ht(0, 0, !1), 3 == u) for (g = 0; g < S; g++)E[g] = 0; if (e.flush_pending(), 0 === e.avail_out) return a = -1, 0 } } return 4 != u ? 0 : 1 } } function A() { const t = this; t.next_in_index = 0, t.next_out_index = 0, t.avail_in = 0, t.total_in = 0, t.avail_out = 0, t.total_out = 0 } A.prototype = { deflateInit: function (t, e) { const n = this; return n.dstate = new E, e || (e = r), n.dstate.deflateInit(n, t, e) }, deflate: function (t) { const e = this; return e.dstate ? e.dstate.deflate(e, t) : o }, deflateEnd: function () { const t = this; if (!t.dstate) return o; const e = t.dstate.deflateEnd(); return t.dstate = null, e }, deflateParams: function (t, e) { const n = this; return n.dstate ? n.dstate.deflateParams(n, t, e) : o }, deflateSetDictionary: function (t, e) { const n = this; return n.dstate ? n.dstate.deflateSetDictionary(n, t, e) : o }, read_buf: function (t, e, n) { const r = this; let i = r.avail_in; return i > n && (i = n), 0 === i ? 0 : (r.avail_in -= i, t.set(r.next_in.subarray(r.next_in_index, r.next_in_index + i), e), r.next_in_index += i, r.total_in += i, i) }, flush_pending: function () { const t = this; let e = t.dstate.pending; e > t.avail_out && (e = t.avail_out), 0 !== e && (t.next_out.set(t.dstate.pending_buf.subarray(t.dstate.pending_out, t.dstate.pending_out + e), t.next_out_index), t.next_out_index += e, t.dstate.pending_out += e, t.total_out += e, t.avail_out -= e, t.dstate.pending -= e, 0 === t.dstate.pending && (t.dstate.pending_out = 0)) } }; var S = function (t) { const e = new A, n = (r = t && t.chunkSize ? t.chunkSize : 65536) + 5 * (Math.floor(r / 16383) + 1); var r; const i = new Uint8Array(n); let a = t ? t.level : -1; void 0 === a && (a = -1), e.deflateInit(a), e.next_out = i, this.append = function (t, r) { let a, s, o = 0, c = 0, l = 0; const f = []; if (t.length) { e.next_in_index = 0, e.next_in = t, e.avail_in = t.length; do { if (e.next_out_index = 0, e.avail_out = n, a = e.deflate(0), 0 != a) throw new Error("deflating: " + e.msg); e.next_out_index && (e.next_out_index == n ? f.push(new Uint8Array(i)) : f.push(i.slice(0, e.next_out_index))), l += e.next_out_index, r && e.next_in_index > 0 && e.next_in_index != o && (r(e.next_in_index), o = e.next_in_index) } while (e.avail_in > 0 || 0 === e.avail_out); return f.length > 1 ? (s = new Uint8Array(l), f.forEach((function (t) { s.set(t, c), c += t.length }))) : s = f[0] || new Uint8Array(0), s } }, this.flush = function () { let t, r, a = 0, s = 0; const o = []; do { if (e.next_out_index = 0, e.avail_out = n, t = e.deflate(4), 1 != t && 0 != t) throw new Error("deflating: " + e.msg); n - e.avail_out > 0 && o.push(i.slice(0, e.next_out_index)), s += e.next_out_index } while (e.avail_in > 0 || 0 === e.avail_out); return e.deflateEnd(), r = new Uint8Array(s), o.forEach((function (t) { r.set(t, a), a += t.length })), r } }; const B = 0, z = 1, C = -2, U = -3, I = -4, T = -5, N = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535], j = 1440, O = [96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 192, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 160, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0, 9, 224, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 144, 83, 7, 59, 0, 8, 120, 0, 8, 56, 0, 9, 208, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 176, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 240, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 200, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9, 168, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 232, 80, 7, 8, 0, 8, 92, 0, 8, 28, 0, 9, 152, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 216, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 184, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 248, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 196, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 164, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0, 9, 228, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 148, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 212, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 180, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 244, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 204, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9, 172, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 236, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 156, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 220, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 188, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 252, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 194, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 162, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 226, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 146, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 210, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 178, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 242, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9, 202, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 170, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 234, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 154, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 218, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 186, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 250, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 198, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 166, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 230, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 150, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 214, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 182, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9, 246, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9, 206, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 174, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 238, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 158, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 222, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9, 190, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 254, 96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 193, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 161, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0, 9, 225, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 145, 83, 7, 59, 0, 8, 120, 0, 8, 56, 0, 9, 209, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 177, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 241, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 201, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9, 169, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 233, 80, 7, 8, 0, 8, 92, 0, 8, 28, 0, 9, 153, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 217, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 185, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 249, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 197, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 165, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0, 9, 229, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 149, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 213, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 181, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 245, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 205, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9, 173, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 237, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 157, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 221, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 189, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 253, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 195, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 163, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 227, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 147, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 211, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 179, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 243, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9, 203, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 171, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 235, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 155, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 219, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 187, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 251, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 199, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 167, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 231, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 151, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 215, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 183, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9, 247, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9, 207, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 175, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 239, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 159, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 223, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9, 191, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 255], D = [80, 5, 1, 87, 5, 257, 83, 5, 17, 91, 5, 4097, 81, 5, 5, 89, 5, 1025, 85, 5, 65, 93, 5, 16385, 80, 5, 3, 88, 5, 513, 84, 5, 33, 92, 5, 8193, 82, 5, 9, 90, 5, 2049, 86, 5, 129, 192, 5, 24577, 80, 5, 2, 87, 5, 385, 83, 5, 25, 91, 5, 6145, 81, 5, 7, 89, 5, 1537, 85, 5, 97, 93, 5, 24577, 80, 5, 4, 88, 5, 769, 84, 5, 49, 92, 5, 12289, 82, 5, 13, 90, 5, 3073, 86, 5, 193, 192, 5, 24577], M = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], R = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112], L = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577], F = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], P = 15; function V() { let t, e, n, r, i, a; function s(t, e, s, o, c, l, f, d, u, h, p) { let g, m, b, w, y, v, _, x, k, E, A, S, z, C, I; E = 0, y = s; do { n[t[e + E]]++, E++, y-- } while (0 !== y); if (n[0] == s) return f[0] = -1, d[0] = 0, B; for (x = d[0], v = 1; v <= P && 0 === n[v]; v++); for (_ = v, x < v && (x = v), y = P; 0 !== y && 0 === n[y]; y--); for (b = y, x > y && (x = y), d[0] = x, C = 1 << v; v < y; v++, C <<= 1)if ((C -= n[v]) < 0) return U; if ((C -= n[y]) < 0) return U; for (n[y] += C, a[1] = v = 0, E = 1, z = 2; 0 != --y;)a[z] = v += n[E], z++, E++; y = 0, E = 0; do { 0 !== (v = t[e + E]) && (p[a[v]++] = y), E++ } while (++y < s); for (s = a[b], a[0] = y = 0, E = 0, w = -1, S = -x, i[0] = 0, A = 0, I = 0; _ <= b; _++)for (g = n[_]; 0 != g--;) { for (; _ > S + x;) { if (w++, S += x, I = b - S, I = I > x ? x : I, (m = 1 << (v = _ - S)) > g + 1 && (m -= g + 1, z = _, v < I)) for (; ++v < I && !((m <<= 1) <= n[++z]);)m -= n[z]; if (I = 1 << v, h[0] + I > j) return U; i[w] = A = h[0], h[0] += I, 0 !== w ? (a[w] = y, r[0] = v, r[1] = x, v = y >>> S - x, r[2] = A - i[w - 1] - v, u.set(r, 3 * (i[w - 1] + v))) : f[0] = A } for (r[1] = _ - S, E >= s ? r[0] = 192 : p[E] < o ? (r[0] = p[E] < 256 ? 0 : 96, r[2] = p[E++]) : (r[0] = l[p[E] - o] + 16 + 64, r[2] = c[p[E++] - o]), m = 1 << _ - S, v = y >>> S; v < I; v += m)u.set(r, 3 * (A + v)); for (v = 1 << _ - 1; 0 != (y & v); v >>>= 1)y ^= v; for (y ^= v, k = (1 << S) - 1; (y & k) != a[w];)w--, S -= x, k = (1 << S) - 1 } return 0 !== C && 1 != b ? T : B } function o(s) { let o; for (t || (t = [], e = [], n = new Int32Array(P + 1), r = [], i = new Int32Array(P), a = new Int32Array(P + 1)), e.length < s && (e = []), o = 0; o < s; o++)e[o] = 0; for (o = 0; o < P + 1; o++)n[o] = 0; for (o = 0; o < 3; o++)r[o] = 0; i.set(n.subarray(0, P), 0), a.set(n.subarray(0, P + 1), 0) } this.inflate_trees_bits = function (n, r, i, a, c) { let l; return o(19), t[0] = 0, l = s(n, 0, 19, 19, null, null, i, r, a, t, e), l == U ? c.msg = "oversubscribed dynamic bit lengths tree" : l != T && 0 !== r[0] || (c.msg = "incomplete dynamic bit lengths tree", l = U), l }, this.inflate_trees_dynamic = function (n, r, i, a, c, l, f, d, u) { let h; return o(288), t[0] = 0, h = s(i, 0, n, 257, M, R, l, a, d, t, e), h != B || 0 === a[0] ? (h == U ? u.msg = "oversubscribed literal/length tree" : h != I && (u.msg = "incomplete literal/length tree", h = U), h) : (o(288), h = s(i, n, r, 0, L, F, f, c, d, t, e), h != B || 0 === c[0] && n > 257 ? (h == U ? u.msg = "oversubscribed distance tree" : h == T ? (u.msg = "incomplete distance tree", h = U) : h != I && (u.msg = "empty distance tree with lengths", h = U), h) : B) } } V.inflate_trees_fixed = function (t, e, n, r) { return t[0] = 9, e[0] = 5, n[0] = O, r[0] = D, B }; const Z = 0, q = 1, H = 2, W = 3, $ = 4, Q = 5, G = 6, K = 7, J = 8, X = 9; function Y() { const t = this; let e, n, r, i, a = 0, s = 0, o = 0, c = 0, l = 0, f = 0, d = 0, u = 0, h = 0, p = 0; function g(t, e, n, r, i, a, s, o) { let c, l, f, d, u, h, p, g, m, b, w, y, v, _, x, k; p = o.next_in_index, g = o.avail_in, u = s.bitb, h = s.bitk, m = s.write, b = m < s.read ? s.read - m - 1 : s.end - m, w = N[t], y = N[e]; do { for (; h < 20;)g--, u |= (255 & o.read_byte(p++)) << h, h += 8; if (c = u & w, l = n, f = r, k = 3 * (f + c), 0 !== (d = l[k])) for (; ;) { if (u >>= l[k + 1], h -= l[k + 1], 0 != (16 & d)) { for (d &= 15, v = l[k + 2] + (u & N[d]), u >>= d, h -= d; h < 15;)g--, u |= (255 & o.read_byte(p++)) << h, h += 8; for (c = u & y, l = i, f = a, k = 3 * (f + c), d = l[k]; ;) { if (u >>= l[k + 1], h -= l[k + 1], 0 != (16 & d)) { for (d &= 15; h < d;)g--, u |= (255 & o.read_byte(p++)) << h, h += 8; if (_ = l[k + 2] + (u & N[d]), u >>= d, h -= d, b -= v, m >= _) x = m - _, m - x > 0 && 2 > m - x ? (s.win[m++] = s.win[x++], s.win[m++] = s.win[x++], v -= 2) : (s.win.set(s.win.subarray(x, x + 2), m), m += 2, x += 2, v -= 2); else { x = m - _; do { x += s.end } while (x < 0); if (d = s.end - x, v > d) { if (v -= d, m - x > 0 && d > m - x) do { s.win[m++] = s.win[x++] } while (0 != --d); else s.win.set(s.win.subarray(x, x + d), m), m += d, x += d, d = 0; x = 0 } } if (m - x > 0 && v > m - x) do { s.win[m++] = s.win[x++] } while (0 != --v); else s.win.set(s.win.subarray(x, x + v), m), m += v, x += v, v = 0; break } if (0 != (64 & d)) return o.msg = "invalid distance code", v = o.avail_in - g, v = h >> 3 < v ? h >> 3 : v, g += v, p -= v, h -= v << 3, s.bitb = u, s.bitk = h, o.avail_in = g, o.total_in += p - o.next_in_index, o.next_in_index = p, s.write = m, U; c += l[k + 2], c += u & N[d], k = 3 * (f + c), d = l[k] } break } if (0 != (64 & d)) return 0 != (32 & d) ? (v = o.avail_in - g, v = h >> 3 < v ? h >> 3 : v, g += v, p -= v, h -= v << 3, s.bitb = u, s.bitk = h, o.avail_in = g, o.total_in += p - o.next_in_index, o.next_in_index = p, s.write = m, z) : (o.msg = "invalid literal/length code", v = o.avail_in - g, v = h >> 3 < v ? h >> 3 : v, g += v, p -= v, h -= v << 3, s.bitb = u, s.bitk = h, o.avail_in = g, o.total_in += p - o.next_in_index, o.next_in_index = p, s.write = m, U); if (c += l[k + 2], c += u & N[d], k = 3 * (f + c), 0 === (d = l[k])) { u >>= l[k + 1], h -= l[k + 1], s.win[m++] = l[k + 2], b--; break } } else u >>= l[k + 1], h -= l[k + 1], s.win[m++] = l[k + 2], b-- } while (b >= 258 && g >= 10); return v = o.avail_in - g, v = h >> 3 < v ? h >> 3 : v, g += v, p -= v, h -= v << 3, s.bitb = u, s.bitk = h, o.avail_in = g, o.total_in += p - o.next_in_index, o.next_in_index = p, s.write = m, B } t.init = function (t, a, s, o, c, l) { e = Z, d = t, u = a, r = s, h = o, i = c, p = l, n = null }, t.proc = function (t, m, b) { let w, y, v, _, x, k, E, A = 0, S = 0, I = 0; for (I = m.next_in_index, _ = m.avail_in, A = t.bitb, S = t.bitk, x = t.write, k = x < t.read ? t.read - x - 1 : t.end - x; ;)switch (e) { case Z: if (k >= 258 && _ >= 10 && (t.bitb = A, t.bitk = S, m.avail_in = _, m.total_in += I - m.next_in_index, m.next_in_index = I, t.write = x, b = g(d, u, r, h, i, p, t, m), I = m.next_in_index, _ = m.avail_in, A = t.bitb, S = t.bitk, x = t.write, k = x < t.read ? t.read - x - 1 : t.end - x, b != B)) { e = b == z ? K : X; break } o = d, n = r, s = h, e = q; case q: for (w = o; S < w;) { if (0 === _) return t.bitb = A, t.bitk = S, m.avail_in = _, m.total_in += I - m.next_in_index, m.next_in_index = I, t.write = x, t.inflate_flush(m, b); b = B, _--, A |= (255 & m.read_byte(I++)) << S, S += 8 } if (y = 3 * (s + (A & N[w])), A >>>= n[y + 1], S -= n[y + 1], v = n[y], 0 === v) { c = n[y + 2], e = G; break } if (0 != (16 & v)) { l = 15 & v, a = n[y + 2], e = H; break } if (0 == (64 & v)) { o = v, s = y / 3 + n[y + 2]; break } if (0 != (32 & v)) { e = K; break } return e = X, m.msg = "invalid literal/length code", b = U, t.bitb = A, t.bitk = S, m.avail_in = _, m.total_in += I - m.next_in_index, m.next_in_index = I, t.write = x, t.inflate_flush(m, b); case H: for (w = l; S < w;) { if (0 === _) return t.bitb = A, t.bitk = S, m.avail_in = _, m.total_in += I - m.next_in_index, m.next_in_index = I, t.write = x, t.inflate_flush(m, b); b = B, _--, A |= (255 & m.read_byte(I++)) << S, S += 8 } a += A & N[w], A >>= w, S -= w, o = u, n = i, s = p, e = W; case W: for (w = o; S < w;) { if (0 === _) return t.bitb = A, t.bitk = S, m.avail_in = _, m.total_in += I - m.next_in_index, m.next_in_index = I, t.write = x, t.inflate_flush(m, b); b = B, _--, A |= (255 & m.read_byte(I++)) << S, S += 8 } if (y = 3 * (s + (A & N[w])), A >>= n[y + 1], S -= n[y + 1], v = n[y], 0 != (16 & v)) { l = 15 & v, f = n[y + 2], e = $; break } if (0 == (64 & v)) { o = v, s = y / 3 + n[y + 2]; break } return e = X, m.msg = "invalid distance code", b = U, t.bitb = A, t.bitk = S, m.avail_in = _, m.total_in += I - m.next_in_index, m.next_in_index = I, t.write = x, t.inflate_flush(m, b); case $: for (w = l; S < w;) { if (0 === _) return t.bitb = A, t.bitk = S, m.avail_in = _, m.total_in += I - m.next_in_index, m.next_in_index = I, t.write = x, t.inflate_flush(m, b); b = B, _--, A |= (255 & m.read_byte(I++)) << S, S += 8 } f += A & N[w], A >>= w, S -= w, e = Q; case Q: for (E = x - f; E < 0;)E += t.end; for (; 0 !== a;) { if (0 === k && (x == t.end && 0 !== t.read && (x = 0, k = x < t.read ? t.read - x - 1 : t.end - x), 0 === k && (t.write = x, b = t.inflate_flush(m, b), x = t.write, k = x < t.read ? t.read - x - 1 : t.end - x, x == t.end && 0 !== t.read && (x = 0, k = x < t.read ? t.read - x - 1 : t.end - x), 0 === k))) return t.bitb = A, t.bitk = S, m.avail_in = _, m.total_in += I - m.next_in_index, m.next_in_index = I, t.write = x, t.inflate_flush(m, b); t.win[x++] = t.win[E++], k--, E == t.end && (E = 0), a-- } e = Z; break; case G: if (0 === k && (x == t.end && 0 !== t.read && (x = 0, k = x < t.read ? t.read - x - 1 : t.end - x), 0 === k && (t.write = x, b = t.inflate_flush(m, b), x = t.write, k = x < t.read ? t.read - x - 1 : t.end - x, x == t.end && 0 !== t.read && (x = 0, k = x < t.read ? t.read - x - 1 : t.end - x), 0 === k))) return t.bitb = A, t.bitk = S, m.avail_in = _, m.total_in += I - m.next_in_index, m.next_in_index = I, t.write = x, t.inflate_flush(m, b); b = B, t.win[x++] = c, k--, e = Z; break; case K: if (S > 7 && (S -= 8, _++, I--), t.write = x, b = t.inflate_flush(m, b), x = t.write, k = x < t.read ? t.read - x - 1 : t.end - x, t.read != t.write) return t.bitb = A, t.bitk = S, m.avail_in = _, m.total_in += I - m.next_in_index, m.next_in_index = I, t.write = x, t.inflate_flush(m, b); e = J; case J: return b = z, t.bitb = A, t.bitk = S, m.avail_in = _, m.total_in += I - m.next_in_index, m.next_in_index = I, t.write = x, t.inflate_flush(m, b); case X: return b = U, t.bitb = A, t.bitk = S, m.avail_in = _, m.total_in += I - m.next_in_index, m.next_in_index = I, t.write = x, t.inflate_flush(m, b); default: return b = C, t.bitb = A, t.bitk = S, m.avail_in = _, m.total_in += I - m.next_in_index, m.next_in_index = I, t.write = x, t.inflate_flush(m, b) } }, t.free = function () { } } const tt = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], et = 0, nt = 1, rt = 2, it = 3, at = 4, st = 5, ot = 6, ct = 7, lt = 8, ft = 9; function dt(t, e) { const n = this; let r, i = et, a = 0, s = 0, o = 0; const c = [0], l = [0], f = new Y; let d = 0, u = new Int32Array(3 * j); const h = new V; n.bitk = 0, n.bitb = 0, n.win = new Uint8Array(e), n.end = e, n.read = 0, n.write = 0, n.reset = function (t, e) { e && (e[0] = 0), i == ot && f.free(t), i = et, n.bitk = 0, n.bitb = 0, n.read = n.write = 0 }, n.reset(t, null), n.inflate_flush = function (t, e) { let r, i, a; return i = t.next_out_index, a = n.read, r = (a <= n.write ? n.write : n.end) - a, r > t.avail_out && (r = t.avail_out), 0 !== r && e == T && (e = B), t.avail_out -= r, t.total_out += r, t.next_out.set(n.win.subarray(a, a + r), i), i += r, a += r, a == n.end && (a = 0, n.write == n.end && (n.write = 0), r = n.write - a, r > t.avail_out && (r = t.avail_out), 0 !== r && e == T && (e = B), t.avail_out -= r, t.total_out += r, t.next_out.set(n.win.subarray(a, a + r), i), i += r, a += r), t.next_out_index = i, n.read = a, e }, n.proc = function (t, e) { let p, g, m, b, w, y, v, _; for (b = t.next_in_index, w = t.avail_in, g = n.bitb, m = n.bitk, y = n.write, v = y < n.read ? n.read - y - 1 : n.end - y; ;) { let x, k, E, A, S, I, T, j; switch (i) { case et: for (; m < 3;) { if (0 === w) return n.bitb = g, n.bitk = m, t.avail_in = w, t.total_in += b - t.next_in_index, t.next_in_index = b, n.write = y, n.inflate_flush(t, e); e = B, w--, g |= (255 & t.read_byte(b++)) << m, m += 8 } switch (p = 7 & g, d = 1 & p, p >>> 1) { case 0: g >>>= 3, m -= 3, p = 7 & m, g >>>= p, m -= p, i = nt; break; case 1: x = [], k = [], E = [[]], A = [[]], V.inflate_trees_fixed(x, k, E, A), f.init(x[0], k[0], E[0], 0, A[0], 0), g >>>= 3, m -= 3, i = ot; break; case 2: g >>>= 3, m -= 3, i = it; break; case 3: return g >>>= 3, m -= 3, i = ft, t.msg = "invalid block type", e = U, n.bitb = g, n.bitk = m, t.avail_in = w, t.total_in += b - t.next_in_index, t.next_in_index = b, n.write = y, n.inflate_flush(t, e) }break; case nt: for (; m < 32;) { if (0 === w) return n.bitb = g, n.bitk = m, t.avail_in = w, t.total_in += b - t.next_in_index, t.next_in_index = b, n.write = y, n.inflate_flush(t, e); e = B, w--, g |= (255 & t.read_byte(b++)) << m, m += 8 } if ((~g >>> 16 & 65535) != (65535 & g)) return i = ft, t.msg = "invalid stored block lengths", e = U, n.bitb = g, n.bitk = m, t.avail_in = w, t.total_in += b - t.next_in_index, t.next_in_index = b, n.write = y, n.inflate_flush(t, e); a = 65535 & g, g = m = 0, i = 0 !== a ? rt : 0 !== d ? ct : et; break; case rt: if (0 === w) return n.bitb = g, n.bitk = m, t.avail_in = w, t.total_in += b - t.next_in_index, t.next_in_index = b, n.write = y, n.inflate_flush(t, e); if (0 === v && (y == n.end && 0 !== n.read && (y = 0, v = y < n.read ? n.read - y - 1 : n.end - y), 0 === v && (n.write = y, e = n.inflate_flush(t, e), y = n.write, v = y < n.read ? n.read - y - 1 : n.end - y, y == n.end && 0 !== n.read && (y = 0, v = y < n.read ? n.read - y - 1 : n.end - y), 0 === v))) return n.bitb = g, n.bitk = m, t.avail_in = w, t.total_in += b - t.next_in_index, t.next_in_index = b, n.write = y, n.inflate_flush(t, e); if (e = B, p = a, p > w && (p = w), p > v && (p = v), n.win.set(t.read_buf(b, p), y), b += p, w -= p, y += p, v -= p, 0 != (a -= p)) break; i = 0 !== d ? ct : et; break; case it: for (; m < 14;) { if (0 === w) return n.bitb = g, n.bitk = m, t.avail_in = w, t.total_in += b - t.next_in_index, t.next_in_index = b, n.write = y, n.inflate_flush(t, e); e = B, w--, g |= (255 & t.read_byte(b++)) << m, m += 8 } if (s = p = 16383 & g, (31 & p) > 29 || (p >> 5 & 31) > 29) return i = ft, t.msg = "too many length or distance symbols", e = U, n.bitb = g, n.bitk = m, t.avail_in = w, t.total_in += b - t.next_in_index, t.next_in_index = b, n.write = y, n.inflate_flush(t, e); if (p = 258 + (31 & p) + (p >> 5 & 31), !r || r.length < p) r = []; else for (_ = 0; _ < p; _++)r[_] = 0; g >>>= 14, m -= 14, o = 0, i = at; case at: for (; o < 4 + (s >>> 10);) { for (; m < 3;) { if (0 === w) return n.bitb = g, n.bitk = m, t.avail_in = w, t.total_in += b - t.next_in_index, t.next_in_index = b, n.write = y, n.inflate_flush(t, e); e = B, w--, g |= (255 & t.read_byte(b++)) << m, m += 8 } r[tt[o++]] = 7 & g, g >>>= 3, m -= 3 } for (; o < 19;)r[tt[o++]] = 0; if (c[0] = 7, p = h.inflate_trees_bits(r, c, l, u, t), p != B) return (e = p) == U && (r = null, i = ft), n.bitb = g, n.bitk = m, t.avail_in = w, t.total_in += b - t.next_in_index, t.next_in_index = b, n.write = y, n.inflate_flush(t, e); o = 0, i = st; case st: for (; p = s, !(o >= 258 + (31 & p) + (p >> 5 & 31));) { let a, f; for (p = c[0]; m < p;) { if (0 === w) return n.bitb = g, n.bitk = m, t.avail_in = w, t.total_in += b - t.next_in_index, t.next_in_index = b, n.write = y, n.inflate_flush(t, e); e = B, w--, g |= (255 & t.read_byte(b++)) << m, m += 8 } if (p = u[3 * (l[0] + (g & N[p])) + 1], f = u[3 * (l[0] + (g & N[p])) + 2], f < 16) g >>>= p, m -= p, r[o++] = f; else { for (_ = 18 == f ? 7 : f - 14, a = 18 == f ? 11 : 3; m < p + _;) { if (0 === w) return n.bitb = g, n.bitk = m, t.avail_in = w, t.total_in += b - t.next_in_index, t.next_in_index = b, n.write = y, n.inflate_flush(t, e); e = B, w--, g |= (255 & t.read_byte(b++)) << m, m += 8 } if (g >>>= p, m -= p, a += g & N[_], g >>>= _, m -= _, _ = o, p = s, _ + a > 258 + (31 & p) + (p >> 5 & 31) || 16 == f && _ < 1) return r = null, i = ft, t.msg = "invalid bit length repeat", e = U, n.bitb = g, n.bitk = m, t.avail_in = w, t.total_in += b - t.next_in_index, t.next_in_index = b, n.write = y, n.inflate_flush(t, e); f = 16 == f ? r[_ - 1] : 0; do { r[_++] = f } while (0 != --a); o = _ } } if (l[0] = -1, S = [], I = [], T = [], j = [], S[0] = 9, I[0] = 6, p = s, p = h.inflate_trees_dynamic(257 + (31 & p), 1 + (p >> 5 & 31), r, S, I, T, j, u, t), p != B) return p == U && (r = null, i = ft), e = p, n.bitb = g, n.bitk = m, t.avail_in = w, t.total_in += b - t.next_in_index, t.next_in_index = b, n.write = y, n.inflate_flush(t, e); f.init(S[0], I[0], u, T[0], u, j[0]), i = ot; case ot: if (n.bitb = g, n.bitk = m, t.avail_in = w, t.total_in += b - t.next_in_index, t.next_in_index = b, n.write = y, (e = f.proc(n, t, e)) != z) return n.inflate_flush(t, e); if (e = B, f.free(t), b = t.next_in_index, w = t.avail_in, g = n.bitb, m = n.bitk, y = n.write, v = y < n.read ? n.read - y - 1 : n.end - y, 0 === d) { i = et; break } i = ct; case ct: if (n.write = y, e = n.inflate_flush(t, e), y = n.write, v = y < n.read ? n.read - y - 1 : n.end - y, n.read != n.write) return n.bitb = g, n.bitk = m, t.avail_in = w, t.total_in += b - t.next_in_index, t.next_in_index = b, n.write = y, n.inflate_flush(t, e); i = lt; case lt: return e = z, n.bitb = g, n.bitk = m, t.avail_in = w, t.total_in += b - t.next_in_index, t.next_in_index = b, n.write = y, n.inflate_flush(t, e); case ft: return e = U, n.bitb = g, n.bitk = m, t.avail_in = w, t.total_in += b - t.next_in_index, t.next_in_index = b, n.write = y, n.inflate_flush(t, e); default: return e = C, n.bitb = g, n.bitk = m, t.avail_in = w, t.total_in += b - t.next_in_index, t.next_in_index = b, n.write = y, n.inflate_flush(t, e) } } }, n.free = function (t) { n.reset(t, null), n.win = null, u = null }, n.set_dictionary = function (t, e, r) { n.win.set(t.subarray(e, e + r), 0), n.read = n.write = r }, n.sync_point = function () { return i == nt ? 1 : 0 } } const ut = 13, ht = [0, 0, 255, 255]; function pt() { const t = this; function e(t) { return t && t.istate ? (t.total_in = t.total_out = 0, t.msg = null, t.istate.mode = 7, t.istate.blocks.reset(t, null), B) : C } t.mode = 0, t.method = 0, t.was = [0], t.need = 0, t.marker = 0, t.wbits = 0, t.inflateEnd = function (e) { return t.blocks && t.blocks.free(e), t.blocks = null, B }, t.inflateInit = function (n, r) { return n.msg = null, t.blocks = null, r < 8 || r > 15 ? (t.inflateEnd(n), C) : (t.wbits = r, n.istate.blocks = new dt(n, 1 << r), e(n), B) }, t.inflate = function (t, e) { let n, r; if (!t || !t.istate || !t.next_in) return C; const i = t.istate; for (e = 4 == e ? T : B, n = T; ;)switch (i.mode) { case 0: if (0 === t.avail_in) return n; if (n = e, t.avail_in--, t.total_in++, 8 != (15 & (i.method = t.read_byte(t.next_in_index++)))) { i.mode = ut, t.msg = "unknown compression method", i.marker = 5; break } if (8 + (i.method >> 4) > i.wbits) { i.mode = ut, t.msg = "invalid win size", i.marker = 5; break } i.mode = 1; case 1: if (0 === t.avail_in) return n; if (n = e, t.avail_in--, t.total_in++, r = 255 & t.read_byte(t.next_in_index++), ((i.method << 8) + r) % 31 != 0) { i.mode = ut, t.msg = "incorrect header check", i.marker = 5; break } if (0 == (32 & r)) { i.mode = 7; break } i.mode = 2; case 2: if (0 === t.avail_in) return n; n = e, t.avail_in--, t.total_in++, i.need = (255 & t.read_byte(t.next_in_index++)) << 24 & 4278190080, i.mode = 3; case 3: if (0 === t.avail_in) return n; n = e, t.avail_in--, t.total_in++, i.need += (255 & t.read_byte(t.next_in_index++)) << 16 & 16711680, i.mode = 4; case 4: if (0 === t.avail_in) return n; n = e, t.avail_in--, t.total_in++, i.need += (255 & t.read_byte(t.next_in_index++)) << 8 & 65280, i.mode = 5; case 5: return 0 === t.avail_in ? n : (n = e, t.avail_in--, t.total_in++, i.need += 255 & t.read_byte(t.next_in_index++), i.mode = 6, 2); case 6: return i.mode = ut, t.msg = "need dictionary", i.marker = 0, C; case 7: if (n = i.blocks.proc(t, n), n == U) { i.mode = ut, i.marker = 0; break } if (n == B && (n = e), n != z) return n; n = e, i.blocks.reset(t, i.was), i.mode = 12; case 12: return t.avail_in = 0, z; case ut: return U; default: return C } }, t.inflateSetDictionary = function (t, e, n) { let r = 0, i = n; if (!t || !t.istate || 6 != t.istate.mode) return C; const a = t.istate; return i >= 1 << a.wbits && (i = (1 << a.wbits) - 1, r = n - i), a.blocks.set_dictionary(e, r, i), a.mode = 7, B }, t.inflateSync = function (t) { let n, r, i, a, s; if (!t || !t.istate) return C; const o = t.istate; if (o.mode != ut && (o.mode = ut, o.marker = 0), 0 === (n = t.avail_in)) return T; for (r = t.next_in_index, i = o.marker; 0 !== n && i < 4;)t.read_byte(r) == ht[i] ? i++ : i = 0 !== t.read_byte(r) ? 0 : 4 - i, r++, n--; return t.total_in += r - t.next_in_index, t.next_in_index = r, t.avail_in = n, o.marker = i, 4 != i ? U : (a = t.total_in, s = t.total_out, e(t), t.total_in = a, t.total_out = s, o.mode = 7, B) }, t.inflateSyncPoint = function (t) { return t && t.istate && t.istate.blocks ? t.istate.blocks.sync_point() : C } } function gt() { } gt.prototype = { inflateInit: function (t) { const e = this; return e.istate = new pt, t || (t = 15), e.istate.inflateInit(e, t) }, inflate: function (t) { const e = this; return e.istate ? e.istate.inflate(e, t) : C }, inflateEnd: function () { const t = this; if (!t.istate) return C; const e = t.istate.inflateEnd(t); return t.istate = null, e }, inflateSync: function () { const t = this; return t.istate ? t.istate.inflateSync(t) : C }, inflateSetDictionary: function (t, e) { const n = this; return n.istate ? n.istate.inflateSetDictionary(n, t, e) : C }, read_byte: function (t) { return this.next_in[t] }, read_buf: function (t, e) { return this.next_in.subarray(t, t + e) } }; var mt = function (t) { const e = new gt, n = t && t.chunkSize ? Math.floor(2 * t.chunkSize) : 131072, r = new Uint8Array(n); let i = !1; e.inflateInit(), e.next_out = r, this.append = function (t, a) { const s = []; let o, c, l = 0, f = 0, d = 0; if (0 !== t.length) { e.next_in_index = 0, e.next_in = t, e.avail_in = t.length; do { if (e.next_out_index = 0, e.avail_out = n, 0 !== e.avail_in || i || (e.next_in_index = 0, i = !0), o = e.inflate(0), i && o === T) { if (0 !== e.avail_in) throw new Error("inflating: bad input") } else if (o !== B && o !== z) throw new Error("inflating: " + e.msg); if ((i || o === z) && e.avail_in === t.length) throw new Error("inflating: bad input"); e.next_out_index && (e.next_out_index === n ? s.push(new Uint8Array(r)) : s.push(r.slice(0, e.next_out_index))), d += e.next_out_index, a && e.next_in_index > 0 && e.next_in_index != l && (a(e.next_in_index), l = e.next_in_index) } while (e.avail_in > 0 || 0 === e.avail_out); return s.length > 1 ? (c = new Uint8Array(d), s.forEach((function (t) { c.set(t, f), f += t.length }))) : c = s[0] || new Uint8Array(0), c } }, this.flush = function () { e.inflateEnd() } }; const bt = { chunkSize: 524288, maxWorkers: "undefined" != typeof navigator && navigator.hardwareConcurrency || 2, terminateWorkerTimeout: 5e3, useWebWorkers: !0, workerScripts: void 0 }, wt = Object.assign({}, bt); function yt() { return wt } function vt(t) { if (void 0 !== t.baseURL && (wt.baseURL = t.baseURL), void 0 !== t.chunkSize && (wt.chunkSize = t.chunkSize), void 0 !== t.maxWorkers && (wt.maxWorkers = t.maxWorkers), void 0 !== t.terminateWorkerTimeout && (wt.terminateWorkerTimeout = t.terminateWorkerTimeout), void 0 !== t.useWebWorkers && (wt.useWebWorkers = t.useWebWorkers), void 0 !== t.Deflate && (wt.Deflate = t.Deflate), void 0 !== t.Inflate && (wt.Inflate = t.Inflate), void 0 !== t.workerScripts) { if (t.workerScripts.deflate) { if (!Array.isArray(t.workerScripts.deflate)) throw new Error("workerScripts.deflate must be an array"); wt.workerScripts || (wt.workerScripts = {}), wt.workerScripts.deflate = t.workerScripts.deflate } if (t.workerScripts.inflate) { if (!Array.isArray(t.workerScripts.inflate)) throw new Error("workerScripts.inflate must be an array"); wt.workerScripts || (wt.workerScripts = {}), wt.workerScripts.inflate = t.workerScripts.inflate } } } const _t = { application: { "andrew-inset": "ez", annodex: "anx", "atom+xml": "atom", "atomcat+xml": "atomcat", "atomserv+xml": "atomsrv", bbolin: "lin", cap: ["cap", "pcap"], "cu-seeme": "cu", "davmount+xml": "davmount", dsptype: "tsp", ecmascript: ["es", "ecma"], futuresplash: "spl", hta: "hta", "java-archive": "jar", "java-serialized-object": "ser", "java-vm": "class", javascript: "js", m3g: "m3g", "mac-binhex40": "hqx", mathematica: ["nb", "ma", "mb"], msaccess: "mdb", msword: ["doc", "dot"], mxf: "mxf", oda: "oda", ogg: "ogx", pdf: "pdf", "pgp-keys": "key", "pgp-signature": ["asc", "sig"], "pics-rules": "prf", postscript: ["ps", "ai", "eps", "epsi", "epsf", "eps2", "eps3"], rar: "rar", "rdf+xml": "rdf", "rss+xml": "rss", rtf: "rtf", smil: ["smi", "smil"], "xhtml+xml": ["xhtml", "xht"], xml: ["xml", "xsl", "xsd"], "xspf+xml": "xspf", zip: "zip", "vnd.android.package-archive": "apk", "vnd.cinderella": "cdy", "vnd.google-earth.kml+xml": "kml", "vnd.google-earth.kmz": "kmz", "vnd.mozilla.xul+xml": "xul", "vnd.ms-excel": ["xls", "xlb", "xlt", "xlm", "xla", "xlc", "xlw"], "vnd.ms-pki.seccat": "cat", "vnd.ms-pki.stl": "stl", "vnd.ms-powerpoint": ["ppt", "pps", "pot"], "vnd.oasis.opendocument.chart": "odc", "vnd.oasis.opendocument.database": "odb", "vnd.oasis.opendocument.formula": "odf", "vnd.oasis.opendocument.graphics": "odg", "vnd.oasis.opendocument.graphics-template": "otg", "vnd.oasis.opendocument.image": "odi", "vnd.oasis.opendocument.presentation": "odp", "vnd.oasis.opendocument.presentation-template": "otp", "vnd.oasis.opendocument.spreadsheet": "ods", "vnd.oasis.opendocument.spreadsheet-template": "ots", "vnd.oasis.opendocument.text": "odt", "vnd.oasis.opendocument.text-master": "odm", "vnd.oasis.opendocument.text-template": "ott", "vnd.oasis.opendocument.text-web": "oth", "vnd.openxmlformats-officedocument.spreadsheetml.sheet": "xlsx", "vnd.openxmlformats-officedocument.spreadsheetml.template": "xltx", "vnd.openxmlformats-officedocument.presentationml.presentation": "pptx", "vnd.openxmlformats-officedocument.presentationml.slideshow": "ppsx", "vnd.openxmlformats-officedocument.presentationml.template": "potx", "vnd.openxmlformats-officedocument.wordprocessingml.document": "docx", "vnd.openxmlformats-officedocument.wordprocessingml.template": "dotx", "vnd.smaf": "mmf", "vnd.stardivision.calc": "sdc", "vnd.stardivision.chart": "sds", "vnd.stardivision.draw": "sda", "vnd.stardivision.impress": "sdd", "vnd.stardivision.math": ["sdf", "smf"], "vnd.stardivision.writer": ["sdw", "vor"], "vnd.stardivision.writer-global": "sgl", "vnd.sun.xml.calc": "sxc", "vnd.sun.xml.calc.template": "stc", "vnd.sun.xml.draw": "sxd", "vnd.sun.xml.draw.template": "std", "vnd.sun.xml.impress": "sxi", "vnd.sun.xml.impress.template": "sti", "vnd.sun.xml.math": "sxm", "vnd.sun.xml.writer": "sxw", "vnd.sun.xml.writer.global": "sxg", "vnd.sun.xml.writer.template": "stw", "vnd.symbian.install": ["sis", "sisx"], "vnd.visio": ["vsd", "vst", "vss", "vsw"], "vnd.wap.wbxml": "wbxml", "vnd.wap.wmlc": "wmlc", "vnd.wap.wmlscriptc": "wmlsc", "vnd.wordperfect": "wpd", "vnd.wordperfect5.1": "wp5", "x-123": "wk", "x-7z-compressed": "7z", "x-abiword": "abw", "x-apple-diskimage": "dmg", "x-bcpio": "bcpio", "x-bittorrent": "torrent", "x-cbr": ["cbr", "cba", "cbt", "cb7"], "x-cbz": "cbz", "x-cdf": ["cdf", "cda"], "x-cdlink": "vcd", "x-chess-pgn": "pgn", "x-cpio": "cpio", "x-csh": "csh", "x-debian-package": ["deb", "udeb"], "x-director": ["dcr", "dir", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "x-dms": "dms", "x-doom": "wad", "x-dvi": "dvi", "x-httpd-eruby": "rhtml", "x-font": "pcf.Z", "x-freemind": "mm", "x-gnumeric": "gnumeric", "x-go-sgf": "sgf", "x-graphing-calculator": "gcf", "x-gtar": ["gtar", "taz"], "x-hdf": "hdf", "x-httpd-php": ["phtml", "pht", "php"], "x-httpd-php-source": "phps", "x-httpd-php3": "php3", "x-httpd-php3-preprocessed": "php3p", "x-httpd-php4": "php4", "x-httpd-php5": "php5", "x-ica": "ica", "x-info": "info", "x-internet-signup": ["ins", "isp"], "x-iphone": "iii", "x-iso9660-image": "iso", "x-java-jnlp-file": "jnlp", "x-jmol": "jmz", "x-killustrator": "kil", "x-koan": ["skp", "skd", "skt", "skm"], "x-kpresenter": ["kpr", "kpt"], "x-kword": ["kwd", "kwt"], "x-latex": "latex", "x-lha": "lha", "x-lyx": "lyx", "x-lzh": "lzh", "x-lzx": "lzx", "x-maker": ["frm", "maker", "frame", "fm", "fb", "book", "fbdoc"], "x-ms-wmd": "wmd", "x-ms-wmz": "wmz", "x-msdos-program": ["com", "exe", "bat", "dll"], "x-msi": "msi", "x-netcdf": ["nc", "cdf"], "x-ns-proxy-autoconfig": ["pac", "dat"], "x-nwc": "nwc", "x-object": "o", "x-oz-application": "oza", "x-pkcs7-certreqresp": "p7r", "x-python-code": ["pyc", "pyo"], "x-qgis": ["qgs", "shp", "shx"], "x-quicktimeplayer": "qtl", "x-redhat-package-manager": "rpm", "x-ruby": "rb", "x-sh": "sh", "x-shar": "shar", "x-shockwave-flash": ["swf", "swfl"], "x-silverlight": "scr", "x-stuffit": "sit", "x-sv4cpio": "sv4cpio", "x-sv4crc": "sv4crc", "x-tar": "tar", "x-tcl": "tcl", "x-tex-gf": "gf", "x-tex-pk": "pk", "x-texinfo": ["texinfo", "texi"], "x-trash": ["~", "%", "bak", "old", "sik"], "x-troff": ["t", "tr", "roff"], "x-troff-man": "man", "x-troff-me": "me", "x-troff-ms": "ms", "x-ustar": "ustar", "x-wais-source": "src", "x-wingz": "wz", "x-x509-ca-cert": ["crt", "der", "cer"], "x-xcf": "xcf", "x-xfig": "fig", "x-xpinstall": "xpi", applixware: "aw", "atomsvc+xml": "atomsvc", "ccxml+xml": "ccxml", "cdmi-capability": "cdmia", "cdmi-container": "cdmic", "cdmi-domain": "cdmid", "cdmi-object": "cdmio", "cdmi-queue": "cdmiq", "docbook+xml": "dbk", "dssc+der": "dssc", "dssc+xml": "xdssc", "emma+xml": "emma", "epub+zip": "epub", exi: "exi", "font-tdpfr": "pfr", "gml+xml": "gml", "gpx+xml": "gpx", gxf: "gxf", hyperstudio: "stk", "inkml+xml": ["ink", "inkml"], ipfix: "ipfix", json: "json", "jsonml+json": "jsonml", "lost+xml": "lostxml", "mads+xml": "mads", marc: "mrc", "marcxml+xml": "mrcx", "mathml+xml": "mathml", mbox: "mbox", "mediaservercontrol+xml": "mscml", "metalink+xml": "metalink", "metalink4+xml": "meta4", "mets+xml": "mets", "mods+xml": "mods", mp21: ["m21", "mp21"], mp4: "mp4s", "oebps-package+xml": "opf", "omdoc+xml": "omdoc", onenote: ["onetoc", "onetoc2", "onetmp", "onepkg"], oxps: "oxps", "patch-ops-error+xml": "xer", "pgp-encrypted": "pgp", pkcs10: "p10", "pkcs7-mime": ["p7m", "p7c"], "pkcs7-signature": "p7s", pkcs8: "p8", "pkix-attr-cert": "ac", "pkix-crl": "crl", "pkix-pkipath": "pkipath", pkixcmp: "pki", "pls+xml": "pls", "prs.cww": "cww", "pskc+xml": "pskcxml", "reginfo+xml": "rif", "relax-ng-compact-syntax": "rnc", "resource-lists+xml": "rl", "resource-lists-diff+xml": "rld", "rls-services+xml": "rs", "rpki-ghostbusters": "gbr", "rpki-manifest": "mft", "rpki-roa": "roa", "rsd+xml": "rsd", "sbml+xml": "sbml", "scvp-cv-request": "scq", "scvp-cv-response": "scs", "scvp-vp-request": "spq", "scvp-vp-response": "spp", sdp: "sdp", "set-payment-initiation": "setpay", "set-registration-initiation": "setreg", "shf+xml": "shf", "sparql-query": "rq", "sparql-results+xml": "srx", srgs: "gram", "srgs+xml": "grxml", "sru+xml": "sru", "ssdl+xml": "ssdl", "ssml+xml": "ssml", "tei+xml": ["tei", "teicorpus"], "thraud+xml": "tfi", "timestamped-data": "tsd", "vnd.3gpp.pic-bw-large": "plb", "vnd.3gpp.pic-bw-small": "psb", "vnd.3gpp.pic-bw-var": "pvb", "vnd.3gpp2.tcap": "tcap", "vnd.3m.post-it-notes": "pwn", "vnd.accpac.simply.aso": "aso", "vnd.accpac.simply.imp": "imp", "vnd.acucobol": "acu", "vnd.acucorp": ["atc", "acutc"], "vnd.adobe.air-application-installer-package+zip": "air", "vnd.adobe.formscentral.fcdt": "fcdt", "vnd.adobe.fxp": ["fxp", "fxpl"], "vnd.adobe.xdp+xml": "xdp", "vnd.adobe.xfdf": "xfdf", "vnd.ahead.space": "ahead", "vnd.airzip.filesecure.azf": "azf", "vnd.airzip.filesecure.azs": "azs", "vnd.amazon.ebook": "azw", "vnd.americandynamics.acc": "acc", "vnd.amiga.ami": "ami", "vnd.anser-web-certificate-issue-initiation": "cii", "vnd.anser-web-funds-transfer-initiation": "fti", "vnd.antix.game-component": "atx", "vnd.apple.installer+xml": "mpkg", "vnd.apple.mpegurl": "m3u8", "vnd.aristanetworks.swi": "swi", "vnd.astraea-software.iota": "iota", "vnd.audiograph": "aep", "vnd.blueice.multipass": "mpm", "vnd.bmi": "bmi", "vnd.businessobjects": "rep", "vnd.chemdraw+xml": "cdxml", "vnd.chipnuts.karaoke-mmd": "mmd", "vnd.claymore": "cla", "vnd.cloanto.rp9": "rp9", "vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "vnd.cluetrust.cartomobile-config": "c11amc", "vnd.cluetrust.cartomobile-config-pkg": "c11amz", "vnd.commonspace": "csp", "vnd.contact.cmsg": "cdbcmsg", "vnd.cosmocaller": "cmc", "vnd.crick.clicker": "clkx", "vnd.crick.clicker.keyboard": "clkk", "vnd.crick.clicker.palette": "clkp", "vnd.crick.clicker.template": "clkt", "vnd.crick.clicker.wordbank": "clkw", "vnd.criticaltools.wbs+xml": "wbs", "vnd.ctc-posml": "pml", "vnd.cups-ppd": "ppd", "vnd.curl.car": "car", "vnd.curl.pcurl": "pcurl", "vnd.dart": "dart", "vnd.data-vision.rdz": "rdz", "vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "vnd.dece.ttml+xml": ["uvt", "uvvt"], "vnd.dece.unspecified": ["uvx", "uvvx"], "vnd.dece.zip": ["uvz", "uvvz"], "vnd.denovo.fcselayout-link": "fe_launch", "vnd.dna": "dna", "vnd.dolby.mlp": "mlp", "vnd.dpgraph": "dpg", "vnd.dreamfactory": "dfac", "vnd.ds-keypoint": "kpxx", "vnd.dvb.ait": "ait", "vnd.dvb.service": "svc", "vnd.dynageo": "geo", "vnd.ecowin.chart": "mag", "vnd.enliven": "nml", "vnd.epson.esf": "esf", "vnd.epson.msf": "msf", "vnd.epson.quickanime": "qam", "vnd.epson.salt": "slt", "vnd.epson.ssf": "ssf", "vnd.eszigno3+xml": ["es3", "et3"], "vnd.ezpix-album": "ez2", "vnd.ezpix-package": "ez3", "vnd.fdf": "fdf", "vnd.fdsn.mseed": "mseed", "vnd.fdsn.seed": ["seed", "dataless"], "vnd.flographit": "gph", "vnd.fluxtime.clip": "ftc", "vnd.framemaker": ["fm", "frame", "maker", "book"], "vnd.frogans.fnc": "fnc", "vnd.frogans.ltf": "ltf", "vnd.fsc.weblaunch": "fsc", "vnd.fujitsu.oasys": "oas", "vnd.fujitsu.oasys2": "oa2", "vnd.fujitsu.oasys3": "oa3", "vnd.fujitsu.oasysgp": "fg5", "vnd.fujitsu.oasysprs": "bh2", "vnd.fujixerox.ddd": "ddd", "vnd.fujixerox.docuworks": "xdw", "vnd.fujixerox.docuworks.binder": "xbd", "vnd.fuzzysheet": "fzs", "vnd.genomatix.tuxedo": "txd", "vnd.geogebra.file": "ggb", "vnd.geogebra.tool": "ggt", "vnd.geometry-explorer": ["gex", "gre"], "vnd.geonext": "gxt", "vnd.geoplan": "g2w", "vnd.geospace": "g3w", "vnd.gmx": "gmx", "vnd.grafeq": ["gqf", "gqs"], "vnd.groove-account": "gac", "vnd.groove-help": "ghf", "vnd.groove-identity-message": "gim", "vnd.groove-injector": "grv", "vnd.groove-tool-message": "gtm", "vnd.groove-tool-template": "tpl", "vnd.groove-vcard": "vcg", "vnd.hal+xml": "hal", "vnd.handheld-entertainment+xml": "zmm", "vnd.hbci": "hbci", "vnd.hhe.lesson-player": "les", "vnd.hp-hpgl": "hpgl", "vnd.hp-hpid": "hpid", "vnd.hp-hps": "hps", "vnd.hp-jlyt": "jlt", "vnd.hp-pcl": "pcl", "vnd.hp-pclxl": "pclxl", "vnd.hydrostatix.sof-data": "sfd-hdstx", "vnd.ibm.minipay": "mpy", "vnd.ibm.modcap": ["afp", "listafp", "list3820"], "vnd.ibm.rights-management": "irm", "vnd.ibm.secure-container": "sc", "vnd.iccprofile": ["icc", "icm"], "vnd.igloader": "igl", "vnd.immervision-ivp": "ivp", "vnd.immervision-ivu": "ivu", "vnd.insors.igm": "igm", "vnd.intercon.formnet": ["xpw", "xpx"], "vnd.intergeo": "i2g", "vnd.intu.qbo": "qbo", "vnd.intu.qfx": "qfx", "vnd.ipunplugged.rcprofile": "rcprofile", "vnd.irepository.package+xml": "irp", "vnd.is-xpr": "xpr", "vnd.isac.fcs": "fcs", "vnd.jam": "jam", "vnd.jcp.javame.midlet-rms": "rms", "vnd.jisp": "jisp", "vnd.joost.joda-archive": "joda", "vnd.kahootz": ["ktz", "ktr"], "vnd.kde.karbon": "karbon", "vnd.kde.kchart": "chrt", "vnd.kde.kformula": "kfo", "vnd.kde.kivio": "flw", "vnd.kde.kontour": "kon", "vnd.kde.kpresenter": ["kpr", "kpt"], "vnd.kde.kspread": "ksp", "vnd.kde.kword": ["kwd", "kwt"], "vnd.kenameaapp": "htke", "vnd.kidspiration": "kia", "vnd.kinar": ["kne", "knp"], "vnd.koan": ["skp", "skd", "skt", "skm"], "vnd.kodak-descriptor": "sse", "vnd.las.las+xml": "lasxml", "vnd.llamagraphics.life-balance.desktop": "lbd", "vnd.llamagraphics.life-balance.exchange+xml": "lbe", "vnd.lotus-1-2-3": "123", "vnd.lotus-approach": "apr", "vnd.lotus-freelance": "pre", "vnd.lotus-notes": "nsf", "vnd.lotus-organizer": "org", "vnd.lotus-screencam": "scm", "vnd.lotus-wordpro": "lwp", "vnd.macports.portpkg": "portpkg", "vnd.mcd": "mcd", "vnd.medcalcdata": "mc1", "vnd.mediastation.cdkey": "cdkey", "vnd.mfer": "mwf", "vnd.mfmp": "mfm", "vnd.micrografx.flo": "flo", "vnd.micrografx.igx": "igx", "vnd.mif": "mif", "vnd.mobius.daf": "daf", "vnd.mobius.dis": "dis", "vnd.mobius.mbk": "mbk", "vnd.mobius.mqy": "mqy", "vnd.mobius.msl": "msl", "vnd.mobius.plc": "plc", "vnd.mobius.txf": "txf", "vnd.mophun.application": "mpn", "vnd.mophun.certificate": "mpc", "vnd.ms-artgalry": "cil", "vnd.ms-cab-compressed": "cab", "vnd.ms-excel.addin.macroenabled.12": "xlam", "vnd.ms-excel.sheet.binary.macroenabled.12": "xlsb", "vnd.ms-excel.sheet.macroenabled.12": "xlsm", "vnd.ms-excel.template.macroenabled.12": "xltm", "vnd.ms-fontobject": "eot", "vnd.ms-htmlhelp": "chm", "vnd.ms-ims": "ims", "vnd.ms-lrm": "lrm", "vnd.ms-officetheme": "thmx", "vnd.ms-powerpoint.addin.macroenabled.12": "ppam", "vnd.ms-powerpoint.presentation.macroenabled.12": "pptm", "vnd.ms-powerpoint.slide.macroenabled.12": "sldm", "vnd.ms-powerpoint.slideshow.macroenabled.12": "ppsm", "vnd.ms-powerpoint.template.macroenabled.12": "potm", "vnd.ms-project": ["mpp", "mpt"], "vnd.ms-word.document.macroenabled.12": "docm", "vnd.ms-word.template.macroenabled.12": "dotm", "vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "vnd.ms-wpl": "wpl", "vnd.ms-xpsdocument": "xps", "vnd.mseq": "mseq", "vnd.musician": "mus", "vnd.muvee.style": "msty", "vnd.mynfc": "taglet", "vnd.neurolanguage.nlu": "nlu", "vnd.nitf": ["ntf", "nitf"], "vnd.noblenet-directory": "nnd", "vnd.noblenet-sealer": "nns", "vnd.noblenet-web": "nnw", "vnd.nokia.n-gage.data": "ngdat", "vnd.nokia.n-gage.symbian.install": "n-gage", "vnd.nokia.radio-preset": "rpst", "vnd.nokia.radio-presets": "rpss", "vnd.novadigm.edm": "edm", "vnd.novadigm.edx": "edx", "vnd.novadigm.ext": "ext", "vnd.oasis.opendocument.chart-template": "otc", "vnd.oasis.opendocument.formula-template": "odft", "vnd.oasis.opendocument.image-template": "oti", "vnd.olpc-sugar": "xo", "vnd.oma.dd2+xml": "dd2", "vnd.openofficeorg.extension": "oxt", "vnd.openxmlformats-officedocument.presentationml.slide": "sldx", "vnd.osgeo.mapguide.package": "mgp", "vnd.osgi.dp": "dp", "vnd.osgi.subsystem": "esa", "vnd.palm": ["pdb", "pqa", "oprc"], "vnd.pawaafile": "paw", "vnd.pg.format": "str", "vnd.pg.osasli": "ei6", "vnd.picsel": "efif", "vnd.pmi.widget": "wg", "vnd.pocketlearn": "plf", "vnd.powerbuilder6": "pbd", "vnd.previewsystems.box": "box", "vnd.proteus.magazine": "mgz", "vnd.publishare-delta-tree": "qps", "vnd.pvi.ptid1": "ptid", "vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "vnd.realvnc.bed": "bed", "vnd.recordare.musicxml": "mxl", "vnd.recordare.musicxml+xml": "musicxml", "vnd.rig.cryptonote": "cryptonote", "vnd.rn-realmedia": "rm", "vnd.rn-realmedia-vbr": "rmvb", "vnd.route66.link66+xml": "link66", "vnd.sailingtracker.track": "st", "vnd.seemail": "see", "vnd.sema": "sema", "vnd.semd": "semd", "vnd.semf": "semf", "vnd.shana.informed.formdata": "ifm", "vnd.shana.informed.formtemplate": "itp", "vnd.shana.informed.interchange": "iif", "vnd.shana.informed.package": "ipk", "vnd.simtech-mindmapper": ["twd", "twds"], "vnd.smart.teacher": "teacher", "vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "vnd.spotfire.dxp": "dxp", "vnd.spotfire.sfs": "sfs", "vnd.stepmania.package": "smzip", "vnd.stepmania.stepchart": "sm", "vnd.sus-calendar": ["sus", "susp"], "vnd.svd": "svd", "vnd.syncml+xml": "xsm", "vnd.syncml.dm+wbxml": "bdm", "vnd.syncml.dm+xml": "xdm", "vnd.tao.intent-module-archive": "tao", "vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "vnd.tmobile-livetv": "tmo", "vnd.trid.tpt": "tpt", "vnd.triscape.mxs": "mxs", "vnd.trueapp": "tra", "vnd.ufdl": ["ufd", "ufdl"], "vnd.uiq.theme": "utz", "vnd.umajin": "umj", "vnd.unity": "unityweb", "vnd.uoml+xml": "uoml", "vnd.vcx": "vcx", "vnd.visionary": "vis", "vnd.vsf": "vsf", "vnd.webturbo": "wtb", "vnd.wolfram.player": "nbp", "vnd.wqd": "wqd", "vnd.wt.stf": "stf", "vnd.xara": "xar", "vnd.xfdl": "xfdl", "vnd.yamaha.hv-dic": "hvd", "vnd.yamaha.hv-script": "hvs", "vnd.yamaha.hv-voice": "hvp", "vnd.yamaha.openscoreformat": "osf", "vnd.yamaha.openscoreformat.osfpvg+xml": "osfpvg", "vnd.yamaha.smaf-audio": "saf", "vnd.yamaha.smaf-phrase": "spf", "vnd.yellowriver-custom-menu": "cmp", "vnd.zul": ["zir", "zirz"], "vnd.zzazz.deck+xml": "zaz", "voicexml+xml": "vxml", widget: "wgt", winhlp: "hlp", "wsdl+xml": "wsdl", "wspolicy+xml": "wspolicy", "x-ace-compressed": "ace", "x-authorware-bin": ["aab", "x32", "u32", "vox"], "x-authorware-map": "aam", "x-authorware-seg": "aas", "x-blorb": ["blb", "blorb"], "x-bzip": "bz", "x-bzip2": ["bz2", "boz"], "x-cfs-compressed": "cfs", "x-chat": "chat", "x-conference": "nsc", "x-dgc-compressed": "dgc", "x-dtbncx+xml": "ncx", "x-dtbook+xml": "dtb", "x-dtbresource+xml": "res", "x-eva": "eva", "x-font-bdf": "bdf", "x-font-ghostscript": "gsf", "x-font-linux-psf": "psf", "x-font-otf": "otf", "x-font-pcf": "pcf", "x-font-snf": "snf", "x-font-ttf": ["ttf", "ttc"], "x-font-type1": ["pfa", "pfb", "pfm", "afm"], "x-font-woff": "woff", "x-freearc": "arc", "x-gca-compressed": "gca", "x-glulx": "ulx", "x-gramps-xml": "gramps", "x-install-instructions": "install", "x-lzh-compressed": ["lzh", "lha"], "x-mie": "mie", "x-mobipocket-ebook": ["prc", "mobi"], "x-ms-application": "application", "x-ms-shortcut": "lnk", "x-ms-xbap": "xbap", "x-msbinder": "obd", "x-mscardfile": "crd", "x-msclip": "clp", "x-msdownload": ["exe", "dll", "com", "bat", "msi"], "x-msmediaview": ["mvb", "m13", "m14"], "x-msmetafile": ["wmf", "wmz", "emf", "emz"], "x-msmoney": "mny", "x-mspublisher": "pub", "x-msschedule": "scd", "x-msterminal": "trm", "x-mswrite": "wri", "x-nzb": "nzb", "x-pkcs12": ["p12", "pfx"], "x-pkcs7-certificates": ["p7b", "spc"], "x-research-info-systems": "ris", "x-silverlight-app": "xap", "x-sql": "sql", "x-stuffitx": "sitx", "x-subrip": "srt", "x-t3vm-image": "t3", "x-tads": "gam", "x-tex": "tex", "x-tex-tfm": "tfm", "x-tgif": "obj", "x-xliff+xml": "xlf", "x-xz": "xz", "x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "xaml+xml": "xaml", "xcap-diff+xml": "xdf", "xenc+xml": "xenc", "xml-dtd": "dtd", "xop+xml": "xop", "xproc+xml": "xpl", "xslt+xml": "xslt", "xv+xml": ["mxml", "xhvml", "xvml", "xvm"], yang: "yang", "yin+xml": "yin", envoy: "evy", fractals: "fif", "internet-property-stream": "acx", olescript: "axs", "vnd.ms-outlook": "msg", "vnd.ms-pkicertstore": "sst", "x-compress": "z", "x-compressed": "tgz", "x-gzip": "gz", "x-perfmon": ["pma", "pmc", "pml", "pmr", "pmw"], "x-pkcs7-mime": ["p7c", "p7m"], "ynd.ms-pkipko": "pko" }, audio: { amr: "amr", "amr-wb": "awb", annodex: "axa", basic: ["au", "snd"], flac: "flac", midi: ["mid", "midi", "kar", "rmi"], mpeg: ["mpga", "mpega", "mp2", "mp3", "m4a", "mp2a", "m2a", "m3a"], mpegurl: "m3u", ogg: ["oga", "ogg", "spx"], "prs.sid": "sid", "x-aiff": ["aif", "aiff", "aifc"], "x-gsm": "gsm", "x-ms-wma": "wma", "x-ms-wax": "wax", "x-pn-realaudio": "ram", "x-realaudio": "ra", "x-sd2": "sd2", "x-wav": "wav", adpcm: "adp", mp4: "mp4a", s3m: "s3m", silk: "sil", "vnd.dece.audio": ["uva", "uvva"], "vnd.digital-winds": "eol", "vnd.dra": "dra", "vnd.dts": "dts", "vnd.dts.hd": "dtshd", "vnd.lucent.voice": "lvp", "vnd.ms-playready.media.pya": "pya", "vnd.nuera.ecelp4800": "ecelp4800", "vnd.nuera.ecelp7470": "ecelp7470", "vnd.nuera.ecelp9600": "ecelp9600", "vnd.rip": "rip", webm: "weba", "x-aac": "aac", "x-caf": "caf", "x-matroska": "mka", "x-pn-realaudio-plugin": "rmp", xm: "xm", mid: ["mid", "rmi"] }, chemical: { "x-alchemy": "alc", "x-cache": ["cac", "cache"], "x-cache-csf": "csf", "x-cactvs-binary": ["cbin", "cascii", "ctab"], "x-cdx": "cdx", "x-chem3d": "c3d", "x-cif": "cif", "x-cmdf": "cmdf", "x-cml": "cml", "x-compass": "cpa", "x-crossfire": "bsd", "x-csml": ["csml", "csm"], "x-ctx": "ctx", "x-cxf": ["cxf", "cef"], "x-embl-dl-nucleotide": ["emb", "embl"], "x-gamess-input": ["inp", "gam", "gamin"], "x-gaussian-checkpoint": ["fch", "fchk"], "x-gaussian-cube": "cub", "x-gaussian-input": ["gau", "gjc", "gjf"], "x-gaussian-log": "gal", "x-gcg8-sequence": "gcg", "x-genbank": "gen", "x-hin": "hin", "x-isostar": ["istr", "ist"], "x-jcamp-dx": ["jdx", "dx"], "x-kinemage": "kin", "x-macmolecule": "mcm", "x-macromodel-input": ["mmd", "mmod"], "x-mdl-molfile": "mol", "x-mdl-rdfile": "rd", "x-mdl-rxnfile": "rxn", "x-mdl-sdfile": ["sd", "sdf"], "x-mdl-tgf": "tgf", "x-mmcif": "mcif", "x-mol2": "mol2", "x-molconn-Z": "b", "x-mopac-graph": "gpt", "x-mopac-input": ["mop", "mopcrt", "mpc", "zmt"], "x-mopac-out": "moo", "x-ncbi-asn1": "asn", "x-ncbi-asn1-ascii": ["prt", "ent"], "x-ncbi-asn1-binary": ["val", "aso"], "x-pdb": ["pdb", "ent"], "x-rosdal": "ros", "x-swissprot": "sw", "x-vamas-iso14976": "vms", "x-vmd": "vmd", "x-xtel": "xtel", "x-xyz": "xyz" }, image: { gif: "gif", ief: "ief", jpeg: ["jpeg", "jpg", "jpe"], pcx: "pcx", png: "png", "svg+xml": ["svg", "svgz"], tiff: ["tiff", "tif"], "vnd.djvu": ["djvu", "djv"], "vnd.wap.wbmp": "wbmp", "x-canon-cr2": "cr2", "x-canon-crw": "crw", "x-cmu-raster": "ras", "x-coreldraw": "cdr", "x-coreldrawpattern": "pat", "x-coreldrawtemplate": "cdt", "x-corelphotopaint": "cpt", "x-epson-erf": "erf", "x-icon": "ico", "x-jg": "art", "x-jng": "jng", "x-nikon-nef": "nef", "x-olympus-orf": "orf", "x-photoshop": "psd", "x-portable-anymap": "pnm", "x-portable-bitmap": "pbm", "x-portable-graymap": "pgm", "x-portable-pixmap": "ppm", "x-rgb": "rgb", "x-xbitmap": "xbm", "x-xpixmap": "xpm", "x-xwindowdump": "xwd", bmp: "bmp", cgm: "cgm", g3fax: "g3", ktx: "ktx", "prs.btif": "btif", sgi: "sgi", "vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "vnd.dwg": "dwg", "vnd.dxf": "dxf", "vnd.fastbidsheet": "fbs", "vnd.fpx": "fpx", "vnd.fst": "fst", "vnd.fujixerox.edmics-mmr": "mmr", "vnd.fujixerox.edmics-rlc": "rlc", "vnd.ms-modi": "mdi", "vnd.ms-photo": "wdp", "vnd.net-fpx": "npx", "vnd.xiff": "xif", webp: "webp", "x-3ds": "3ds", "x-cmx": "cmx", "x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "x-pict": ["pic", "pct"], "x-tga": "tga", "cis-cod": "cod", pipeg: "jfif" }, message: { rfc822: ["eml", "mime", "mht", "mhtml", "nws"] }, model: { iges: ["igs", "iges"], mesh: ["msh", "mesh", "silo"], vrml: ["wrl", "vrml"], "x3d+vrml": ["x3dv", "x3dvz"], "x3d+xml": ["x3d", "x3dz"], "x3d+binary": ["x3db", "x3dbz"], "vnd.collada+xml": "dae", "vnd.dwf": "dwf", "vnd.gdl": "gdl", "vnd.gtw": "gtw", "vnd.mts": "mts", "vnd.vtu": "vtu" }, text: { "cache-manifest": ["manifest", "appcache"], calendar: ["ics", "icz", "ifb"], css: "css", csv: "csv", h323: "323", html: ["html", "htm", "shtml", "stm"], iuls: "uls", mathml: "mml", plain: ["txt", "text", "brf", "conf", "def", "list", "log", "in", "bas"], richtext: "rtx", scriptlet: ["sct", "wsc"], texmacs: ["tm", "ts"], "tab-separated-values": "tsv", "vnd.sun.j2me.app-descriptor": "jad", "vnd.wap.wml": "wml", "vnd.wap.wmlscript": "wmls", "x-bibtex": "bib", "x-boo": "boo", "x-c++hdr": ["h++", "hpp", "hxx", "hh"], "x-c++src": ["c++", "cpp", "cxx", "cc"], "x-component": "htc", "x-dsrc": "d", "x-diff": ["diff", "patch"], "x-haskell": "hs", "x-java": "java", "x-literate-haskell": "lhs", "x-moc": "moc", "x-pascal": ["p", "pas"], "x-pcs-gcd": "gcd", "x-perl": ["pl", "pm"], "x-python": "py", "x-scala": "scala", "x-setext": "etx", "x-tcl": ["tcl", "tk"], "x-tex": ["tex", "ltx", "sty", "cls"], "x-vcalendar": "vcs", "x-vcard": "vcf", n3: "n3", "prs.lines.tag": "dsc", sgml: ["sgml", "sgm"], troff: ["t", "tr", "roff", "man", "me", "ms"], turtle: "ttl", "uri-list": ["uri", "uris", "urls"], vcard: "vcard", "vnd.curl": "curl", "vnd.curl.dcurl": "dcurl", "vnd.curl.scurl": "scurl", "vnd.curl.mcurl": "mcurl", "vnd.dvb.subtitle": "sub", "vnd.fly": "fly", "vnd.fmi.flexstor": "flx", "vnd.graphviz": "gv", "vnd.in3d.3dml": "3dml", "vnd.in3d.spot": "spot", "x-asm": ["s", "asm"], "x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "x-fortran": ["f", "for", "f77", "f90"], "x-opml": "opml", "x-nfo": "nfo", "x-sfv": "sfv", "x-uuencode": "uu", webviewhtml: "htt" }, video: { avif: ".avif", "3gpp": "3gp", annodex: "axv", dl: "dl", dv: ["dif", "dv"], fli: "fli", gl: "gl", mpeg: ["mpeg", "mpg", "mpe", "m1v", "m2v", "mp2", "mpa", "mpv2"], mp4: ["mp4", "mp4v", "mpg4"], quicktime: ["qt", "mov"], ogg: "ogv", "vnd.mpegurl": ["mxu", "m4u"], "x-flv": "flv", "x-la-asf": ["lsf", "lsx"], "x-mng": "mng", "x-ms-asf": ["asf", "asx", "asr"], "x-ms-wm": "wm", "x-ms-wmv": "wmv", "x-ms-wmx": "wmx", "x-ms-wvx": "wvx", "x-msvideo": "avi", "x-sgi-movie": "movie", "x-matroska": ["mpv", "mkv", "mk3d", "mks"], "3gpp2": "3g2", h261: "h261", h263: "h263", h264: "h264", jpeg: "jpgv", jpm: ["jpm", "jpgm"], mj2: ["mj2", "mjp2"], "vnd.dece.hd": ["uvh", "uvvh"], "vnd.dece.mobile": ["uvm", "uvvm"], "vnd.dece.pd": ["uvp", "uvvp"], "vnd.dece.sd": ["uvs", "uvvs"], "vnd.dece.video": ["uvv", "uvvv"], "vnd.dvb.file": "dvb", "vnd.fvt": "fvt", "vnd.ms-playready.media.pyv": "pyv", "vnd.uvvu.mp4": ["uvu", "uvvu"], "vnd.vivo": "viv", webm: "webm", "x-f4v": "f4v", "x-m4v": "m4v", "x-ms-vob": "vob", "x-smv": "smv" }, "x-conference": { "x-cooltalk": "ice" }, "x-world": { "x-vrml": ["vrm", "vrml", "wrl", "flr", "wrz", "xaf", "xof"] } }; (() => { const t = {}; for (const e in _t) if (_t.hasOwnProperty(e)) for (const n in _t[e]) if (_t[e].hasOwnProperty(n)) { const r = _t[e][n]; if ("string" == typeof r) t[r] = e + "/" + n; else for (let i = 0; i < r.length; i++)t[r[i]] = e + "/" + n } })(); const xt = []; for (let t = 0; t < 256; t++) { let e = t; for (let t = 0; t < 8; t++)1 & e ? e = e >>> 1 ^ 3988292384 : e >>>= 1; xt[t] = e } var kt = class { constructor(t) { this.crc = t || -1 } append(t) { let e = 0 | this.crc; for (let n = 0, r = 0 | t.length; n < r; n++)e = e >>> 8 ^ xt[255 & (e ^ t[n])]; this.crc = e } get() { return ~this.crc } }, Et = function (t) { if ("undefined" == typeof TextEncoder) { t = unescape(encodeURIComponent(t)); const e = new Uint8Array(t.length); for (let n = 0; n < e.length; n++)e[n] = t.charCodeAt(n); return e } return (new TextEncoder).encode(t) }; const At = { concat(t, e) { if (0 === t.length || 0 === e.length) return t.concat(e); const n = t[t.length - 1], r = At.getPartial(n); return 32 === r ? t.concat(e) : At._shiftRight(e, r, 0 | n, t.slice(0, t.length - 1)) }, bitLength(t) { const e = t.length; if (0 === e) return 0; const n = t[e - 1]; return 32 * (e - 1) + At.getPartial(n) }, clamp(t, e) { if (32 * t.length < e) return t; const n = (t = t.slice(0, Math.ceil(e / 32))).length; return e &= 31, n > 0 && e && (t[n - 1] = At.partial(e, t[n - 1] & 2147483648 >> e - 1, 1)), t }, partial(t, e, n) { return 32 === t ? e : (n ? 0 | e : e << 32 - t) + 1099511627776 * t }, getPartial(t) { return Math.round(t / 1099511627776) || 32 }, _shiftRight(t, e, n, r) { for (void 0 === r && (r = []); e >= 32; e -= 32)r.push(n), n = 0; if (0 === e) return r.concat(t); for (let i = 0; i < t.length; i++)r.push(n | t[i] >>> e), n = t[i] << 32 - e; const i = t.length ? t[t.length - 1] : 0, a = At.getPartial(i); return r.push(At.partial(e + a & 31, e + a > 32 ? n : r.pop(), 1)), r } }, St = { bytes: { fromBits(t) { const e = At.bitLength(t) / 8, n = new Uint8Array(e); let r; for (let i = 0; i < e; i++)0 == (3 & i) && (r = t[i / 4]), n[i] = r >>> 24, r <<= 8; return n }, toBits(t) { const e = []; let n, r = 0; for (n = 0; n < t.length; n++)r = r << 8 | t[n], 3 == (3 & n) && (e.push(r), r = 0); return 3 & n && e.push(At.partial(8 * (3 & n), r)), e } } }, Bt = { sha1: function (t) { t ? (this._h = t._h.slice(0), this._buffer = t._buffer.slice(0), this._length = t._length) : this.reset() } }; Bt.sha1.prototype = { blockSize: 512, reset: function () { const t = this; return t._h = this._init.slice(0), t._buffer = [], t._length = 0, t }, update: function (t) { const e = this; "string" == typeof t && (t = St.utf8String.toBits(t)); const n = e._buffer = At.concat(e._buffer, t), r = e._length, i = e._length = r + At.bitLength(t); if (i > 9007199254740991) throw new Error("Cannot hash more than 2^53 - 1 bits"); const a = new Uint32Array(n); let s = 0; for (let t = e.blockSize + r - (e.blockSize + r & e.blockSize - 1); t <= i; t += e.blockSize)e._block(a.subarray(16 * s, 16 * (s + 1))), s += 1; return n.splice(0, 16 * s), e }, finalize: function () { const t = this; let e = t._buffer; const n = t._h; e = At.concat(e, [At.partial(1, 1)]); for (let t = e.length + 2; 15 & t; t++)e.push(0); for (e.push(Math.floor(t._length / 4294967296)), e.push(0 | t._length); e.length;)t._block(e.splice(0, 16)); return t.reset(), n }, _init: [1732584193, 4023233417, 2562383102, 271733878, 3285377520], _key: [1518500249, 1859775393, 2400959708, 3395469782], _f: function (t, e, n, r) { return t <= 19 ? e & n | ~e & r : t <= 39 ? e ^ n ^ r : t <= 59 ? e & n | e & r | n & r : t <= 79 ? e ^ n ^ r : void 0 }, _S: function (t, e) { return e << t | e >>> 32 - t }, _block: function (t) { const e = this, n = e._h, r = Array(80); for (let e = 0; e < 16; e++)r[e] = t[e]; let i = n[0], a = n[1], s = n[2], o = n[3], c = n[4]; for (let t = 0; t <= 79; t++) { t >= 16 && (r[t] = e._S(1, r[t - 3] ^ r[t - 8] ^ r[t - 14] ^ r[t - 16])); const n = e._S(5, i) + e._f(t, a, s, o) + c + r[t] + e._key[Math.floor(t / 20)] | 0; c = o, o = s, s = e._S(30, a), a = i, i = n } n[0] = n[0] + i | 0, n[1] = n[1] + a | 0, n[2] = n[2] + s | 0, n[3] = n[3] + o | 0, n[4] = n[4] + c | 0 } }; const zt = { aes: class { constructor(t) { const e = this; e._tables = [[[], [], [], [], []], [[], [], [], [], []]], e._tables[0][0][0] || e._precompute(); const n = e._tables[0][4], r = e._tables[1], i = t.length; let a, s, o, c = 1; if (4 !== i && 6 !== i && 8 !== i) throw new Error("invalid aes key size"); for (e._key = [s = t.slice(0), o = []], a = i; a < 4 * i + 28; a++) { let t = s[a - 1]; (a % i == 0 || 8 === i && a % i == 4) && (t = n[t >>> 24] << 24 ^ n[t >> 16 & 255] << 16 ^ n[t >> 8 & 255] << 8 ^ n[255 & t], a % i == 0 && (t = t << 8 ^ t >>> 24 ^ c << 24, c = c << 1 ^ 283 * (c >> 7))), s[a] = s[a - i] ^ t } for (let t = 0; a; t++, a--) { const e = s[3 & t ? a : a - 4]; o[t] = a <= 4 || t < 4 ? e : r[0][n[e >>> 24]] ^ r[1][n[e >> 16 & 255]] ^ r[2][n[e >> 8 & 255]] ^ r[3][n[255 & e]] } } encrypt(t) { return this._crypt(t, 0) } decrypt(t) { return this._crypt(t, 1) } _precompute() { const t = this._tables[0], e = this._tables[1], n = t[4], r = e[4], i = [], a = []; let s, o, c, l; for (let t = 0; t < 256; t++)a[(i[t] = t << 1 ^ 283 * (t >> 7)) ^ t] = t; for (let f = s = 0; !n[f]; f ^= o || 1, s = a[s] || 1) { let a = s ^ s << 1 ^ s << 2 ^ s << 3 ^ s << 4; a = a >> 8 ^ 255 & a ^ 99, n[f] = a, r[a] = f, l = i[c = i[o = i[f]]]; let d = 16843009 * l ^ 65537 * c ^ 257 * o ^ 16843008 * f, u = 257 * i[a] ^ 16843008 * a; for (let n = 0; n < 4; n++)t[n][f] = u = u << 24 ^ u >>> 8, e[n][a] = d = d << 24 ^ d >>> 8 } for (let n = 0; n < 5; n++)t[n] = t[n].slice(0), e[n] = e[n].slice(0) } _crypt(t, e) { if (4 !== t.length) throw new Error("invalid aes block size"); const n = this._key[e], r = n.length / 4 - 2, i = [0, 0, 0, 0], a = this._tables[e], s = a[0], o = a[1], c = a[2], l = a[3], f = a[4]; let d, u, h, p = t[0] ^ n[0], g = t[e ? 3 : 1] ^ n[1], m = t[2] ^ n[2], b = t[e ? 1 : 3] ^ n[3], w = 4; for (let t = 0; t < r; t++)d = s[p >>> 24] ^ o[g >> 16 & 255] ^ c[m >> 8 & 255] ^ l[255 & b] ^ n[w], u = s[g >>> 24] ^ o[m >> 16 & 255] ^ c[b >> 8 & 255] ^ l[255 & p] ^ n[w + 1], h = s[m >>> 24] ^ o[b >> 16 & 255] ^ c[p >> 8 & 255] ^ l[255 & g] ^ n[w + 2], b = s[b >>> 24] ^ o[p >> 16 & 255] ^ c[g >> 8 & 255] ^ l[255 & m] ^ n[w + 3], w += 4, p = d, g = u, m = h; for (let t = 0; t < 4; t++)i[e ? 3 & -t : t] = f[p >>> 24] << 24 ^ f[g >> 16 & 255] << 16 ^ f[m >> 8 & 255] << 8 ^ f[255 & b] ^ n[w++], d = p, p = g, g = m, m = b, b = d; return i } } }, Ct = { getRandomValues(t) { const e = new Uint32Array(t.buffer), n = t => { let e = 987654321; const n = 4294967295; return function () { e = 36969 * (65535 & e) + (e >> 16) & n; return (((e << 16) + (t = 18e3 * (65535 & t) + (t >> 16) & n) & n) / 4294967296 + .5) * (Math.random() > .5 ? 1 : -1) } }; for (let r, i = 0; i < t.length; i += 4) { const t = n(4294967296 * (r || Math.random())); r = 987654071 * t(), e[i / 4] = 4294967296 * t() | 0 } return t } }, Ut = { ctrGladman: class { constructor(t, e) { this._prf = t, this._initIv = e, this._iv = e } reset() { this._iv = this._initIv } update(t) { return this.calculate(this._prf, t, this._iv) } incWord(t) { if (255 == (t >> 24 & 255)) { let e = t >> 16 & 255, n = t >> 8 & 255, r = 255 & t; 255 === e ? (e = 0, 255 === n ? (n = 0, 255 === r ? r = 0 : ++r) : ++n) : ++e, t = 0, t += e << 16, t += n << 8, t += r } else t += 1 << 24; return t } incCounter(t) { 0 === (t[0] = this.incWord(t[0])) && (t[1] = this.incWord(t[1])) } calculate(t, e, n) { let r; if (!(r = e.length)) return []; const i = At.bitLength(e); for (let i = 0; i < r; i += 4) { this.incCounter(n); const r = t.encrypt(n); e[i] ^= r[0], e[i + 1] ^= r[1], e[i + 2] ^= r[2], e[i + 3] ^= r[3] } return At.clamp(e, i) } } }, It = { importKey(t) { return new It.hmacSha1(St.bytes.toBits(t)) }, pbkdf2(t, e, n, r) { if (n = n || 1e4, r < 0 || n < 0) throw new Error("invalid params to pbkdf2"); const i = 1 + (r >> 5) << 2; let a, s, o, c, l; const f = new ArrayBuffer(i), d = new DataView(f); let u = 0; const h = At; for (e = St.bytes.toBits(e), l = 1; u < (i || 1); l++) { for (a = s = t.encrypt(h.concat(e, [l])), o = 1; o < n; o++)for (s = t.encrypt(s), c = 0; c < s.length; c++)a[c] ^= s[c]; for (o = 0; u < (i || 1) && o < a.length; o++)d.setInt32(u, a[o]), u += 4 } return f.slice(0, r / 8) }, hmacSha1: class { constructor(t) { const e = this, n = e._hash = Bt.sha1, r = [[], []], i = n.prototype.blockSize / 32; e._baseHash = [new n, new n], t.length > i && (t = n.hash(t)); for (let e = 0; e < i; e++)r[0][e] = 909522486 ^ t[e], r[1][e] = 1549556828 ^ t[e]; e._baseHash[0].update(r[0]), e._baseHash[1].update(r[1]), e._resultHash = new n(e._baseHash[0]) } reset() { const t = this; t._resultHash = new t._hash(t._baseHash[0]), t._updated = !1 } update(t) { this._updated = !0, this._resultHash.update(t) } digest() { const t = this, e = t._resultHash.finalize(), n = new t._hash(t._baseHash[1]).update(e).finalize(); return t.reset(), n } encrypt(t) { if (this._updated) throw new Error("encrypt on already updated hmac called!"); return this.update(t), this.digest(t) } } }, Tt = "Invalid pasword", Nt = 16, jt = "raw", Ot = { name: "PBKDF2" }, Dt = Object.assign({ hash: { name: "HMAC" } }, Ot), Mt = Object.assign({ iterations: 1e3, hash: { name: "SHA-1" } }, Ot), Rt = ["deriveBits"], Lt = [8, 12, 16], Ft = [16, 24, 32], Pt = 10, Vt = [0, 0, 0, 0], Zt = "undefined" != typeof crypto, qt = Zt && void 0 !== crypto.subtle, Ht = St.bytes, Wt = zt.aes, $t = Ut.ctrGladman, Qt = It.hmacSha1; class Gt { constructor(t, e, n) { Object.assign(this, { password: t, signed: e, strength: n - 1, pendingInput: new Uint8Array(0) }) } async append(t) { const e = this; if (e.password) { const n = te(t, 0, Lt[e.strength] + 2); await async function (t, e, n) { await Xt(t, n, te(e, 0, Lt[t.strength])); const r = te(e, Lt[t.strength]), i = t.keys.passwordVerification; if (i[0] != r[0] || i[1] != r[1]) throw new Error(Tt) }(e, n, e.password), e.password = null, e.aesCtrGladman = new $t(new Wt(e.keys.key), Array.from(Vt)), e.hmac = new Qt(e.keys.authentication), t = te(t, Lt[e.strength] + 2) } return Jt(e, t, new Uint8Array(t.length - Pt - (t.length - Pt) % Nt), 0, Pt, !0) } flush() { const t = this, e = t.pendingInput, n = te(e, 0, e.length - Pt), r = te(e, e.length - Pt); let i = new Uint8Array(0); if (n.length) { const e = Ht.toBits(n); t.hmac.update(e); const r = t.aesCtrGladman.update(e); i = Ht.fromBits(r) } let a = !0; if (t.signed) { const e = te(Ht.fromBits(t.hmac.digest()), 0, Pt); for (let t = 0; t < Pt; t++)e[t] != r[t] && (a = !1) } return { valid: a, data: i } } } class Kt { constructor(t, e) { Object.assign(this, { password: t, strength: e - 1, pendingInput: new Uint8Array(0) }) } async append(t) { const e = this; let n = new Uint8Array(0); e.password && (n = await async function (t, e) { const n = (r = new Uint8Array(Lt[t.strength]), Zt && "function" == typeof crypto.getRandomValues ? crypto.getRandomValues(r) : Ct.getRandomValues(r)); var r; return await Xt(t, e, n), Yt(n, t.keys.passwordVerification) }(e, e.password), e.password = null, e.aesCtrGladman = new $t(new Wt(e.keys.key), Array.from(Vt)), e.hmac = new Qt(e.keys.authentication)); const r = new Uint8Array(n.length + t.length - t.length % Nt); return r.set(n, 0), Jt(e, t, r, n.length, 0) } flush() { const t = this; let e = new Uint8Array(0); if (t.pendingInput.length) { const n = t.aesCtrGladman.update(Ht.toBits(t.pendingInput)); t.hmac.update(n), e = Ht.fromBits(n) } const n = te(Ht.fromBits(t.hmac.digest()), 0, Pt); return { data: Yt(e, n), signature: n } } } function Jt(t, e, n, r, i, a) { const s = e.length - i; let o; for (t.pendingInput.length && (e = Yt(t.pendingInput, e), n = function (t, e) { if (e && e > t.length) { const n = t; (t = new Uint8Array(e)).set(n, 0) } return t }(n, s - s % Nt)), o = 0; o <= s - Nt; o += Nt) { const i = Ht.toBits(te(e, o, o + Nt)); a && t.hmac.update(i); const s = t.aesCtrGladman.update(i); a || t.hmac.update(s), n.set(Ht.fromBits(s), o + r) } return t.pendingInput = te(e, o), n } async function Xt(t, e, n) { const r = Et(e), i = await function (t, e, n, r, i) { return Zt && qt && "function" == typeof crypto.subtle.importKey ? crypto.subtle.importKey(t, e, n, r, i) : It.importKey(e) }(jt, r, Dt, !1, Rt), a = await async function (t, e, n) { return Zt && qt && "function" == typeof crypto.subtle.deriveBits ? await crypto.subtle.deriveBits(t, e, n) : It.pbkdf2(e, t.salt, Mt.iterations, n) }(Object.assign({ salt: n }, Mt), i, 8 * (2 * Ft[t.strength] + 2)), s = new Uint8Array(a); t.keys = { key: Ht.toBits(te(s, 0, Ft[t.strength])), authentication: Ht.toBits(te(s, Ft[t.strength], 2 * Ft[t.strength])), passwordVerification: te(s, 2 * Ft[t.strength]) } } function Yt(t, e) { let n = t; return t.length + e.length && (n = new Uint8Array(t.length + e.length), n.set(t, 0), n.set(e, t.length)), n } function te(t, e, n) { return t.subarray(e, n) } const ee = 12; class ne { constructor(t, e) { Object.assign(this, { password: t, passwordVerification: e }), se(this, t) } append(t) { const e = this; if (e.password) { const n = ie(e, t.subarray(0, ee)); if (e.password = null, n[11] != e.passwordVerification) throw new Error(Tt); t = t.subarray(ee) } return ie(e, t) } flush() { return { valid: !0, data: new Uint8Array(0) } } } class re { constructor(t, e) { Object.assign(this, { password: t, passwordVerification: e }), se(this, t) } append(t) { const e = this; let n, r; if (e.password) { e.password = null; const i = crypto.getRandomValues(new Uint8Array(ee)); i[11] = e.passwordVerification, n = new Uint8Array(t.length + i.length), n.set(ae(e, i), 0), r = ee } else n = new Uint8Array(t.length), r = 0; return n.set(ae(e, t), r), n } flush() { return { data: new Uint8Array(0) } } } function ie(t, e) { const n = new Uint8Array(e.length); for (let r = 0; r < e.length; r++)n[r] = ce(t) ^ e[r], oe(t, n[r]); return n } function ae(t, e) { const n = new Uint8Array(e.length); for (let r = 0; r < e.length; r++)n[r] = ce(t) ^ e[r], oe(t, e[r]); return n } function se(t, e) { t.keys = [305419896, 591751049, 878082192], t.crcKey0 = new kt(t.keys[0]), t.crcKey2 = new kt(t.keys[2]); for (let n = 0; n < e.length; n++)oe(t, e.charCodeAt(n)) } function oe(t, e) { t.crcKey0.append([e]), t.keys[0] = ~t.crcKey0.get(), t.keys[1] = fe(t.keys[1] + le(t.keys[0])), t.keys[1] = fe(Math.imul(t.keys[1], 134775813) + 1), t.crcKey2.append([t.keys[1] >>> 24]), t.keys[2] = ~t.crcKey2.get() } function ce(t) { const e = 2 | t.keys[2]; return le(Math.imul(e, 1 ^ e) >>> 8) } function le(t) { return 255 & t } function fe(t) { return 4294967295 & t } const de = "deflate", ue = "inflate", he = "Invalid signature"; class pe { constructor(t, { signature: e, password: n, signed: r, compressed: i, zipCrypto: a, passwordVerification: s, encryptionStrength: o }, { chunkSize: c }) { const l = Boolean(n); Object.assign(this, { signature: e, encrypted: l, signed: r, compressed: i, inflate: i && new t({ chunkSize: c }), crc32: r && new kt, zipCrypto: a, decrypt: l && a ? new ne(n, s) : new Gt(n, r, o) }) } async append(t) { const e = this; return e.encrypted && t.length && (t = await e.decrypt.append(t)), e.compressed && t.length && (t = await e.inflate.append(t)), (!e.encrypted || e.zipCrypto) && e.signed && t.length && e.crc32.append(t), t } async flush() { const t = this; let e, n = new Uint8Array(0); if (t.encrypted) { const e = t.decrypt.flush(); if (!e.valid) throw new Error(he); n = e.data } if ((!t.encrypted || t.zipCrypto) && t.signed) { const n = new DataView(new Uint8Array(4).buffer); if (e = t.crc32.get(), n.setUint32(0, e), t.signature != n.getUint32(0, !1)) throw new Error(he) } return t.compressed && (n = await t.inflate.append(n) || new Uint8Array(0), await t.inflate.flush()), { data: n, signature: e } } } class ge { constructor(t, { encrypted: e, signed: n, compressed: r, level: i, zipCrypto: a, password: s, passwordVerification: o, encryptionStrength: c }, { chunkSize: l }) { Object.assign(this, { encrypted: e, signed: n, compressed: r, deflate: r && new t({ level: i || 5, chunkSize: l }), crc32: n && new kt, zipCrypto: a, encrypt: e && a ? new re(s, o) : new Kt(s, c) }) } async append(t) { const e = this; let n = t; return e.compressed && t.length && (n = await e.deflate.append(t)), e.encrypted && n.length && (n = await e.encrypt.append(n)), (!e.encrypted || e.zipCrypto) && e.signed && t.length && e.crc32.append(t), n } async flush() { const t = this; let e, n = new Uint8Array(0); if (t.compressed && (n = await t.deflate.flush() || new Uint8Array(0)), t.encrypted) { n = await t.encrypt.append(n); const r = t.encrypt.flush(); e = r.signature; const i = new Uint8Array(n.length + r.data.length); i.set(n, 0), i.set(r.data, n.length), n = i } return t.encrypted && !t.zipCrypto || !t.signed || (e = t.crc32.get()), { data: n, signature: e } } } const me = "init", be = "append", we = "flush", ye = "message"; let ve = !0; var _e = (t, e, n, r, i, a, s) => (Object.assign(t, { busy: !0, codecConstructor: e, options: Object.assign({}, n), scripts: s, terminate() { t.worker && !t.busy && (t.worker.terminate(), t.interface = null) }, onTaskFinished() { t.busy = !1, i(t) } }), a ? function (t, e) { let n; const r = { type: "module" }; if (!t.interface) { if (ve) try { t.worker = i({}, e.baseURL) } catch (n) { ve = !1, t.worker = i(r, e.baseURL) } else t.worker = i(r, e.baseURL); t.worker.addEventListener(ye, o, !1), t.interface = { append(t) { return a({ type: be, data: t }) }, flush() { return a({ type: we }) }, abort() { t.onTaskFinished() } } } return t.interface; function i(e, n) { let r, i; r = t.scripts[0], "function" == typeof r && (r = r()); try { i = new URL(r, n) } catch (t) { i = r } return new Worker(i, e) } async function a(r) { if (!n) { const n = t.options, r = t.scripts.slice(1); await s({ scripts: r, type: me, options: n, config: { chunkSize: e.chunkSize } }) } return s(r) } function s(e) { const r = t.worker, i = new Promise(((t, e) => n = { resolve: t, reject: e })); try { if (e.data) try { e.data = e.data.buffer, r.postMessage(e, [e.data]) } catch (t) { r.postMessage(e) } else r.postMessage(e) } catch (e) { n.reject(e), n = null, t.onTaskFinished() } return i } function o(e) { const r = e.data; if (n) { const e = r.error, i = r.type; if (e) { const r = new Error(e.message); r.stack = e.stack, n.reject(r), n = null, t.onTaskFinished() } else if (i == me || i == we || i == be) { const e = r.data; i == we ? (n.resolve({ data: new Uint8Array(e), signature: r.signature }), n = null, t.onTaskFinished()) : n.resolve(e && new Uint8Array(e)) } } } }(t, r) : function (t, e) { const n = function (t, e, n) { return e.codecType.startsWith(de) ? new ge(t, e, n) : e.codecType.startsWith(ue) ? new pe(t, e, n) : void 0 }(t.codecConstructor, t.options, e); return { async append(e) { try { return await n.append(e) } catch (e) { throw t.onTaskFinished(), e } }, async flush() { try { return await n.flush() } finally { t.onTaskFinished() } }, abort() { t.onTaskFinished() } } }(t, r)); let xe = []; const ke = []; function Ee(t, e, n) { const r = !(!e.compressed && !e.signed && !e.encrypted) && (e.useWebWorkers || void 0 === e.useWebWorkers && n.useWebWorkers), i = r && n.workerScripts ? n.workerScripts[e.codecType] : []; if (xe.length < n.maxWorkers) { const s = {}; return xe.push(s), _e(s, t, e, n, a, r, i) } { const s = xe.find((t => !t.busy)); return s ? (Ae(s), _e(s, t, e, n, a, r, i)) : new Promise((n => ke.push({ resolve: n, codecConstructor: t, options: e, webWorker: r, scripts: i }))) } function a(t) { if (ke.length) { const [{ resolve: e, codecConstructor: r, options: i, webWorker: s, scripts: o }] = ke.splice(0, 1); e(_e(t, r, i, n, a, s, o)) } else t.worker ? (Ae(t), Number.isFinite(n.terminateWorkerTimeout) && n.terminateWorkerTimeout >= 0 && (t.terminateTimeout = setTimeout((() => { xe = xe.filter((e => e != t)), t.terminate() }), n.terminateWorkerTimeout))) : xe = xe.filter((e => e != t)) } } function Ae(t) { t.terminateTimeout && (clearTimeout(t.terminateTimeout), t.terminateTimeout = null) } const Se = "HTTP error ", Be = "HTTP Range not supported", ze = "text/plain", Ce = "Content-Length", Ue = "Range", Ie = "HEAD", Te = "GET", Ne = "bytes"; class je { constructor() { this.size = 0 } init() { this.initialized = !0 } } class Oe extends je { } class De extends je { writeUint8Array(t) { this.size += t.length } } class Me extends Oe { constructor(t) { super(), this.blobReader = new Pe(new Blob([t], { type: ze })) } init() { super.init(), this.blobReader.init(), this.size = this.blobReader.size } readUint8Array(t, e) { return this.blobReader.readUint8Array(t, e) } } class Re extends De { constructor(t) { super(), this.encoding = t, this.blob = new Blob([], { type: ze }) } writeUint8Array(t) { super.writeUint8Array(t), this.blob = new Blob([this.blob, t.buffer], { type: ze }) } getData() { if (this.blob.text) return this.blob.text(); { const t = new FileReader; return new Promise(((e, n) => { t.onload = t => e(t.target.result), t.onerror = () => n(t.error), t.readAsText(this.blob, this.encoding) })) } } } class Le extends Oe { constructor(t) { super(), this.dataURI = t; let e = t.length; for (; "=" == t.charAt(e - 1);)e--; this.dataStart = t.indexOf(",") + 1, this.size = Math.floor(.75 * (e - this.dataStart)) } readUint8Array(t, e) { const n = new Uint8Array(e), r = 4 * Math.floor(t / 3), i = atob(this.dataURI.substring(r + this.dataStart, 4 * Math.ceil((t + e) / 3) + this.dataStart)), a = t - 3 * Math.floor(r / 4); for (let t = a; t < a + e; t++)n[t - a] = i.charCodeAt(t); return n } } class Fe extends De { constructor(t) { super(), this.data = "data:" + (t || "") + ";base64,", this.pending = [] } writeUint8Array(t) { super.writeUint8Array(t); let e = 0, n = this.pending; const r = this.pending.length; for (this.pending = "", e = 0; e < 3 * Math.floor((r + t.length) / 3) - r; e++)n += String.fromCharCode(t[e]); for (; e < t.length; e++)this.pending += String.fromCharCode(t[e]); n.length > 2 ? this.data += btoa(n) : this.pending = n } getData() { return this.data + btoa(this.pending) } } class Pe extends Oe { constructor(t) { super(), this.blob = t, this.size = t.size } async readUint8Array(t, e) { if (this.blob.arrayBuffer) return new Uint8Array(await this.blob.slice(t, t + e).arrayBuffer()); { const n = new FileReader; return new Promise(((r, i) => { n.onload = t => r(new Uint8Array(t.target.result)), n.onerror = () => i(n.error), n.readAsArrayBuffer(this.blob.slice(t, t + e)) })) } } } class Ve extends De { constructor(t) { super(), this.contentType = t, this.arrayBuffersMaxlength = 8, Ze(this) } writeUint8Array(t) { super.writeUint8Array(t), this.arrayBuffers.length == this.arrayBuffersMaxlength && qe(this), this.arrayBuffers.push(t.buffer) } getData() { return this.blob || (this.arrayBuffers.length && qe(this), this.blob = this.pendingBlob, Ze(this)), this.blob } } function Ze(t) { t.pendingBlob = new Blob([], { type: t.contentType }), t.arrayBuffers = [] } function qe(t) { t.pendingBlob = new Blob([t.pendingBlob, ...t.arrayBuffers], { type: t.contentType }), t.arrayBuffers = [] } class He extends Oe { constructor(t, e) { super(), this.url = t, this.preventHeadRequest = e.preventHeadRequest, this.useRangeHeader = e.useRangeHeader, this.forceRangeRequests = e.forceRangeRequests, this.options = Object.assign({}, e), delete this.options.preventHeadRequest, delete this.options.useRangeHeader, delete this.options.forceRangeRequests, delete this.options.useXHR } async init() { super.init(), await $e(this, en, Je) } readUint8Array(t, e) { return Qe(this, t, e, en, Je) } } class We extends Oe { constructor(t, e) { super(), this.url = t, this.preventHeadRequest = e.preventHeadRequest, this.useRangeHeader = e.useRangeHeader, this.forceRangeRequests = e.forceRangeRequests, this.options = e } async init() { super.init(), await $e(this, nn, Xe) } readUint8Array(t, e) { return Qe(this, t, e, nn, Xe) } } async function $e(t, e, n) { if (function (t) { if ("undefined" != typeof document) { const e = document.createElement("a"); return e.href = t, "http:" == e.protocol || "https:" == e.protocol } return /^https?:\/\//i.test(t) }(t.url) && (t.useRangeHeader || t.forceRangeRequests)) { const r = await e(Te, t, Ge(t)); if (!t.forceRangeRequests && r.headers.get("Accept-Ranges") != Ne) throw new Error(Be); { let i; const a = r.headers.get("Content-Range"); if (a) { const t = a.trim().split(/\s*\/\s*/); if (t.length) { const e = t[1]; e && "*" != e && (i = Number(e)) } } void 0 === i ? await tn(t, e, n) : t.size = i } } else await tn(t, e, n) } async function Qe(t, e, n, r, i) { if (t.useRangeHeader || t.forceRangeRequests) { const i = await r(Te, t, Ge(t, e, n)); if (206 != i.status) throw new Error(Be); return new Uint8Array(await i.arrayBuffer()) } return t.data || await i(t, t.options), new Uint8Array(t.data.subarray(e, e + n)) } function Ge(t, e = 0, n = 1) { return Object.assign({}, Ke(t), { [Ue]: Ne + "=" + e + "-" + (e + n - 1) }) } function Ke(t) { const e = t.options.headers; if (e) return Symbol.iterator in e ? Object.fromEntries(e) : e } async function Je(t) { await Ye(t, en) } async function Xe(t) { await Ye(t, nn) } async function Ye(t, e) { const n = await e(Te, t, Ke(t)); t.data = new Uint8Array(await n.arrayBuffer()), t.size || (t.size = t.data.length) } async function tn(t, e, n) { if (t.preventHeadRequest) await n(t, t.options); else { const r = (await e(Ie, t, Ke(t))).headers.get(Ce); r ? t.size = Number(r) : await n(t, t.options) } } async function en(t, { options: e, url: n }, r) { const i = await fetch(n, Object.assign({}, e, { method: t, headers: r })); if (i.status < 400) return i; throw new Error(Se + (i.statusText || i.status)) } function nn(t, { url: e }, n) { return new Promise(((r, i) => { const a = new XMLHttpRequest; if (a.addEventListener("load", (() => { if (a.status < 400) { const t = []; a.getAllResponseHeaders().trim().split(/[\r\n]+/).forEach((e => { const n = e.trim().split(/\s*:\s*/); n[0] = n[0].trim().replace(/^[a-z]|-[a-z]/g, (t => t.toUpperCase())), t.push(n) })), r({ status: a.status, arrayBuffer: () => a.response, headers: new Map(t) }) } else i(new Error(Se + (a.statusText || a.status))) }), !1), a.addEventListener("error", (t => i(t.detail.error)), !1), a.open(t, e), n) for (const t of Object.entries(n)) a.setRequestHeader(t[0], t[1]); a.responseType = "arraybuffer", a.send() })) } class rn extends Oe { constructor(t, e = {}) { super(), this.url = t, e.useXHR ? this.reader = new We(t, e) : this.reader = new He(t, e) } set size(t) { } get size() { return this.reader.size } async init() { super.init(), await this.reader.init() } readUint8Array(t, e) { return this.reader.readUint8Array(t, e) } } class an extends rn { constructor(t, e = {}) { e.useRangeHeader = !0, super(t, e) } } class sn extends Oe { constructor(t) { super(), this.array = t, this.size = t.length } readUint8Array(t, e) { return this.array.slice(t, t + e) } } class on extends De { constructor() { super(), this.array = new Uint8Array(0) } writeUint8Array(t) { super.writeUint8Array(t); const e = this.array; this.array = new Uint8Array(e.length + t.length), this.array.set(e), this.array.set(t, e.length) } getData() { return this.array } } const cn = 4294967295, ln = 65535, fn = 8, dn = 0, un = 99, hn = 67324752, pn = 134695760, gn = 33639248, mn = 101010256, bn = 101075792, wn = 117853008, yn = 1, vn = 39169, _n = 10, xn = 1, kn = 21589, En = 1, An = 8, Sn = 2048, Bn = 20, zn = 45, Cn = 51, Un = "/", In = new Date(2107, 11, 31), Tn = new Date(1980, 0, 1), Nn = "\0 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ ".split(""); var jn = function (t, e) { if (e && "cp437" == e.trim().toLowerCase()) return (t => { let e = ""; for (let n = 0; n < t.length; n++)e += Nn[t[n]]; return e })(t); if ("undefined" == typeof TextDecoder) { const e = new FileReader; return new Promise(((n, r) => { e.onload = t => n(t.target.result), e.onerror = () => r(e.error), e.readAsText(new Blob([t])) })) } return new TextDecoder(e).decode(t) }; const On = 64, Dn = "Abort error"; async function Mn(t, e, n, r, i, a, s) { const o = Math.max(a.chunkSize, On); return async function a(c = 0, l = 0) { const f = s.signal, d = i(); if (c < d) { Rn(f, t); const i = await e.readUint8Array(c + r, Math.min(o, d - c)), u = i.length; Rn(f, t); const h = await t.append(i); if (Rn(f, t), l += await Ln(n, h), s.onprogress) try { s.onprogress(c + u, d) } catch (t) { } return a(c + o, l) } { const e = await t.flush(); return l += await Ln(n, e.data), { signature: e.signature, length: l } } }() } function Rn(t, e) { if (t && t.aborted) throw e.abort(), new Error(Dn) } async function Ln(t, e) { return e.length && await t.writeUint8Array(e), e.length } const Fn = ["filename", "rawFilename", "directory", "encrypted", "compressedSize", "uncompressedSize", "lastModDate", "rawLastModDate", "comment", "rawComment", "signature", "extraField", "rawExtraField", "bitFlag", "extraFieldZip64", "extraFieldUnicodePath", "extraFieldUnicodeComment", "extraFieldAES", "filenameUTF8", "commentUTF8", "offset", "zip64", "compressionMethod", "extraFieldNTFS", "lastAccessDate", "creationDate", "extraFieldExtendedTimestamp", "version", "versionMadeBy", "msDosCompatible", "internalFileAttribute", "externalFileAttribute"]; class Pn { constructor(t) { Fn.forEach((e => this[e] = t[e])) } } const Vn = "File format is not recognized", Zn = "Zip64 extra field not found", qn = "Compression method not supported", Hn = "utf-8", Wn = "cp437", $n = ["uncompressedSize", "compressedSize", "offset"]; class Qn { constructor(t, e = {}) { Object.assign(this, { reader: t, options: e, config: yt() }) } async*getEntriesGenerator(t = {}) { const e = this, n = e.reader; if (n.initialized || await n.init(), n.size < 22) throw new Error(Vn); const r = await async function (t, e, n, r, i) { const a = new Uint8Array(4); !function (t, e, n) { t.setUint32(e, n, !0) }(sr(a), 0, e); const s = r + i; return await o(r) || await o(Math.min(s, n)); async function o(e) { const i = n - e, s = await or(t, i, e); for (let t = s.length - r; t >= 0; t--)if (s[t] == a[0] && s[t + 1] == a[1] && s[t + 2] == a[2] && s[t + 3] == a[3]) return { offset: i + t, buffer: s.slice(t, t + r).buffer } } }(n, mn, n.size, 22, 1048560); if (!r) throw new Error("End of central directory not found"); const i = sr(r); let a = ir(i, 12), s = ir(i, 16), o = rr(i, 8), c = 0; if (s == cn || a == cn || o == ln) { const t = sr(await or(n, r.offset - 20, 20)); if (ir(t, 0) != wn) throw new Error("End of Zip64 central directory not found"); s = ar(t, 8); let e = await or(n, s, 56), i = sr(e); const l = r.offset - 20 - 56; if (ir(i, 0) != bn && s != l) { const t = s; s = l, c = s - t, e = await or(n, s, 56), i = sr(e) } if (ir(i, 0) != bn) throw new Error("End of Zip64 central directory locator not found"); o = ar(i, 32), a = ar(i, 40), s -= a } if (s < 0 || s >= n.size) throw new Error(Vn); let l = 0, f = await or(n, s, a), d = sr(f); if (a) { const t = r.offset - a; if (ir(d, l) != gn && s != t) { const e = s; s = t, c = s - e, f = await or(n, s, a), d = sr(f) } } if (s < 0 || s >= n.size) throw new Error(Vn); for (let r = 0; r < o; r++) { const i = new Gn(n, e.config, e.options); if (ir(d, l) != gn) throw new Error("Central directory header not found"); Kn(i, d, l + 6); const a = Boolean(i.bitFlag.languageEncodingFlag), s = l + 46, u = s + i.filenameLength, h = u + i.extraFieldLength, p = rr(d, l + 4), g = 0 == (0 & p); Object.assign(i, { versionMadeBy: p, msDosCompatible: g, compressedSize: 0, uncompressedSize: 0, commentLength: rr(d, l + 32), directory: g && 16 == (16 & nr(d, l + 38)), offset: ir(d, l + 42) + c, internalFileAttribute: ir(d, l + 34), externalFileAttribute: ir(d, l + 38), rawFilename: f.subarray(s, u), filenameUTF8: a, commentUTF8: a, rawExtraField: f.subarray(u, h) }); const m = h + i.commentLength; i.rawComment = f.subarray(h, m); const b = Yn(e, t, "filenameEncoding"), w = Yn(e, t, "commentEncoding"), [y, v] = await Promise.all([jn(i.rawFilename, i.filenameUTF8 ? Hn : b || Wn), jn(i.rawComment, i.commentUTF8 ? Hn : w || Wn)]); i.filename = y, i.comment = v, !i.directory && i.filename.endsWith(Un) && (i.directory = !0), await Jn(i, i, d, l + 6); const _ = new Pn(i); if (_.getData = (t, e) => i.getData(t, _, e), l = m, t.onprogress) try { t.onprogress(r + 1, o, new Pn(i)) } catch (t) { } yield _ } return !0 } async getEntries(t = {}) { const e = [], n = this.getEntriesGenerator(t); let r = n.next(); for (; !(await r).done;)e.push((await r).value), r = n.next(); return e } async close() { } } class Gn { constructor(t, e, n) { Object.assign(this, { reader: t, config: e, options: n }) } async getData(t, e, n = {}) { const r = this, { reader: i, offset: a, extraFieldAES: s, compressionMethod: o, config: c, bitFlag: l, signature: f, rawLastModDate: d, compressedSize: u } = r, h = r.localDirectory = {}; i.initialized || await i.init(); let p = await or(i, a, 30); const g = sr(p); let m = Yn(r, n, "password"); if (m = m && m.length && m, s && s.originalCompressionMethod != un) throw new Error(qn); if (o != dn && o != fn) throw new Error(qn); if (ir(g, 0) != hn) throw new Error("Local file header not found"); Kn(h, g, 4), p = await or(i, a, 30 + h.filenameLength + h.extraFieldLength), h.rawExtraField = p.subarray(30 + h.filenameLength), await Jn(r, h, g, 4), e.lastAccessDate = h.lastAccessDate, e.creationDate = h.creationDate; const b = r.encrypted && h.encrypted, w = b && !s; if (b) { if (!w && void 0 === s.strength) throw new Error("Encryption method not supported"); if (!m) throw new Error("File contains encrypted entry") } const y = await Ee(c.Inflate, { codecType: ue, password: m, zipCrypto: w, encryptionStrength: s && s.strength, signed: Yn(r, n, "checkSignature"), passwordVerification: w && (l.dataDescriptor ? d >>> 8 & 255 : f >>> 24 & 255), signature: f, compressed: 0 != o, encrypted: b, useWebWorkers: Yn(r, n, "useWebWorkers") }, c); t.initialized || await t.init(); const v = Yn(r, n, "signal"), _ = a + 30 + h.filenameLength + h.extraFieldLength; return await Mn(y, i, t, _, (() => u), c, { onprogress: n.onprogress, signal: v }), t.getData() } } function Kn(t, e, n) { const r = t.rawBitFlag = rr(e, n + 2), i = (r & En) == En, a = ir(e, n + 6); Object.assign(t, { encrypted: i, version: rr(e, n), bitFlag: { level: (6 & r) >> 1, dataDescriptor: (r & An) == An, languageEncodingFlag: (r & Sn) == Sn }, rawLastModDate: a, lastModDate: tr(a), filenameLength: rr(e, n + 22), extraFieldLength: rr(e, n + 24) }) } async function Jn(t, e, n, r) { const i = e.rawExtraField, a = e.extraField = new Map, s = sr(new Uint8Array(i)); let o = 0; try { for (; o < i.length;) { const t = rr(s, o), e = rr(s, o + 2); a.set(t, { type: t, data: i.slice(o + 4, o + 4 + e) }), o += 4 + e } } catch (t) { } const c = rr(n, r + 4); e.signature = ir(n, r + 10), e.uncompressedSize = ir(n, r + 18), e.compressedSize = ir(n, r + 14); const l = a.get(yn); l && (!function (t, e) { e.zip64 = !0; const n = sr(t.data); t.values = []; for (let e = 0; e < Math.floor(t.data.length / 8); e++)t.values.push(ar(n, 0 + 8 * e)); const r = $n.filter((t => e[t] == cn)); for (let e = 0; e < r.length; e++)t[r[e]] = t.values[e]; $n.forEach((n => { if (e[n] == cn) { if (void 0 === t[n]) throw new Error(Zn); e[n] = t[n] } })) }(l, e), e.extraFieldZip64 = l); const f = a.get(28789); f && (await Xn(f, "filename", "rawFilename", e, t), e.extraFieldUnicodePath = f); const d = a.get(25461); d && (await Xn(d, "comment", "rawComment", e, t), e.extraFieldUnicodeComment = d); const u = a.get(vn); u ? (!function (t, e, n) { const r = sr(t.data); t.vendorVersion = nr(r, 0), t.vendorId = nr(r, 2); const i = nr(r, 4); t.strength = i, t.originalCompressionMethod = n, e.compressionMethod = t.compressionMethod = rr(r, 5) }(u, e, c), e.extraFieldAES = u) : e.compressionMethod = c; const h = a.get(_n); h && (!function (t, e) { const n = sr(t.data); let r, i = 4; try { for (; i < t.data.length && !r;) { const e = rr(n, i), a = rr(n, i + 2); e == xn && (r = t.data.slice(i + 4, i + 4 + a)), i += 4 + a } } catch (t) { } try { if (r && 24 == r.length) { const n = sr(r), i = n.getBigUint64(0, !0), a = n.getBigUint64(8, !0), s = n.getBigUint64(16, !0); Object.assign(t, { rawLastModDate: i, rawLastAccessDate: a, rawCreationDate: s }); const o = er(i), c = er(a), l = { lastModDate: o, lastAccessDate: c, creationDate: er(s) }; Object.assign(t, l), Object.assign(e, l) } } catch (t) { } }(h, e), e.extraFieldNTFS = h); const p = a.get(kn); p && (!function (t, e) { const n = sr(t.data), r = nr(n, 0), i = [], a = []; 1 == (1 & r) && (i.push("lastModDate"), a.push("rawLastModDate")); 2 == (2 & r) && (i.push("lastAccessDate"), a.push("rawLastAccessDate")); 4 == (4 & r) && (i.push("creationDate"), a.push("rawCreationDate")); let s = 1; i.forEach(((r, i) => { if (t.data.length >= s + 4) { const o = ir(n, s); e[r] = t[r] = new Date(1e3 * o); const c = a[i]; t[c] = o } s += 4 })) }(p, e), e.extraFieldExtendedTimestamp = p) } async function Xn(t, e, n, r, i) { const a = sr(t.data); t.version = nr(a, 0), t.signature = ir(a, 1); const s = new kt; s.append(i[n]); const o = sr(new Uint8Array(4)); o.setUint32(0, s.get(), !0), t[e] = await jn(t.data.subarray(5)), t.valid = !i.bitFlag.languageEncodingFlag && t.signature == ir(o, 0), t.valid && (r[e] = t[e], r[e + "UTF8"] = !0) } function Yn(t, e, n) { return void 0 === e[n] ? t.options[n] : e[n] } function tr(t) { const e = (4294901760 & t) >> 16, n = 65535 & t; try { return new Date(1980 + ((65024 & e) >> 9), ((480 & e) >> 5) - 1, 31 & e, (63488 & n) >> 11, (2016 & n) >> 5, 2 * (31 & n), 0) } catch (t) { } } function er(t) { return new Date(Number(t / BigInt(1e4) - BigInt(116444736e5))) } function nr(t, e) { return t.getUint8(e) } function rr(t, e) { return t.getUint16(e, !0) } function ir(t, e) { return t.getUint32(e, !0) } function ar(t, e) { return Number(t.getBigUint64(e, !0)) } function sr(t) { return new DataView(t.buffer) } function or(t, e, n) { return t.readUint8Array(e, n) } const cr = "File already exists", lr = "Zip file comment exceeds 64KB", fr = "File entry comment exceeds 64KB", dr = "File entry name exceeds 64KB", ur = "Version exceeds 65535", hr = "The strength must equal 1, 2, or 3", pr = "Extra field type exceeds 65535", gr = "Extra field data exceeds 64KB", mr = "Zip64 is not supported", br = new Uint8Array([7, 0, 2, 0, 65, 69, 3, 0, 0]), wr = 24; let yr = 0; class vr { constructor(t, e = {}) { Object.assign(this, { writer: t, options: e, config: yt(), files: new Map, offset: t.size, pendingCompressedSize: 0, pendingEntries: [], pendingAddFileCalls: new Set }) } async add(t = "", e, n = {}) { const r = this; if (!(yr < r.config.maxWorkers)) return new Promise(((i, a) => r.pendingEntries.push({ name: t, reader: e, options: n, resolve: i, reject: a }))); { let i; yr++; try { return i = async function (t, e, n, r) { e = e.trim(), r.directory && !e.endsWith(Un) ? e += Un : r.directory = e.endsWith(Un); if (t.files.has(e)) throw new Error(cr); const i = Et(e); if (i.length > ln) throw new Error(dr); const a = r.comment || "", s = Et(a); if (s.length > ln) throw new Error(fr); const o = t.options.version || r.version || 0; if (o > ln) throw new Error(ur); const c = t.options.versionMadeBy || r.versionMadeBy || 20; if (c > ln) throw new Error(ur); const l = kr(t, r, "lastModDate") || new Date, f = kr(t, r, "lastAccessDate"), d = kr(t, r, "creationDate"), u = kr(t, r, "password"), h = kr(t, r, "encryptionStrength") || 3, p = kr(t, r, "zipCrypto"); if (void 0 !== u && void 0 !== h && (h < 1 || h > 3)) throw new Error(hr); let g = new Uint8Array(0); const m = r.extraField; if (m) { let t = 0, e = 0; m.forEach((e => t += 4 + e.length)), g = new Uint8Array(t), m.forEach(((t, n) => { if (n > ln) throw new Error(pr); if (t.length > ln) throw new Error(gr); zr(g, new Uint16Array([n]), e), zr(g, new Uint16Array([t.length]), e + 2), zr(g, t, e + 4), e += 4 + t.length })) } let b = kr(t, r, "extendedTimestamp"); void 0 === b && (b = !0); let w = 0, y = kr(t, r, "keepOrder"); void 0 === y && (y = !0); let v = 0, _ = kr(t, r, "msDosCompatible"); void 0 === _ && (_ = !0); const x = kr(t, r, "internalFileAttribute") || 0, k = kr(t, r, "externalFileAttribute") || 0; n && (n.initialized || await n.init(), v = n.size, w = function (t) { return t + 5 * (Math.floor(t / 16383) + 1) }(v)); let E = r.zip64 || t.options.zip64 || !1; if (t.offset + t.pendingCompressedSize >= cn || v >= cn || w >= cn) { if (!1 === r.zip64 || !1 === t.options.zip64 || !y) throw new Error(mr); E = !0 } t.pendingCompressedSize += w, await Promise.resolve(); const A = kr(t, r, "level"), S = kr(t, r, "useWebWorkers"), B = kr(t, r, "bufferedWrite"); let z = kr(t, r, "dataDescriptor"), C = kr(t, r, "dataDescriptorSignature"); const U = kr(t, r, "signal"); void 0 === z && (z = !0); z && void 0 === C && (C = !1); const I = await async function (t, e, n, r) { const i = t.files, a = t.writer, s = Array.from(i.values()).pop(); let o, c, l, f = {}; i.set(e, f); try { let d, u, h; if (r.keepOrder && (d = s && s.lock), f.lock = h = new Promise((t => l = t)), r.bufferedWrite || t.lockWrite || !r.dataDescriptor ? (u = new Ve, u.init(), o = !0) : (t.lockWrite = new Promise((t => c = t)), a.initialized || await a.init(), u = a), f = await async function (t, e, n, r) { const { rawFilename: i, lastAccessDate: a, creationDate: s, password: o, level: c, zip64: l, zipCrypto: f, dataDescriptor: d, dataDescriptorSignature: u, directory: h, version: p, versionMadeBy: g, rawComment: m, rawExtraField: b, useWebWorkers: w, onprogress: y, signal: v, encryptionStrength: _, extendedTimestamp: x, msDosCompatible: k, internalFileAttribute: E, externalFileAttribute: A } = r, S = Boolean(o && o.length), B = 0 !== c && !h; let z, C, U; if (S && !f) { z = new Uint8Array(br.length + 2); const t = Cr(z); Ar(t, 0, vn), zr(z, br, 2), Er(t, 8, _) } else z = new Uint8Array(0); if (x) { U = new Uint8Array(9 + (a ? 4 : 0) + (s ? 4 : 0)); const t = Cr(U); Ar(t, 0, kn), Ar(t, 2, U.length - 4); Er(t, 4, 1 + (a ? 2 : 0) + (s ? 4 : 0)), Sr(t, 5, Math.floor(r.lastModDate.getTime() / 1e3)), a && Sr(t, 9, Math.floor(a.getTime() / 1e3)), s && Sr(t, 13, Math.floor(s.getTime() / 1e3)); try { C = new Uint8Array(36); const t = Cr(C), e = xr(r.lastModDate); Ar(t, 0, _n), Ar(t, 2, 32), Ar(t, 8, xn), Ar(t, 10, 24), Br(t, 12, e), Br(t, 20, xr(a) || e), Br(t, 28, xr(s) || e) } catch (t) { C = new Uint8Array(0) } } else C = U = new Uint8Array(0); const I = { version: p || Bn, versionMadeBy: g, zip64: l, directory: Boolean(h), filenameUTF8: !0, rawFilename: i, commentUTF8: !0, rawComment: m, rawExtraFieldZip64: l ? new Uint8Array(wr + 4) : new Uint8Array(0), rawExtraFieldExtendedTimestamp: U, rawExtraFieldNTFS: C, rawExtraFieldAES: z, rawExtraField: b, extendedTimestamp: x, msDosCompatible: k, internalFileAttribute: E, externalFileAttribute: A }; let T = I.uncompressedSize = 0, N = Sn; d && (N |= An); let j = dn; B && (j = fn); l && (I.version = I.version > zn ? I.version : zn); S && (N |= En, f || (I.version = I.version > Cn ? I.version : Cn, j = un, B && (I.rawExtraFieldAES[9] = fn))); I.compressionMethod = j; const O = I.headerArray = new Uint8Array(26), D = Cr(O); Ar(D, 0, I.version), Ar(D, 2, N), Ar(D, 4, j); const M = new Uint32Array(1), R = Cr(M); let L; L = r.lastModDate < Tn ? Tn : r.lastModDate > In ? In : r.lastModDate; Ar(R, 0, (L.getHours() << 6 | L.getMinutes()) << 5 | L.getSeconds() / 2), Ar(R, 2, (L.getFullYear() - 1980 << 4 | L.getMonth() + 1) << 5 | L.getDate()); const F = M[0]; Sr(D, 6, F), Ar(D, 22, i.length); const P = z.length + U.length + C.length + I.rawExtraField.length; Ar(D, 24, P); const V = new Uint8Array(30 + i.length + P); let Z; Sr(Cr(V), 0, hn), zr(V, O, 4), zr(V, i, 30), zr(V, z, 30 + i.length), zr(V, U, 30 + i.length + z.length), zr(V, C, 30 + i.length + z.length + U.length), zr(V, I.rawExtraField, 30 + i.length + z.length + U.length + C.length); let q = 0; if (t) { const r = await Ee(n.Deflate, { codecType: de, level: c, password: o, encryptionStrength: _, zipCrypto: S && f, passwordVerification: S && f && F >> 8 & 255, signed: !0, compressed: B, encrypted: S, useWebWorkers: w }, n); await e.writeUint8Array(V), I.dataWritten = !0, Z = await Mn(r, t, e, 0, (() => t.size), n, { onprogress: y, signal: v }), T = I.uncompressedSize = t.size, q = Z.length } else await e.writeUint8Array(V), I.dataWritten = !0; let H, W = new Uint8Array(0), $ = 0; d && (W = new Uint8Array(l ? u ? 24 : 20 : u ? 16 : 12), H = Cr(W), u && ($ = 4, Sr(H, 0, pn))); if (t) { const t = Z.signature; if (S && !f || void 0 === t || (Sr(D, 10, t), I.signature = t, d && Sr(H, $, t)), l) { const t = Cr(I.rawExtraFieldZip64); Ar(t, 0, yn), Ar(t, 2, wr), Sr(D, 14, cn), Br(t, 12, BigInt(q)), Sr(D, 18, cn), Br(t, 4, BigInt(T)), d && (Br(H, $ + 4, BigInt(q)), Br(H, $ + 12, BigInt(T))) } else Sr(D, 14, q), Sr(D, 18, T), d && (Sr(H, $ + 4, q), Sr(H, $ + 8, T)) } d && await e.writeUint8Array(W); const Q = V.length + q + W.length; return Object.assign(I, { compressedSize: q, lastModDate: L, rawLastModDate: F, creationDate: s, lastAccessDate: a, encrypted: S, length: Q }), I }(n, u, t.config, r), f.lock = h, i.set(e, f), f.filename = e, o) { let e = 0; const n = u.getData(); let s; await Promise.all([t.lockWrite, d]); do { s = Array.from(i.values()).find((t => t.writingBufferedData)), s && await s.lock } while (s && s.lock); if (f.writingBufferedData = !0, !r.dataDescriptor) { const t = 26, i = await _r(n, 0, t), s = new DataView(i); f.encrypted && !r.zipCrypto || Sr(s, 14, f.signature), f.zip64 ? (Sr(s, 18, cn), Sr(s, 22, cn)) : (Sr(s, 18, f.compressedSize), Sr(s, 22, f.uncompressedSize)), await a.writeUint8Array(new Uint8Array(i)), e = t } await async function (t, e, n = 0) { const r = 536870912; async function i() { if (n < e.size) { const a = await _r(e, n, n + r); await t.writeUint8Array(new Uint8Array(a)), n += r, await i() } } await i() }(a, n, e), delete f.writingBufferedData } if (f.offset = t.offset, f.zip64) { Br(Cr(f.rawExtraFieldZip64), 20, BigInt(f.offset)) } else if (f.offset >= cn) throw new Error(mr); return t.offset += f.length, f } catch (n) { throw (o && f.writingBufferedData || !o && f.dataWritten) && (n.corruptedEntry = t.hasCorruptedEntries = !0, f.uncompressedSize && (t.offset += f.uncompressedSize)), i.delete(e), n } finally { l(), c && c() } }(t, e, n, Object.assign({}, r, { rawFilename: i, rawComment: s, version: o, versionMadeBy: c, lastModDate: l, lastAccessDate: f, creationDate: d, rawExtraField: g, zip64: E, password: u, level: A, useWebWorkers: S, encryptionStrength: h, extendedTimestamp: b, zipCrypto: p, bufferedWrite: B, keepOrder: y, dataDescriptor: z, dataDescriptorSignature: C, signal: U, msDosCompatible: _, internalFileAttribute: x, externalFileAttribute: k })); w && (t.pendingCompressedSize -= w); return Object.assign(I, { name: e, comment: a, extraField: m }), new Pn(I) }(r, t, e, n), this.pendingAddFileCalls.add(i), await i } finally { this.pendingAddFileCalls.delete(i), yr--; const t = r.pendingEntries.shift(); t && r.add(t.name, t.reader, t.options).then(t.resolve).catch(t.reject) } } } async close(t = new Uint8Array(0), e = {}) { for (; this.pendingAddFileCalls.size;)await Promise.all(Array.from(this.pendingAddFileCalls)); return await async function (t, e, n) { const r = t.writer, i = t.files; let a = 0, s = 0, o = t.offset, c = i.size; for (const [, t] of i) s += 46 + t.rawFilename.length + t.rawComment.length + t.rawExtraFieldZip64.length + t.rawExtraFieldAES.length + t.rawExtraFieldExtendedTimestamp.length + t.rawExtraFieldNTFS.length + t.rawExtraField.length; let l = n.zip64 || t.options.zip64 || !1; if (o >= cn || s >= cn || c >= ln) { if (!1 === n.zip64 || !1 === t.options.zip64) throw new Error(mr); l = !0 } const f = new Uint8Array(s + (l ? 98 : 22)), d = Cr(f); if (e && e.length) { if (!(e.length <= ln)) throw new Error(lr); Ar(d, a + 20, e.length) } for (const [t, e] of Array.from(i.values()).entries()) { const { rawFilename: r, rawExtraFieldZip64: s, rawExtraFieldAES: o, rawExtraField: c, rawComment: l, versionMadeBy: u, headerArray: h, directory: p, zip64: g, msDosCompatible: m, internalFileAttribute: b, externalFileAttribute: w } = e; let y, v; if (e.extendedTimestamp) { v = e.rawExtraFieldNTFS, y = new Uint8Array(9); const t = Cr(y); Ar(t, 0, kn), Ar(t, 2, y.length - 4), Er(t, 4, 1), Sr(t, 5, Math.floor(e.lastModDate.getTime() / 1e3)) } else v = y = new Uint8Array(0); const _ = s.length + o.length + y.length + v.length + c.length; if (Sr(d, a, gn), Ar(d, a + 4, u), zr(f, h, a + 6), Ar(d, a + 30, _), Ar(d, a + 32, l.length), Sr(d, a + 34, b), w ? Sr(d, a + 38, w) : p && m && Er(d, a + 38, 16), Sr(d, a + 42, g ? cn : e.offset), zr(f, r, a + 46), zr(f, s, a + 46 + r.length), zr(f, o, a + 46 + r.length + s.length), zr(f, y, a + 46 + r.length + s.length + o.length), zr(f, v, a + 46 + r.length + s.length + o.length + y.length), zr(f, c, a + 46 + r.length + s.length + o.length + y.length + v.length), zr(f, l, a + 46 + r.length + _), a += 46 + r.length + _ + l.length, n.onprogress) try { n.onprogress(t + 1, i.size, new Pn(e)) } catch (t) { } } l && (Sr(d, a, bn), Br(d, a + 4, BigInt(44)), Ar(d, a + 12, 45), Ar(d, a + 14, 45), Br(d, a + 24, BigInt(c)), Br(d, a + 32, BigInt(c)), Br(d, a + 40, BigInt(s)), Br(d, a + 48, BigInt(o)), Sr(d, a + 56, wn), Br(d, a + 64, BigInt(o) + BigInt(s)), Sr(d, a + 72, 1), c = ln, o = cn, s = cn, a += 76); Sr(d, a, mn), Ar(d, a + 8, c), Ar(d, a + 10, c), Sr(d, a + 12, s), Sr(d, a + 16, o), await r.writeUint8Array(f), e && e.length && await r.writeUint8Array(e) }(this, t, e), this.writer.getData() } } function _r(t, e, n) { if (t.arrayBuffer) return e || n ? t.slice(e, n).arrayBuffer() : t.arrayBuffer(); { const r = new FileReader; return new Promise(((i, a) => { r.onload = t => i(t.target.result), r.onerror = () => a(r.error), r.readAsArrayBuffer(e || n ? t.slice(e, n) : t) })) } } function xr(t) { if (t) return (BigInt(t.getTime()) + BigInt(116444736e5)) * BigInt(1e4) } function kr(t, e, n) { return void 0 === e[n] ? t.options[n] : e[n] } function Er(t, e, n) { t.setUint8(e, n) } function Ar(t, e, n) { t.setUint16(e, n, !0) } function Sr(t, e, n) { t.setUint32(e, n, !0) } function Br(t, e, n) { t.setBigUint64(e, n, !0) } function zr(t, e, n) { t.set(e, n) } function Cr(t) { return new DataView(t.buffer) } const Ur = 524288; class Ir { constructor(t, e, n, r) { const i = this; if (t.root && r && r.getChildByName(e)) throw new Error("Entry filename already exists"); n || (n = {}), Object.assign(i, { fs: t, name: e, data: n.data, id: t.entries.length, parent: r, children: [], uncompressedSize: 0 }), t.entries.push(i), r && i.parent.children.push(i) } moveTo(t) { this.fs.move(this, t) } getFullname() { return this.getRelativeName() } getRelativeName(t = this.fs.root) { let e = this.name, n = this.parent; for (; n && n != t;)e = (n.name ? n.name + "/" : "") + e, n = n.parent; return e } isDescendantOf(t) { let e = this.parent; for (; e && e.id != t.id;)e = e.parent; return Boolean(e) } } class Tr extends Ir { constructor(t, e, n, r) { super(t, e, n, r); const i = this; i.Reader = n.Reader, i.Writer = n.Writer, n.getData && (i.getData = n.getData) } async getData(t, e = {}) { const n = this; return !t || t.constructor == n.Writer && n.data ? n.data : (n.reader = new n.Reader(n.data, e), await n.reader.init(), t.initialized || await t.init(), n.uncompressedSize = n.reader.size, function (t, e) { return n(); async function n(r = 0) { const i = r * Ur; if (i < t.size) { const a = await t.readUint8Array(i, Math.min(Ur, t.size - i)); return await e.writeUint8Array(a), n(r + 1) } return e.getData() } }(n.reader, t)) } getText(t, e) { return this.getData(new Re(t), e) } getBlob(t, e) { return this.getData(new Ve(t), e) } getData64URI(t, e) { return this.getData(new Fe(t), e) } getUint8Array(t) { return this.getData(new on, t) } replaceBlob(t) { Object.assign(this, { data: t, Reader: Pe, Writer: Ve, reader: null }) } replaceText(t) { Object.assign(this, { data: t, Reader: Me, Writer: Re, reader: null }) } replaceData64URI(t) { Object.assign(this, { data: t, Reader: Le, Writer: Fe, reader: null }) } replaceUint8Array(t) { Object.assign(this, { data: t, Reader: sn, Writer: on, reader: null }) } } class Nr extends Ir { constructor(t, e, n, r) { super(t, e, n, r), this.directory = !0 } addDirectory(t) { return Lr(this, t, null, !0) } addText(t, e) { return Lr(this, t, { data: e, Reader: Me, Writer: Re }) } addBlob(t, e) { return Lr(this, t, { data: e, Reader: Pe, Writer: Ve }) } addData64URI(t, e) { return Lr(this, t, { data: e, Reader: Le, Writer: Fe }) } addUint8Array(t, e) { return Lr(this, t, { data: e, Reader: sn, Writer: on }) } addHttpContent(t, e, n = {}) { return Lr(this, t, { data: e, Reader: class extends rn { constructor(t) { super(t, n) } } }) } addFileSystemEntry(t) { return async function (t, e) { if (e.isDirectory) { const r = t.addDirectory(e.name); return await n(r, e), r } return new Promise(((n, r) => e.file((r => n(t.addBlob(e.name, r))), r))); async function n(t, e) { const i = await r(e); for (const e of i) e.isDirectory ? await n(t.addDirectory(e.name), e) : await new Promise(((n, r) => { e.file((r => { const i = t.addBlob(e.name, r); i.uncompressedSize = r.size, n(i) }), r) })) } function r(t) { return new Promise(((e, n) => { let r = []; function i(t) { t.readEntries((n => { n.length ? (r = r.concat(n), i(t)) : e(r) }), n) } t.isDirectory && i(t.createReader()), t.isFile && e(r) })) } }(this, t) } addData(t, e) { return Lr(this, t, e) } async importBlob(t, e = {}) { await this.importZip(new Pe(t), e) } async importData64URI(t, e = {}) { await this.importZip(new Le(t), e) } async importUint8Array(t, e = {}) { await this.importZip(new sn(t), e) } async importHttpContent(t, e = {}) { await this.importZip(new rn(t, e), e) } exportBlob(t = {}) { return this.exportZip(new Ve("application/zip"), t) } exportData64URI(t = {}) { return this.exportZip(new Fe("application/zip"), t) } exportUint8Array(t = {}) { return this.exportZip(new on, t) } async importZip(t, e) { t.initialized || await t.init(); const n = new Qn(t, e); (await n.getEntries()).forEach((t => { let n = this; const r = t.filename.split("/"), i = r.pop(); r.forEach((t => n = n.getChildByName(t) || new Nr(this.fs, t, null, n))), t.directory || Lr(n, i, { data: t, Reader: Or(Object.assign({}, e)) }) })) } async exportZip(t, e) { const n = this; await Dr(n), await t.init(); const r = new vr(t, e); return await async function (t, e, n, r) { const i = e, a = new Map; async function s(t, e) { async function o() { if (r.bufferedWrite) await Promise.all(e.children.map(c)); else for (const t of e.children) await c(t) } async function c(e) { const o = r.relativePath ? e.getRelativeName(i) : e.getFullname(); await t.add(o, e.reader, Object.assign({ directory: e.directory }, Object.assign({}, r, { onprogress: t => { if (r.onprogress) { a.set(o, t); try { r.onprogress(Array.from(a.values()).reduce(((t, e) => t + e)), n) } catch (t) { } } } }))), await s(t, e) } await o() } await s(t, e) }(r, n, function (t, e) { let n = 0; return t.forEach(r), n; function r(t) { n += t[e], t.children && t.children.forEach(r) } }([n], "uncompressedSize"), e), await r.close(), t.getData() } getChildByName(t) { const e = this.children; for (let n = 0; n < e.length; n++) { const r = e[n]; if (r.name == t) return r } } } const jr = { FS: class { constructor() { Rr(this) } get children() { return this.root.children } remove(t) { Mr(t), this.entries[t.id] = null } move(t, e) { if (t == this.root) throw new Error("Root directory cannot be moved"); if (!e.directory) throw new Error("Target entry is not a directory"); if (e.isDescendantOf(t)) throw new Error("Entry is a ancestor of target entry"); if (t != e) { if (e.getChildByName(t.name)) throw new Error("Entry filename already exists"); Mr(t), t.parent = e, e.children.push(t) } } find(t) { const e = t.split("/"); let n = this.root; for (let t = 0; n && t < e.length; t++)n = n.getChildByName(e[t]); return n } getById(t) { return this.entries[t] } getChildByName(t) { return this.root.getChildByName(t) } addDirectory(t) { return this.root.addDirectory(t) } addText(t, e) { return this.root.addText(t, e) } addBlob(t, e) { return this.root.addBlob(t, e) } addData64URI(t, e) { return this.root.addData64URI(t, e) } addHttpContent(t, e, n) { return this.root.addHttpContent(t, e, n) } addFileSystemEntry(t) { return this.root.addFileSystemEntry(t) } addData(t, e) { return this.root.addData(t, e) } async importBlob(t, e) { Rr(this), await this.root.importBlob(t, e) } async importData64URI(t, e) { Rr(this), await this.root.importData64URI(t, e) } async importHttpContent(t, e) { Rr(this), await this.root.importHttpContent(t, e) } exportBlob(t) { return this.root.exportBlob(t) } exportData64URI(t) { return this.root.exportData64URI(t) } }, ZipDirectoryEntry: Nr, ZipFileEntry: Tr }; function Or(t) { return class extends Oe { constructor(t, e = {}) { super(), this.entry = t, this.options = e } async init() { const e = this; e.size = e.entry.uncompressedSize; const n = await e.entry.getData(new Ve, Object.assign({}, e.options, t)); e.data = n, e.blobReader = new Pe(n) } readUint8Array(t, e) { return this.blobReader.readUint8Array(t, e) } } } async function Dr(t) { if (t.children.length) for (const e of t.children) e.directory ? await Dr(e) : (e.reader = new e.Reader(e.data), await e.reader.init(), e.uncompressedSize = e.reader.size) } function Mr(t) { const e = t.parent.children; e.forEach(((n, r) => { n.id == t.id && e.splice(r, 1) })) } function Rr(t) { t.entries = [], t.root = new Nr(t) } function Lr(t, e, n, r) { if (t.directory) return r ? new Nr(t.fs, e, n, t) : new Tr(t.fs, e, n, t); throw new Error("Parent entry is not a directory") } let Fr; try { Fr = "file:///E:/project/ofd_ts/node_modules/@zip.js/zip.js/lib/zip-fs.js" } catch (t) { } vt({ baseURL: Fr }), (t => { if ("function" == typeof URL.createObjectURL) { const e = () => URL.createObjectURL(new Blob(['const{Array:t,Object:e,Math:n,Error:r,Uint8Array:i,Uint16Array:o,Uint32Array:s,Int32Array:f,DataView:c,TextEncoder:l,crypto:u,postMessage:a}=globalThis,w=[];for(let t=0;256>t;t++){let e=t;for(let t=0;8>t;t++)1&e?e=e>>>1^3988292384:e>>>=1;w[t]=e}class h{constructor(t){this.t=t||-1}append(t){let e=0|this.t;for(let n=0,r=0|t.length;r>n;n++)e=e>>>8^w[255&(e^t[n])];this.t=e}get(){return~this.t}}const d={concat(t,e){if(0===t.length||0===e.length)return t.concat(e);const n=t[t.length-1],r=d.i(n);return 32===r?t.concat(e):d.o(e,r,0|n,t.slice(0,t.length-1))},l(t){const e=t.length;if(0===e)return 0;const n=t[e-1];return 32*(e-1)+d.i(n)},u(t,e){if(32*t.length<e)return t;const r=(t=t.slice(0,n.ceil(e/32))).length;return e&=31,r>0&&e&&(t[r-1]=d.h(e,t[r-1]&2147483648>>e-1,1)),t},h:(t,e,n)=>32===t?e:(n?0|e:e<<32-t)+1099511627776*t,i:t=>n.round(t/1099511627776)||32,o(t,e,n,r){for(void 0===r&&(r=[]);e>=32;e-=32)r.push(n),n=0;if(0===e)return r.concat(t);for(let i=0;i<t.length;i++)r.push(n|t[i]>>>e),n=t[i]<<32-e;const i=t.length?t[t.length-1]:0,o=d.i(i);return r.push(d.h(e+o&31,e+o>32?n:r.pop(),1)),r}},p={p:{k(t){const e=d.l(t)/8,n=new i(e);let r;for(let i=0;e>i;i++)0==(3&i)&&(r=t[i/4]),n[i]=r>>>24,r<<=8;return n},g(t){const e=[];let n,r=0;for(n=0;n<t.length;n++)r=r<<8|t[n],3==(3&n)&&(e.push(r),r=0);return 3&n&&e.push(d.h(8*(3&n),r)),e}}},y={v:function(t){t?(this.m=t.m.slice(0),this.S=t.S.slice(0),this._=t._):this.reset()}};y.v.prototype={blockSize:512,reset:function(){const t=this;return t.m=this.I.slice(0),t.S=[],t._=0,t},update:function(t){const e=this;"string"==typeof t&&(t=p.A.g(t));const n=e.S=d.concat(e.S,t),i=e._,o=e._=i+d.l(t);if(o>9007199254740991)throw new r("Cannot hash more than 2^53 - 1 bits");const f=new s(n);let c=0;for(let t=e.blockSize+i-(e.blockSize+i&e.blockSize-1);o>=t;t+=e.blockSize)e.C(f.subarray(16*c,16*(c+1))),c+=1;return n.splice(0,16*c),e},V:function(){const t=this;let e=t.S;const r=t.m;e=d.concat(e,[d.h(1,1)]);for(let t=e.length+2;15&t;t++)e.push(0);for(e.push(n.floor(t._/4294967296)),e.push(0|t._);e.length;)t.C(e.splice(0,16));return t.reset(),r},I:[1732584193,4023233417,2562383102,271733878,3285377520],B:[1518500249,1859775393,2400959708,3395469782],D:(t,e,n,r)=>t>19?t>39?t>59?t>79?void 0:e^n^r:e&n|e&r|n&r:e^n^r:e&n|~e&r,U:(t,e)=>e<<t|e>>>32-t,C:function(e){const r=this,i=r.m,o=t(80);for(let t=0;16>t;t++)o[t]=e[t];let s=i[0],f=i[1],c=i[2],l=i[3],u=i[4];for(let t=0;79>=t;t++){16>t||(o[t]=r.U(1,o[t-3]^o[t-8]^o[t-14]^o[t-16]));const e=r.U(5,s)+r.D(t,f,c,l)+u+o[t]+r.B[n.floor(t/20)]|0;u=l,l=c,c=r.U(30,f),f=s,s=e}i[0]=i[0]+s|0,i[1]=i[1]+f|0,i[2]=i[2]+c|0,i[3]=i[3]+l|0,i[4]=i[4]+u|0}};const b={getRandomValues(t){const e=new s(t.buffer),r=t=>{let e=987654321;const r=4294967295;return()=>(e=36969*(65535&e)+(e>>16)&r,(((e<<16)+(t=18e3*(65535&t)+(t>>16)&r)&r)/4294967296+.5)*(n.random()>.5?1:-1))};for(let i,o=0;o<t.length;o+=4){const t=r(4294967296*(i||n.random()));i=987654071*t(),e[o/4]=4294967296*t()|0}return t}},k={importKey:t=>new k.M(p.p.g(t)),P(t,e,n,i){if(n=n||1e4,0>i||0>n)throw new r("invalid params to pbkdf2");const o=1+(i>>5)<<2;let s,f,l,u,a;const w=new ArrayBuffer(o),h=new c(w);let y=0;const b=d;for(e=p.p.g(e),a=1;(o||1)>y;a++){for(s=f=t.encrypt(b.concat(e,[a])),l=1;n>l;l++)for(f=t.encrypt(f),u=0;u<f.length;u++)s[u]^=f[u];for(l=0;(o||1)>y&&l<s.length;l++)h.setInt32(y,s[l]),y+=4}return w.slice(0,i/8)},M:class{constructor(t){const e=this,n=e.R=y.v,r=[[],[]],i=n.prototype.blockSize/32;e.H=[new n,new n],t.length>i&&(t=n.hash(t));for(let e=0;i>e;e++)r[0][e]=909522486^t[e],r[1][e]=1549556828^t[e];e.H[0].update(r[0]),e.H[1].update(r[1]),e.K=new n(e.H[0])}reset(){const t=this;t.K=new t.R(t.H[0]),t.L=!1}update(t){this.L=!0,this.K.update(t)}digest(){const t=this,e=t.K.V(),n=new t.R(t.H[1]).update(e).V();return t.reset(),n}encrypt(t){if(this.L)throw new r("encrypt on already updated hmac called!");return this.update(t),this.digest(t)}}},g={name:"PBKDF2"},v=e.assign({hash:{name:"HMAC"}},g),m=e.assign({iterations:1e3,hash:{name:"SHA-1"}},g),S=["deriveBits"],z=[8,12,16],_=[16,24,32],I=[0,0,0,0],A=void 0!==u,C=A&&void 0!==u.subtle,V=p.p,B=class{constructor(t){const e=this;e.T=[[[],[],[],[],[]],[[],[],[],[],[]]],e.T[0][0][0]||e.j();const n=e.T[0][4],i=e.T[1],o=t.length;let s,f,c,l=1;if(4!==o&&6!==o&&8!==o)throw new r("invalid aes key size");for(e.B=[f=t.slice(0),c=[]],s=o;4*o+28>s;s++){let t=f[s-1];(s%o==0||8===o&&s%o==4)&&(t=n[t>>>24]<<24^n[t>>16&255]<<16^n[t>>8&255]<<8^n[255&t],s%o==0&&(t=t<<8^t>>>24^l<<24,l=l<<1^283*(l>>7))),f[s]=f[s-o]^t}for(let t=0;s;t++,s--){const e=f[3&t?s:s-4];c[t]=4>=s||4>t?e:i[0][n[e>>>24]]^i[1][n[e>>16&255]]^i[2][n[e>>8&255]]^i[3][n[255&e]]}}encrypt(t){return this.F(t,0)}decrypt(t){return this.F(t,1)}j(){const t=this.T[0],e=this.T[1],n=t[4],r=e[4],i=[],o=[];let s,f,c,l;for(let t=0;256>t;t++)o[(i[t]=t<<1^283*(t>>7))^t]=t;for(let u=s=0;!n[u];u^=f||1,s=o[s]||1){let o=s^s<<1^s<<2^s<<3^s<<4;o=o>>8^255&o^99,n[u]=o,r[o]=u,l=i[c=i[f=i[u]]];let a=16843009*l^65537*c^257*f^16843008*u,w=257*i[o]^16843008*o;for(let n=0;4>n;n++)t[n][u]=w=w<<24^w>>>8,e[n][o]=a=a<<24^a>>>8}for(let n=0;5>n;n++)t[n]=t[n].slice(0),e[n]=e[n].slice(0)}F(t,e){if(4!==t.length)throw new r("invalid aes block size");const n=this.B[e],i=n.length/4-2,o=[0,0,0,0],s=this.T[e],f=s[0],c=s[1],l=s[2],u=s[3],a=s[4];let w,h,d,p=t[0]^n[0],y=t[e?3:1]^n[1],b=t[2]^n[2],k=t[e?1:3]^n[3],g=4;for(let t=0;i>t;t++)w=f[p>>>24]^c[y>>16&255]^l[b>>8&255]^u[255&k]^n[g],h=f[y>>>24]^c[b>>16&255]^l[k>>8&255]^u[255&p]^n[g+1],d=f[b>>>24]^c[k>>16&255]^l[p>>8&255]^u[255&y]^n[g+2],k=f[k>>>24]^c[p>>16&255]^l[y>>8&255]^u[255&b]^n[g+3],g+=4,p=w,y=h,b=d;for(let t=0;4>t;t++)o[e?3&-t:t]=a[p>>>24]<<24^a[y>>16&255]<<16^a[b>>8&255]<<8^a[255&k]^n[g++],w=p,p=y,y=b,b=k,k=w;return o}},E=class{constructor(t,e){this.O=t,this.W=e,this.q=e}reset(){this.q=this.W}update(t){return this.G(this.O,t,this.q)}J(t){if(255==(t>>24&255)){let e=t>>16&255,n=t>>8&255,r=255&t;255===e?(e=0,255===n?(n=0,255===r?r=0:++r):++n):++e,t=0,t+=e<<16,t+=n<<8,t+=r}else t+=1<<24;return t}N(t){0===(t[0]=this.J(t[0]))&&(t[1]=this.J(t[1]))}G(t,e,n){let r;if(!(r=e.length))return[];const i=d.l(e);for(let i=0;r>i;i+=4){this.N(n);const r=t.encrypt(n);e[i]^=r[0],e[i+1]^=r[1],e[i+2]^=r[2],e[i+3]^=r[3]}return d.u(e,i)}},D=k.M;class U{constructor(t,n,r){e.assign(this,{password:t,signed:n,X:r-1,Y:new i(0)})}async append(e){const n=this;if(n.password){const i=K(e,0,z[n.X]+2);await(async(t,e,n)=>{await R(t,n,K(e,0,z[t.X]));const i=K(e,z[t.X]),o=t.keys.passwordVerification;if(o[0]!=i[0]||o[1]!=i[1])throw new r("Invalid pasword")})(n,i,n.password),n.password=null,n.Z=new E(new B(n.keys.key),t.from(I)),n.$=new D(n.keys.tt),e=K(e,z[n.X]+2)}return P(n,e,new i(e.length-10-(e.length-10)%16),0,10,!0)}flush(){const t=this,e=t.Y,n=K(e,0,e.length-10),r=K(e,e.length-10);let o=new i(0);if(n.length){const e=V.g(n);t.$.update(e);const r=t.Z.update(e);o=V.k(r)}let s=!0;if(t.signed){const e=K(V.k(t.$.digest()),0,10);for(let t=0;10>t;t++)e[t]!=r[t]&&(s=!1)}return{valid:s,data:o}}}class M{constructor(t,n){e.assign(this,{password:t,X:n-1,Y:new i(0)})}async append(e){const n=this;let r=new i(0);n.password&&(r=await(async(t,e)=>{const n=(r=new i(z[t.X]),A&&"function"==typeof u.getRandomValues?u.getRandomValues(r):b.getRandomValues(r));var r;return await R(t,e,n),H(n,t.keys.passwordVerification)})(n,n.password),n.password=null,n.Z=new E(new B(n.keys.key),t.from(I)),n.$=new D(n.keys.tt));const o=new i(r.length+e.length-e.length%16);return o.set(r,0),P(n,e,o,r.length,0)}flush(){const t=this;let e=new i(0);if(t.Y.length){const n=t.Z.update(V.g(t.Y));t.$.update(n),e=V.k(n)}const n=K(V.k(t.$.digest()),0,10);return{data:H(e,n),signature:n}}}function P(t,e,n,r,o,s){const f=e.length-o;let c;for(t.Y.length&&(e=H(t.Y,e),n=((t,e)=>{if(e&&e>t.length){const n=t;(t=new i(e)).set(n,0)}return t})(n,f-f%16)),c=0;f-16>=c;c+=16){const i=V.g(K(e,c,c+16));s&&t.$.update(i);const o=t.Z.update(i);s||t.$.update(o),n.set(V.k(o),c+r)}return t.Y=K(e,c),n}async function R(t,n,r){const o=(t=>{if(void 0===l){const e=new i((t=unescape(encodeURIComponent(t))).length);for(let n=0;n<e.length;n++)e[n]=t.charCodeAt(n);return e}return(new l).encode(t)})(n),s=await((t,e,n,r,i)=>A&&C&&"function"==typeof u.subtle.importKey?u.subtle.importKey("raw",e,n,!1,i):k.importKey(e))(0,o,v,0,S),f=await(async(t,e,n)=>A&&C&&"function"==typeof u.subtle.deriveBits?await u.subtle.deriveBits(t,e,n):k.P(e,t.salt,m.iterations,n))(e.assign({salt:r},m),s,8*(2*_[t.X]+2)),c=new i(f);t.keys={key:V.g(K(c,0,_[t.X])),tt:V.g(K(c,_[t.X],2*_[t.X])),passwordVerification:K(c,2*_[t.X])}}function H(t,e){let n=t;return t.length+e.length&&(n=new i(t.length+e.length),n.set(t,0),n.set(e,t.length)),n}function K(t,e,n){return t.subarray(e,n)}class L{constructor(t,n){e.assign(this,{password:t,passwordVerification:n}),F(this,t)}append(t){const e=this;if(e.password){const n=j(e,t.subarray(0,12));if(e.password=null,n[11]!=e.passwordVerification)throw new r("Invalid pasword");t=t.subarray(12)}return j(e,t)}flush(){return{valid:!0,data:new i(0)}}}class T{constructor(t,n){e.assign(this,{password:t,passwordVerification:n}),F(this,t)}append(t){const e=this;let n,r;if(e.password){e.password=null;const o=u.getRandomValues(new i(12));o[11]=e.passwordVerification,n=new i(t.length+o.length),n.set(x(e,o),0),r=12}else n=new i(t.length),r=0;return n.set(x(e,t),r),n}flush(){return{data:new i(0)}}}function j(t,e){const n=new i(e.length);for(let r=0;r<e.length;r++)n[r]=W(t)^e[r],O(t,n[r]);return n}function x(t,e){const n=new i(e.length);for(let r=0;r<e.length;r++)n[r]=W(t)^e[r],O(t,e[r]);return n}function F(t,e){t.keys=[305419896,591751049,878082192],t.et=new h(t.keys[0]),t.nt=new h(t.keys[2]);for(let n=0;n<e.length;n++)O(t,e.charCodeAt(n))}function O(t,e){t.et.append([e]),t.keys[0]=~t.et.get(),t.keys[1]=G(t.keys[1]+q(t.keys[0])),t.keys[1]=G(n.imul(t.keys[1],134775813)+1),t.nt.append([t.keys[1]>>>24]),t.keys[2]=~t.nt.get()}function W(t){const e=2|t.keys[2];return q(n.imul(e,1^e)>>>8)}function q(t){return 255&t}function G(t){return 4294967295&t}class J{constructor(t,{signature:n,password:r,signed:i,compressed:o,zipCrypto:s,passwordVerification:f,encryptionStrength:c},{rt:l}){const u=!!r;e.assign(this,{signature:n,encrypted:u,signed:i,compressed:o,it:o&&new t({rt:l}),ot:i&&new h,zipCrypto:s,decrypt:u&&s?new L(r,f):new U(r,i,c)})}async append(t){const e=this;return e.encrypted&&t.length&&(t=await e.decrypt.append(t)),e.compressed&&t.length&&(t=await e.it.append(t)),(!e.encrypted||e.zipCrypto)&&e.signed&&t.length&&e.ot.append(t),t}async flush(){const t=this;let e,n=new i(0);if(t.encrypted){const e=t.decrypt.flush();if(!e.valid)throw new r("Invalid signature");n=e.data}if((!t.encrypted||t.zipCrypto)&&t.signed){const n=new c(new i(4).buffer);if(e=t.ot.get(),n.setUint32(0,e),t.signature!=n.getUint32(0,!1))throw new r("Invalid signature")}return t.compressed&&(n=await t.it.append(n)||new i(0),await t.it.flush()),{data:n,signature:e}}}class N{constructor(t,{encrypted:n,signed:r,compressed:i,level:o,zipCrypto:s,password:f,passwordVerification:c,encryptionStrength:l},{rt:u}){e.assign(this,{encrypted:n,signed:r,compressed:i,st:i&&new t({level:o||5,rt:u}),ot:r&&new h,zipCrypto:s,encrypt:n&&s?new T(f,c):new M(f,l)})}async append(t){const e=this;let n=t;return e.compressed&&t.length&&(n=await e.st.append(t)),e.encrypted&&n.length&&(n=await e.encrypt.append(n)),(!e.encrypted||e.zipCrypto)&&e.signed&&t.length&&e.ot.append(t),n}async flush(){const t=this;let e,n=new i(0);if(t.compressed&&(n=await t.st.flush()||new i(0)),t.encrypted){n=await t.encrypt.append(n);const r=t.encrypt.flush();e=r.signature;const o=new i(n.length+r.data.length);o.set(n,0),o.set(r.data,n.length),n=o}return t.encrypted&&!t.zipCrypto||!t.signed||(e=t.ot.get()),{data:n,signature:e}}}const Q={init(t){t.scripts&&t.scripts.length&&importScripts.apply(void 0,t.scripts);const e=t.options;let n;self.initCodec&&self.initCodec(),e.codecType.startsWith("deflate")?n=self.Deflate:e.codecType.startsWith("inflate")&&(n=self.Inflate),X=((t,e,n)=>e.codecType.startsWith("deflate")?new N(t,e,n):e.codecType.startsWith("inflate")?new J(t,e,n):void 0)(n,e,t.config)},append:async t=>({data:await X.append(t.data)}),flush:()=>X.flush()};let X;function Y(e){return Z(e.map((([e,n])=>new t(e).fill(n,0,e))))}function Z(e){return e.reduce(((e,n)=>e.concat(t.isArray(n)?Z(n):n)),[])}addEventListener("message",(async t=>{const e=t.data,n=e.type,r=Q[n];if(r)try{e.data&&(e.data=new i(e.data));const t=await r(e)||{};if(t.type=n,t.data)try{t.data=t.data.buffer,a(t,[t.data])}catch(e){a(t)}else a(t)}catch(t){a({type:n,error:{message:t.message,stack:t.stack}})}}));const $=[0,1,2,3].concat(...Y([[2,4],[2,5],[4,6],[4,7],[8,8],[8,9],[16,10],[16,11],[32,12],[32,13],[64,14],[64,15],[2,0],[1,16],[1,17],[2,18],[2,19],[4,20],[4,21],[8,22],[8,23],[16,24],[16,25],[32,26],[32,27],[64,28],[64,29]]));function tt(){const t=this;function e(t,e){let n=0;do{n|=1&t,t>>>=1,n<<=1}while(--e>0);return n>>>1}t.ft=r=>{const i=t.ct,o=t.ut.lt,s=t.ut.wt;let f,c,l,u=-1;for(r.ht=0,r.dt=573,f=0;s>f;f++)0!==i[2*f]?(r.yt[++r.ht]=u=f,r.bt[f]=0):i[2*f+1]=0;for(;2>r.ht;)l=r.yt[++r.ht]=2>u?++u:0,i[2*l]=1,r.bt[l]=0,r.kt--,o&&(r.gt-=o[2*l+1]);for(t.vt=u,f=n.floor(r.ht/2);f>=1;f--)r.St(i,f);l=s;do{f=r.yt[1],r.yt[1]=r.yt[r.ht--],r.St(i,1),c=r.yt[1],r.yt[--r.dt]=f,r.yt[--r.dt]=c,i[2*l]=i[2*f]+i[2*c],r.bt[l]=n.max(r.bt[f],r.bt[c])+1,i[2*f+1]=i[2*c+1]=l,r.yt[1]=l++,r.St(i,1)}while(r.ht>=2);r.yt[--r.dt]=r.yt[1],(e=>{const n=t.ct,r=t.ut.lt,i=t.ut.zt,o=t.ut._t,s=t.ut.It;let f,c,l,u,a,w,h=0;for(u=0;15>=u;u++)e.At[u]=0;for(n[2*e.yt[e.dt]+1]=0,f=e.dt+1;573>f;f++)c=e.yt[f],u=n[2*n[2*c+1]+1]+1,u>s&&(u=s,h++),n[2*c+1]=u,c>t.vt||(e.At[u]++,a=0,o>c||(a=i[c-o]),w=n[2*c],e.kt+=w*(u+a),r&&(e.gt+=w*(r[2*c+1]+a)));if(0!==h){do{for(u=s-1;0===e.At[u];)u--;e.At[u]--,e.At[u+1]+=2,e.At[s]--,h-=2}while(h>0);for(u=s;0!==u;u--)for(c=e.At[u];0!==c;)l=e.yt[--f],l>t.vt||(n[2*l+1]!=u&&(e.kt+=(u-n[2*l+1])*n[2*l],n[2*l+1]=u),c--)}})(r),((t,n,r)=>{const i=[];let o,s,f,c=0;for(o=1;15>=o;o++)i[o]=c=c+r[o-1]<<1;for(s=0;n>=s;s++)f=t[2*s+1],0!==f&&(t[2*s]=e(i[f]++,f))})(i,t.vt,r.At)}}function et(t,e,n,r,i){const o=this;o.lt=t,o.zt=e,o._t=n,o.wt=r,o.It=i}tt.Ct=[0,1,2,3,4,5,6,7].concat(...Y([[2,8],[2,9],[2,10],[2,11],[4,12],[4,13],[4,14],[4,15],[8,16],[8,17],[8,18],[8,19],[16,20],[16,21],[16,22],[16,23],[32,24],[32,25],[32,26],[31,27],[1,28]])),tt.Vt=[0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,160,192,224,0],tt.Bt=[0,1,2,3,4,6,8,12,16,24,32,48,64,96,128,192,256,384,512,768,1024,1536,2048,3072,4096,6144,8192,12288,16384,24576],tt.Et=t=>256>t?$[t]:$[256+(t>>>7)],tt.Dt=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],tt.Ut=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],tt.Mt=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],tt.Pt=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];const nt=Y([[144,8],[112,9],[24,7],[8,8]]);et.Rt=Z([12,140,76,204,44,172,108,236,28,156,92,220,60,188,124,252,2,130,66,194,34,162,98,226,18,146,82,210,50,178,114,242,10,138,74,202,42,170,106,234,26,154,90,218,58,186,122,250,6,134,70,198,38,166,102,230,22,150,86,214,54,182,118,246,14,142,78,206,46,174,110,238,30,158,94,222,62,190,126,254,1,129,65,193,33,161,97,225,17,145,81,209,49,177,113,241,9,137,73,201,41,169,105,233,25,153,89,217,57,185,121,249,5,133,69,197,37,165,101,229,21,149,85,213,53,181,117,245,13,141,77,205,45,173,109,237,29,157,93,221,61,189,125,253,19,275,147,403,83,339,211,467,51,307,179,435,115,371,243,499,11,267,139,395,75,331,203,459,43,299,171,427,107,363,235,491,27,283,155,411,91,347,219,475,59,315,187,443,123,379,251,507,7,263,135,391,71,327,199,455,39,295,167,423,103,359,231,487,23,279,151,407,87,343,215,471,55,311,183,439,119,375,247,503,15,271,143,399,79,335,207,463,47,303,175,431,111,367,239,495,31,287,159,415,95,351,223,479,63,319,191,447,127,383,255,511,0,64,32,96,16,80,48,112,8,72,40,104,24,88,56,120,4,68,36,100,20,84,52,116,3,131,67,195,35,163,99,227].map(((t,e)=>[t,nt[e]])));const rt=Y([[30,5]]);function it(t,e,n,r,i){const o=this;o.Ht=t,o.Kt=e,o.Lt=n,o.Tt=r,o.jt=i}et.xt=Z([0,16,8,24,4,20,12,28,2,18,10,26,6,22,14,30,1,17,9,25,5,21,13,29,3,19,11,27,7,23].map(((t,e)=>[t,rt[e]]))),et.Ft=new et(et.Rt,tt.Dt,257,286,15),et.Ot=new et(et.xt,tt.Ut,0,30,15),et.Wt=new et(null,tt.Mt,0,19,7);const ot=[new it(0,0,0,0,0),new it(4,4,8,4,1),new it(4,5,16,8,1),new it(4,6,32,32,1),new it(4,4,16,16,2),new it(8,16,32,32,2),new it(8,16,128,128,2),new it(8,32,128,256,2),new it(32,128,258,1024,2),new it(32,258,258,4096,2)],st=["need dictionary","stream end","","","stream error","data error","","buffer error","",""];function ft(t,e,n,r){const i=t[2*e],o=t[2*n];return o>i||i==o&&r[e]<=r[n]}function ct(){const t=this;let e,r,s,f,c,l,u,a,w,h,d,p,y,b,k,g,v,m,S,z,_,I,A,C,V,B,E,D,U,M,P,R,H;const K=new tt,L=new tt,T=new tt;let j,x,F,O,W,q;function G(){let e;for(e=0;286>e;e++)P[2*e]=0;for(e=0;30>e;e++)R[2*e]=0;for(e=0;19>e;e++)H[2*e]=0;P[512]=1,t.kt=t.gt=0,x=F=0}function J(t,e){let n,r=-1,i=t[1],o=0,s=7,f=4;0===i&&(s=138,f=3),t[2*(e+1)+1]=65535;for(let c=0;e>=c;c++)n=i,i=t[2*(c+1)+1],++o<s&&n==i||(f>o?H[2*n]+=o:0!==n?(n!=r&&H[2*n]++,H[32]++):o>10?H[36]++:H[34]++,o=0,r=n,0===i?(s=138,f=3):n==i?(s=6,f=3):(s=7,f=4))}function N(e){t.qt[t.pending++]=e}function Q(t){N(255&t),N(t>>>8&255)}function X(t,e){let n;const r=e;q>16-r?(n=t,W|=n<<q&65535,Q(W),W=n>>>16-q,q+=r-16):(W|=t<<q&65535,q+=r)}function Y(t,e){const n=2*t;X(65535&e[n],65535&e[n+1])}function Z(t,e){let n,r,i=-1,o=t[1],s=0,f=7,c=4;for(0===o&&(f=138,c=3),n=0;e>=n;n++)if(r=o,o=t[2*(n+1)+1],++s>=f||r!=o){if(c>s)do{Y(r,H)}while(0!=--s);else 0!==r?(r!=i&&(Y(r,H),s--),Y(16,H),X(s-3,2)):s>10?(Y(18,H),X(s-11,7)):(Y(17,H),X(s-3,3));s=0,i=r,0===o?(f=138,c=3):r==o?(f=6,c=3):(f=7,c=4)}}function $(){16==q?(Q(W),W=0,q=0):8>q||(N(255&W),W>>>=8,q-=8)}function nt(e,r){let i,o,s;if(t.Gt[x]=e,t.Jt[x]=255&r,x++,0===e?P[2*r]++:(F++,e--,P[2*(tt.Ct[r]+256+1)]++,R[2*tt.Et(e)]++),0==(8191&x)&&E>2){for(i=8*x,o=_-v,s=0;30>s;s++)i+=R[2*s]*(5+tt.Ut[s]);if(i>>>=3,F<n.floor(x/2)&&i<n.floor(o/2))return!0}return x==j-1}function rt(e,n){let r,i,o,s,f=0;if(0!==x)do{r=t.Gt[f],i=t.Jt[f],f++,0===r?Y(i,e):(o=tt.Ct[i],Y(o+256+1,e),s=tt.Dt[o],0!==s&&(i-=tt.Vt[o],X(i,s)),r--,o=tt.Et(r),Y(o,n),s=tt.Ut[o],0!==s&&(r-=tt.Bt[o],X(r,s)))}while(x>f);Y(256,e),O=e[513]}function it(){q>8?Q(W):q>0&&N(255&W),W=0,q=0}function ct(e,n,r){X(0+(r?1:0),3),((e,n)=>{it(),O=8,Q(n),Q(~n),t.qt.set(a.subarray(e,e+n),t.pending),t.pending+=n})(e,n)}function lt(n){((e,n,r)=>{let i,o,s=0;E>0?(K.ft(t),L.ft(t),s=(()=>{let e;for(J(P,K.vt),J(R,L.vt),T.ft(t),e=18;e>=3&&0===H[2*tt.Pt[e]+1];e--);return t.kt+=14+3*(e+1),e})(),i=t.kt+3+7>>>3,o=t.gt+3+7>>>3,o>i||(i=o)):i=o=n+5,n+4>i||-1==e?o==i?(X(2+(r?1:0),3),rt(et.Rt,et.xt)):(X(4+(r?1:0),3),((t,e,n)=>{let r;for(X(t-257,5),X(e-1,5),X(n-4,4),r=0;n>r;r++)X(H[2*tt.Pt[r]+1],3);Z(P,t-1),Z(R,e-1)})(K.vt+1,L.vt+1,s+1),rt(P,R)):ct(e,n,r),G(),r&&it()})(0>v?-1:v,_-v,n),v=_,e.Nt()}function ut(){let t,n,r,i;do{if(i=w-A-_,0===i&&0===_&&0===A)i=c;else if(-1==i)i--;else if(_>=c+c-262){a.set(a.subarray(c,c+c),0),I-=c,_-=c,v-=c,t=y,r=t;do{n=65535&d[--r],d[r]=c>n?0:n-c}while(0!=--t);t=c,r=t;do{n=65535&h[--r],h[r]=c>n?0:n-c}while(0!=--t);i+=c}if(0===e.Qt)return;t=e.Xt(a,_+A,i),A+=t,3>A||(p=255&a[_],p=(p<<g^255&a[_+1])&k)}while(262>A&&0!==e.Qt)}function at(t){let e,n,r=V,i=_,o=C;const s=_>c-262?_-(c-262):0;let f=M;const l=u,w=_+258;let d=a[i+o-1],p=a[i+o];U>C||(r>>=2),f>A&&(f=A);do{if(e=t,a[e+o]==p&&a[e+o-1]==d&&a[e]==a[i]&&a[++e]==a[i+1]){i+=2,e++;do{}while(a[++i]==a[++e]&&a[++i]==a[++e]&&a[++i]==a[++e]&&a[++i]==a[++e]&&a[++i]==a[++e]&&a[++i]==a[++e]&&a[++i]==a[++e]&&a[++i]==a[++e]&&w>i);if(n=258-(w-i),i=w-258,n>o){if(I=t,o=n,n>=f)break;d=a[i+o-1],p=a[i+o]}}}while((t=65535&h[t&l])>s&&0!=--r);return o>A?A:o}t.bt=[],t.At=[],t.yt=[],P=[],R=[],H=[],t.St=(e,n)=>{const r=t.yt,i=r[n];let o=n<<1;for(;o<=t.ht&&(o<t.ht&&ft(e,r[o+1],r[o],t.bt)&&o++,!ft(e,i,r[o],t.bt));)r[n]=r[o],n=o,o<<=1;r[n]=i},t.Yt=(e,S,I,x,F,J)=>(x||(x=8),F||(F=8),J||(J=0),e.Zt=null,-1==S&&(S=6),1>F||F>9||8!=x||9>I||I>15||0>S||S>9||0>J||J>2?-2:(e.$t=t,l=I,c=1<<l,u=c-1,b=F+7,y=1<<b,k=y-1,g=n.floor((b+3-1)/3),a=new i(2*c),h=[],d=[],j=1<<F+6,t.qt=new i(4*j),s=4*j,t.Gt=new o(j),t.Jt=new i(j),E=S,D=J,(e=>(e.te=e.ee=0,e.Zt=null,t.pending=0,t.ne=0,r=113,f=0,K.ct=P,K.ut=et.Ft,L.ct=R,L.ut=et.Ot,T.ct=H,T.ut=et.Wt,W=0,q=0,O=8,G(),(()=>{w=2*c,d[y-1]=0;for(let t=0;y-1>t;t++)d[t]=0;B=ot[E].Kt,U=ot[E].Ht,M=ot[E].Lt,V=ot[E].Tt,_=0,v=0,A=0,m=C=2,z=0,p=0})(),0))(e))),t.re=()=>42!=r&&113!=r&&666!=r?-2:(t.Jt=null,t.Gt=null,t.qt=null,d=null,h=null,a=null,t.$t=null,113==r?-3:0),t.ie=(t,e,n)=>{let r=0;return-1==e&&(e=6),0>e||e>9||0>n||n>2?-2:(ot[E].jt!=ot[e].jt&&0!==t.te&&(r=t.st(1)),E!=e&&(E=e,B=ot[E].Kt,U=ot[E].Ht,M=ot[E].Lt,V=ot[E].Tt),D=n,r)},t.oe=(t,e,n)=>{let i,o=n,s=0;if(!e||42!=r)return-2;if(3>o)return 0;for(o>c-262&&(o=c-262,s=n-o),a.set(e.subarray(s,s+o),0),_=o,v=o,p=255&a[0],p=(p<<g^255&a[1])&k,i=0;o-3>=i;i++)p=(p<<g^255&a[i+2])&k,h[i&u]=d[p],d[p]=i;return 0},t.st=(n,i)=>{let o,w,b,V,U;if(i>4||0>i)return-2;if(!n.se||!n.fe&&0!==n.Qt||666==r&&4!=i)return n.Zt=st[4],-2;if(0===n.ce)return n.Zt=st[7],-5;var M;if(e=n,V=f,f=i,42==r&&(w=8+(l-8<<4)<<8,b=(E-1&255)>>1,b>3&&(b=3),w|=b<<6,0!==_&&(w|=32),w+=31-w%31,r=113,N((M=w)>>8&255),N(255&M)),0!==t.pending){if(e.Nt(),0===e.ce)return f=-1,0}else if(0===e.Qt&&V>=i&&4!=i)return e.Zt=st[7],-5;if(666==r&&0!==e.Qt)return n.Zt=st[7],-5;if(0!==e.Qt||0!==A||0!=i&&666!=r){switch(U=-1,ot[E].jt){case 0:U=(t=>{let n,r=65535;for(r>s-5&&(r=s-5);;){if(1>=A){if(ut(),0===A&&0==t)return 0;if(0===A)break}if(_+=A,A=0,n=v+r,(0===_||_>=n)&&(A=_-n,_=n,lt(!1),0===e.ce))return 0;if(_-v>=c-262&&(lt(!1),0===e.ce))return 0}return lt(4==t),0===e.ce?4==t?2:0:4==t?3:1})(i);break;case 1:U=(t=>{let n,r=0;for(;;){if(262>A){if(ut(),262>A&&0==t)return 0;if(0===A)break}if(3>A||(p=(p<<g^255&a[_+2])&k,r=65535&d[p],h[_&u]=d[p],d[p]=_),0===r||(_-r&65535)>c-262||2!=D&&(m=at(r)),3>m)n=nt(0,255&a[_]),A--,_++;else if(n=nt(_-I,m-3),A-=m,m>B||3>A)_+=m,m=0,p=255&a[_],p=(p<<g^255&a[_+1])&k;else{m--;do{_++,p=(p<<g^255&a[_+2])&k,r=65535&d[p],h[_&u]=d[p],d[p]=_}while(0!=--m);_++}if(n&&(lt(!1),0===e.ce))return 0}return lt(4==t),0===e.ce?4==t?2:0:4==t?3:1})(i);break;case 2:U=(t=>{let n,r,i=0;for(;;){if(262>A){if(ut(),262>A&&0==t)return 0;if(0===A)break}if(3>A||(p=(p<<g^255&a[_+2])&k,i=65535&d[p],h[_&u]=d[p],d[p]=_),C=m,S=I,m=2,0!==i&&B>C&&c-262>=(_-i&65535)&&(2!=D&&(m=at(i)),5>=m&&(1==D||3==m&&_-I>4096)&&(m=2)),3>C||m>C)if(0!==z){if(n=nt(0,255&a[_-1]),n&&lt(!1),_++,A--,0===e.ce)return 0}else z=1,_++,A--;else{r=_+A-3,n=nt(_-1-S,C-3),A-=C-1,C-=2;do{++_>r||(p=(p<<g^255&a[_+2])&k,i=65535&d[p],h[_&u]=d[p],d[p]=_)}while(0!=--C);if(z=0,m=2,_++,n&&(lt(!1),0===e.ce))return 0}}return 0!==z&&(n=nt(0,255&a[_-1]),z=0),lt(4==t),0===e.ce?4==t?2:0:4==t?3:1})(i)}if(2!=U&&3!=U||(r=666),0==U||2==U)return 0===e.ce&&(f=-1),0;if(1==U){if(1==i)X(2,3),Y(256,et.Rt),$(),9>1+O+10-q&&(X(2,3),Y(256,et.Rt),$()),O=7;else if(ct(0,0,!1),3==i)for(o=0;y>o;o++)d[o]=0;if(e.Nt(),0===e.ce)return f=-1,0}}return 4!=i?0:1}}function lt(){const t=this;t.le=0,t.ue=0,t.Qt=0,t.te=0,t.ce=0,t.ee=0}function ut(t){const e=new lt,o=(s=t&&t.rt?t.rt:65536)+5*(n.floor(s/16383)+1);var s;const f=new i(o);let c=t?t.level:-1;void 0===c&&(c=-1),e.Yt(c),e.se=f,this.append=(t,n)=>{let s,c,l=0,u=0,a=0;const w=[];if(t.length){e.le=0,e.fe=t,e.Qt=t.length;do{if(e.ue=0,e.ce=o,s=e.st(0),0!=s)throw new r("deflating: "+e.Zt);e.ue&&(e.ue==o?w.push(new i(f)):w.push(f.slice(0,e.ue))),a+=e.ue,n&&e.le>0&&e.le!=l&&(n(e.le),l=e.le)}while(e.Qt>0||0===e.ce);return w.length>1?(c=new i(a),w.forEach((t=>{c.set(t,u),u+=t.length}))):c=w[0]||new i(0),c}},this.flush=()=>{let t,n,s=0,c=0;const l=[];do{if(e.ue=0,e.ce=o,t=e.st(4),1!=t&&0!=t)throw new r("deflating: "+e.Zt);o-e.ce>0&&l.push(f.slice(0,e.ue)),c+=e.ue}while(e.Qt>0||0===e.ce);return e.re(),n=new i(c),l.forEach((t=>{n.set(t,s),s+=t.length})),n}}lt.prototype={Yt:function(t,e){const n=this;return n.$t=new ct,e||(e=15),n.$t.Yt(n,t,e)},st:function(t){const e=this;return e.$t?e.$t.st(e,t):-2},re:function(){const t=this;if(!t.$t)return-2;const e=t.$t.re();return t.$t=null,e},ie:function(t,e){const n=this;return n.$t?n.$t.ie(n,t,e):-2},oe:function(t,e){const n=this;return n.$t?n.$t.oe(n,t,e):-2},Xt:function(t,e,n){const r=this;let i=r.Qt;return i>n&&(i=n),0===i?0:(r.Qt-=i,t.set(r.fe.subarray(r.le,r.le+i),e),r.le+=i,r.te+=i,i)},Nt:function(){const t=this;let e=t.$t.pending;e>t.ce&&(e=t.ce),0!==e&&(t.se.set(t.$t.qt.subarray(t.$t.ne,t.$t.ne+e),t.ue),t.ue+=e,t.$t.ne+=e,t.ee+=e,t.ce-=e,t.$t.pending-=e,0===t.$t.pending&&(t.$t.ne=0))}};const at=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535],wt=[96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,192,80,7,10,0,8,96,0,8,32,0,9,160,0,8,0,0,8,128,0,8,64,0,9,224,80,7,6,0,8,88,0,8,24,0,9,144,83,7,59,0,8,120,0,8,56,0,9,208,81,7,17,0,8,104,0,8,40,0,9,176,0,8,8,0,8,136,0,8,72,0,9,240,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,200,81,7,13,0,8,100,0,8,36,0,9,168,0,8,4,0,8,132,0,8,68,0,9,232,80,7,8,0,8,92,0,8,28,0,9,152,84,7,83,0,8,124,0,8,60,0,9,216,82,7,23,0,8,108,0,8,44,0,9,184,0,8,12,0,8,140,0,8,76,0,9,248,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,196,81,7,11,0,8,98,0,8,34,0,9,164,0,8,2,0,8,130,0,8,66,0,9,228,80,7,7,0,8,90,0,8,26,0,9,148,84,7,67,0,8,122,0,8,58,0,9,212,82,7,19,0,8,106,0,8,42,0,9,180,0,8,10,0,8,138,0,8,74,0,9,244,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,204,81,7,15,0,8,102,0,8,38,0,9,172,0,8,6,0,8,134,0,8,70,0,9,236,80,7,9,0,8,94,0,8,30,0,9,156,84,7,99,0,8,126,0,8,62,0,9,220,82,7,27,0,8,110,0,8,46,0,9,188,0,8,14,0,8,142,0,8,78,0,9,252,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,194,80,7,10,0,8,97,0,8,33,0,9,162,0,8,1,0,8,129,0,8,65,0,9,226,80,7,6,0,8,89,0,8,25,0,9,146,83,7,59,0,8,121,0,8,57,0,9,210,81,7,17,0,8,105,0,8,41,0,9,178,0,8,9,0,8,137,0,8,73,0,9,242,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,202,81,7,13,0,8,101,0,8,37,0,9,170,0,8,5,0,8,133,0,8,69,0,9,234,80,7,8,0,8,93,0,8,29,0,9,154,84,7,83,0,8,125,0,8,61,0,9,218,82,7,23,0,8,109,0,8,45,0,9,186,0,8,13,0,8,141,0,8,77,0,9,250,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,198,81,7,11,0,8,99,0,8,35,0,9,166,0,8,3,0,8,131,0,8,67,0,9,230,80,7,7,0,8,91,0,8,27,0,9,150,84,7,67,0,8,123,0,8,59,0,9,214,82,7,19,0,8,107,0,8,43,0,9,182,0,8,11,0,8,139,0,8,75,0,9,246,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,206,81,7,15,0,8,103,0,8,39,0,9,174,0,8,7,0,8,135,0,8,71,0,9,238,80,7,9,0,8,95,0,8,31,0,9,158,84,7,99,0,8,127,0,8,63,0,9,222,82,7,27,0,8,111,0,8,47,0,9,190,0,8,15,0,8,143,0,8,79,0,9,254,96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,193,80,7,10,0,8,96,0,8,32,0,9,161,0,8,0,0,8,128,0,8,64,0,9,225,80,7,6,0,8,88,0,8,24,0,9,145,83,7,59,0,8,120,0,8,56,0,9,209,81,7,17,0,8,104,0,8,40,0,9,177,0,8,8,0,8,136,0,8,72,0,9,241,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,201,81,7,13,0,8,100,0,8,36,0,9,169,0,8,4,0,8,132,0,8,68,0,9,233,80,7,8,0,8,92,0,8,28,0,9,153,84,7,83,0,8,124,0,8,60,0,9,217,82,7,23,0,8,108,0,8,44,0,9,185,0,8,12,0,8,140,0,8,76,0,9,249,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,197,81,7,11,0,8,98,0,8,34,0,9,165,0,8,2,0,8,130,0,8,66,0,9,229,80,7,7,0,8,90,0,8,26,0,9,149,84,7,67,0,8,122,0,8,58,0,9,213,82,7,19,0,8,106,0,8,42,0,9,181,0,8,10,0,8,138,0,8,74,0,9,245,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,205,81,7,15,0,8,102,0,8,38,0,9,173,0,8,6,0,8,134,0,8,70,0,9,237,80,7,9,0,8,94,0,8,30,0,9,157,84,7,99,0,8,126,0,8,62,0,9,221,82,7,27,0,8,110,0,8,46,0,9,189,0,8,14,0,8,142,0,8,78,0,9,253,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,195,80,7,10,0,8,97,0,8,33,0,9,163,0,8,1,0,8,129,0,8,65,0,9,227,80,7,6,0,8,89,0,8,25,0,9,147,83,7,59,0,8,121,0,8,57,0,9,211,81,7,17,0,8,105,0,8,41,0,9,179,0,8,9,0,8,137,0,8,73,0,9,243,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,203,81,7,13,0,8,101,0,8,37,0,9,171,0,8,5,0,8,133,0,8,69,0,9,235,80,7,8,0,8,93,0,8,29,0,9,155,84,7,83,0,8,125,0,8,61,0,9,219,82,7,23,0,8,109,0,8,45,0,9,187,0,8,13,0,8,141,0,8,77,0,9,251,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,199,81,7,11,0,8,99,0,8,35,0,9,167,0,8,3,0,8,131,0,8,67,0,9,231,80,7,7,0,8,91,0,8,27,0,9,151,84,7,67,0,8,123,0,8,59,0,9,215,82,7,19,0,8,107,0,8,43,0,9,183,0,8,11,0,8,139,0,8,75,0,9,247,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,207,81,7,15,0,8,103,0,8,39,0,9,175,0,8,7,0,8,135,0,8,71,0,9,239,80,7,9,0,8,95,0,8,31,0,9,159,84,7,99,0,8,127,0,8,63,0,9,223,82,7,27,0,8,111,0,8,47,0,9,191,0,8,15,0,8,143,0,8,79,0,9,255],ht=[80,5,1,87,5,257,83,5,17,91,5,4097,81,5,5,89,5,1025,85,5,65,93,5,16385,80,5,3,88,5,513,84,5,33,92,5,8193,82,5,9,90,5,2049,86,5,129,192,5,24577,80,5,2,87,5,385,83,5,25,91,5,6145,81,5,7,89,5,1537,85,5,97,93,5,24577,80,5,4,88,5,769,84,5,49,92,5,12289,82,5,13,90,5,3073,86,5,193,192,5,24577],dt=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],pt=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,112,112],yt=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],bt=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];function kt(){let t,e,n,r,i,o;function s(t,e,s,f,c,l,u,a,w,h,d){let p,y,b,k,g,v,m,S,z,_,I,A,C,V,B;_=0,g=s;do{n[t[e+_]]++,_++,g--}while(0!==g);if(n[0]==s)return u[0]=-1,a[0]=0,0;for(S=a[0],v=1;15>=v&&0===n[v];v++);for(m=v,v>S&&(S=v),g=15;0!==g&&0===n[g];g--);for(b=g,S>g&&(S=g),a[0]=S,V=1<<v;g>v;v++,V<<=1)if(0>(V-=n[v]))return-3;if(0>(V-=n[g]))return-3;for(n[g]+=V,o[1]=v=0,_=1,C=2;0!=--g;)o[C]=v+=n[_],C++,_++;g=0,_=0;do{0!==(v=t[e+_])&&(d[o[v]++]=g),_++}while(++g<s);for(s=o[b],o[0]=g=0,_=0,k=-1,A=-S,i[0]=0,I=0,B=0;b>=m;m++)for(p=n[m];0!=p--;){for(;m>A+S;){if(k++,A+=S,B=b-A,B=B>S?S:B,(y=1<<(v=m-A))>p+1&&(y-=p+1,C=m,B>v))for(;++v<B&&(y<<=1)>n[++C];)y-=n[C];if(B=1<<v,h[0]+B>1440)return-3;i[k]=I=h[0],h[0]+=B,0!==k?(o[k]=g,r[0]=v,r[1]=S,v=g>>>A-S,r[2]=I-i[k-1]-v,w.set(r,3*(i[k-1]+v))):u[0]=I}for(r[1]=m-A,s>_?d[_]<f?(r[0]=256>d[_]?0:96,r[2]=d[_++]):(r[0]=l[d[_]-f]+16+64,r[2]=c[d[_++]-f]):r[0]=192,y=1<<m-A,v=g>>>A;B>v;v+=y)w.set(r,3*(I+v));for(v=1<<m-1;0!=(g&v);v>>>=1)g^=v;for(g^=v,z=(1<<A)-1;(g&z)!=o[k];)k--,A-=S,z=(1<<A)-1}return 0!==V&&1!=b?-5:0}function c(s){let c;for(t||(t=[],e=[],n=new f(16),r=[],i=new f(15),o=new f(16)),e.length<s&&(e=[]),c=0;s>c;c++)e[c]=0;for(c=0;16>c;c++)n[c]=0;for(c=0;3>c;c++)r[c]=0;i.set(n.subarray(0,15),0),o.set(n.subarray(0,16),0)}this.ae=(n,r,i,o,f)=>{let l;return c(19),t[0]=0,l=s(n,0,19,19,null,null,i,r,o,t,e),-3==l?f.Zt="oversubscribed dynamic bit lengths tree":-5!=l&&0!==r[0]||(f.Zt="incomplete dynamic bit lengths tree",l=-3),l},this.we=(n,r,i,o,f,l,u,a,w)=>{let h;return c(288),t[0]=0,h=s(i,0,n,257,dt,pt,l,o,a,t,e),0!=h||0===o[0]?(-3==h?w.Zt="oversubscribed literal/length tree":-4!=h&&(w.Zt="incomplete literal/length tree",h=-3),h):(c(288),h=s(i,n,r,0,yt,bt,u,f,a,t,e),0!=h||0===f[0]&&n>257?(-3==h?w.Zt="oversubscribed distance tree":-5==h?(w.Zt="incomplete distance tree",h=-3):-4!=h&&(w.Zt="empty distance tree with lengths",h=-3),h):0)}}function gt(){const t=this;let e,n,r,i,o=0,s=0,f=0,c=0,l=0,u=0,a=0,w=0,h=0,d=0;function p(t,e,n,r,i,o,s,f){let c,l,u,a,w,h,d,p,y,b,k,g,v,m,S,z;d=f.le,p=f.Qt,w=s.he,h=s.de,y=s.write,b=y<s.read?s.read-y-1:s.end-y,k=at[t],g=at[e];do{for(;20>h;)p--,w|=(255&f.pe(d++))<<h,h+=8;if(c=w&k,l=n,u=r,z=3*(u+c),0!==(a=l[z]))for(;;){if(w>>=l[z+1],h-=l[z+1],0!=(16&a)){for(a&=15,v=l[z+2]+(w&at[a]),w>>=a,h-=a;15>h;)p--,w|=(255&f.pe(d++))<<h,h+=8;for(c=w&g,l=i,u=o,z=3*(u+c),a=l[z];;){if(w>>=l[z+1],h-=l[z+1],0!=(16&a)){for(a&=15;a>h;)p--,w|=(255&f.pe(d++))<<h,h+=8;if(m=l[z+2]+(w&at[a]),w>>=a,h-=a,b-=v,m>y){S=y-m;do{S+=s.end}while(0>S);if(a=s.end-S,v>a){if(v-=a,y-S>0&&a>y-S)do{s.ye[y++]=s.ye[S++]}while(0!=--a);else s.ye.set(s.ye.subarray(S,S+a),y),y+=a,S+=a,a=0;S=0}}else S=y-m,y-S>0&&2>y-S?(s.ye[y++]=s.ye[S++],s.ye[y++]=s.ye[S++],v-=2):(s.ye.set(s.ye.subarray(S,S+2),y),y+=2,S+=2,v-=2);if(y-S>0&&v>y-S)do{s.ye[y++]=s.ye[S++]}while(0!=--v);else s.ye.set(s.ye.subarray(S,S+v),y),y+=v,S+=v,v=0;break}if(0!=(64&a))return f.Zt="invalid distance code",v=f.Qt-p,v=v>h>>3?h>>3:v,p+=v,d-=v,h-=v<<3,s.he=w,s.de=h,f.Qt=p,f.te+=d-f.le,f.le=d,s.write=y,-3;c+=l[z+2],c+=w&at[a],z=3*(u+c),a=l[z]}break}if(0!=(64&a))return 0!=(32&a)?(v=f.Qt-p,v=v>h>>3?h>>3:v,p+=v,d-=v,h-=v<<3,s.he=w,s.de=h,f.Qt=p,f.te+=d-f.le,f.le=d,s.write=y,1):(f.Zt="invalid literal/length code",v=f.Qt-p,v=v>h>>3?h>>3:v,p+=v,d-=v,h-=v<<3,s.he=w,s.de=h,f.Qt=p,f.te+=d-f.le,f.le=d,s.write=y,-3);if(c+=l[z+2],c+=w&at[a],z=3*(u+c),0===(a=l[z])){w>>=l[z+1],h-=l[z+1],s.ye[y++]=l[z+2],b--;break}}else w>>=l[z+1],h-=l[z+1],s.ye[y++]=l[z+2],b--}while(b>=258&&p>=10);return v=f.Qt-p,v=v>h>>3?h>>3:v,p+=v,d-=v,h-=v<<3,s.he=w,s.de=h,f.Qt=p,f.te+=d-f.le,f.le=d,s.write=y,0}t.init=(t,o,s,f,c,l)=>{e=0,a=t,w=o,r=s,h=f,i=c,d=l,n=null},t.be=(t,y,b)=>{let k,g,v,m,S,z,_,I=0,A=0,C=0;for(C=y.le,m=y.Qt,I=t.he,A=t.de,S=t.write,z=S<t.read?t.read-S-1:t.end-S;;)switch(e){case 0:if(z>=258&&m>=10&&(t.he=I,t.de=A,y.Qt=m,y.te+=C-y.le,y.le=C,t.write=S,b=p(a,w,r,h,i,d,t,y),C=y.le,m=y.Qt,I=t.he,A=t.de,S=t.write,z=S<t.read?t.read-S-1:t.end-S,0!=b)){e=1==b?7:9;break}f=a,n=r,s=h,e=1;case 1:for(k=f;k>A;){if(0===m)return t.he=I,t.de=A,y.Qt=m,y.te+=C-y.le,y.le=C,t.write=S,t.ke(y,b);b=0,m--,I|=(255&y.pe(C++))<<A,A+=8}if(g=3*(s+(I&at[k])),I>>>=n[g+1],A-=n[g+1],v=n[g],0===v){c=n[g+2],e=6;break}if(0!=(16&v)){l=15&v,o=n[g+2],e=2;break}if(0==(64&v)){f=v,s=g/3+n[g+2];break}if(0!=(32&v)){e=7;break}return e=9,y.Zt="invalid literal/length code",b=-3,t.he=I,t.de=A,y.Qt=m,y.te+=C-y.le,y.le=C,t.write=S,t.ke(y,b);case 2:for(k=l;k>A;){if(0===m)return t.he=I,t.de=A,y.Qt=m,y.te+=C-y.le,y.le=C,t.write=S,t.ke(y,b);b=0,m--,I|=(255&y.pe(C++))<<A,A+=8}o+=I&at[k],I>>=k,A-=k,f=w,n=i,s=d,e=3;case 3:for(k=f;k>A;){if(0===m)return t.he=I,t.de=A,y.Qt=m,y.te+=C-y.le,y.le=C,t.write=S,t.ke(y,b);b=0,m--,I|=(255&y.pe(C++))<<A,A+=8}if(g=3*(s+(I&at[k])),I>>=n[g+1],A-=n[g+1],v=n[g],0!=(16&v)){l=15&v,u=n[g+2],e=4;break}if(0==(64&v)){f=v,s=g/3+n[g+2];break}return e=9,y.Zt="invalid distance code",b=-3,t.he=I,t.de=A,y.Qt=m,y.te+=C-y.le,y.le=C,t.write=S,t.ke(y,b);case 4:for(k=l;k>A;){if(0===m)return t.he=I,t.de=A,y.Qt=m,y.te+=C-y.le,y.le=C,t.write=S,t.ke(y,b);b=0,m--,I|=(255&y.pe(C++))<<A,A+=8}u+=I&at[k],I>>=k,A-=k,e=5;case 5:for(_=S-u;0>_;)_+=t.end;for(;0!==o;){if(0===z&&(S==t.end&&0!==t.read&&(S=0,z=S<t.read?t.read-S-1:t.end-S),0===z&&(t.write=S,b=t.ke(y,b),S=t.write,z=S<t.read?t.read-S-1:t.end-S,S==t.end&&0!==t.read&&(S=0,z=S<t.read?t.read-S-1:t.end-S),0===z)))return t.he=I,t.de=A,y.Qt=m,y.te+=C-y.le,y.le=C,t.write=S,t.ke(y,b);t.ye[S++]=t.ye[_++],z--,_==t.end&&(_=0),o--}e=0;break;case 6:if(0===z&&(S==t.end&&0!==t.read&&(S=0,z=S<t.read?t.read-S-1:t.end-S),0===z&&(t.write=S,b=t.ke(y,b),S=t.write,z=S<t.read?t.read-S-1:t.end-S,S==t.end&&0!==t.read&&(S=0,z=S<t.read?t.read-S-1:t.end-S),0===z)))return t.he=I,t.de=A,y.Qt=m,y.te+=C-y.le,y.le=C,t.write=S,t.ke(y,b);b=0,t.ye[S++]=c,z--,e=0;break;case 7:if(A>7&&(A-=8,m++,C--),t.write=S,b=t.ke(y,b),S=t.write,z=S<t.read?t.read-S-1:t.end-S,t.read!=t.write)return t.he=I,t.de=A,y.Qt=m,y.te+=C-y.le,y.le=C,t.write=S,t.ke(y,b);e=8;case 8:return b=1,t.he=I,t.de=A,y.Qt=m,y.te+=C-y.le,y.le=C,t.write=S,t.ke(y,b);case 9:return b=-3,t.he=I,t.de=A,y.Qt=m,y.te+=C-y.le,y.le=C,t.write=S,t.ke(y,b);default:return b=-2,t.he=I,t.de=A,y.Qt=m,y.te+=C-y.le,y.le=C,t.write=S,t.ke(y,b)}},t.ge=()=>{}}kt.ve=(t,e,n,r)=>(t[0]=9,e[0]=5,n[0]=wt,r[0]=ht,0);const vt=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function mt(t,e){const n=this;let r,o=0,s=0,c=0,l=0;const u=[0],a=[0],w=new gt;let h=0,d=new f(4320);const p=new kt;n.de=0,n.he=0,n.ye=new i(e),n.end=e,n.read=0,n.write=0,n.reset=(t,e)=>{e&&(e[0]=0),6==o&&w.ge(t),o=0,n.de=0,n.he=0,n.read=n.write=0},n.reset(t,null),n.ke=(t,e)=>{let r,i,o;return i=t.ue,o=n.read,r=(o>n.write?n.end:n.write)-o,r>t.ce&&(r=t.ce),0!==r&&-5==e&&(e=0),t.ce-=r,t.ee+=r,t.se.set(n.ye.subarray(o,o+r),i),i+=r,o+=r,o==n.end&&(o=0,n.write==n.end&&(n.write=0),r=n.write-o,r>t.ce&&(r=t.ce),0!==r&&-5==e&&(e=0),t.ce-=r,t.ee+=r,t.se.set(n.ye.subarray(o,o+r),i),i+=r,o+=r),t.ue=i,n.read=o,e},n.be=(t,e)=>{let i,f,y,b,k,g,v,m;for(b=t.le,k=t.Qt,f=n.he,y=n.de,g=n.write,v=g<n.read?n.read-g-1:n.end-g;;){let S,z,_,I,A,C,V,B;switch(o){case 0:for(;3>y;){if(0===k)return n.he=f,n.de=y,t.Qt=k,t.te+=b-t.le,t.le=b,n.write=g,n.ke(t,e);e=0,k--,f|=(255&t.pe(b++))<<y,y+=8}switch(i=7&f,h=1&i,i>>>1){case 0:f>>>=3,y-=3,i=7&y,f>>>=i,y-=i,o=1;break;case 1:S=[],z=[],_=[[]],I=[[]],kt.ve(S,z,_,I),w.init(S[0],z[0],_[0],0,I[0],0),f>>>=3,y-=3,o=6;break;case 2:f>>>=3,y-=3,o=3;break;case 3:return f>>>=3,y-=3,o=9,t.Zt="invalid block type",e=-3,n.he=f,n.de=y,t.Qt=k,t.te+=b-t.le,t.le=b,n.write=g,n.ke(t,e)}break;case 1:for(;32>y;){if(0===k)return n.he=f,n.de=y,t.Qt=k,t.te+=b-t.le,t.le=b,n.write=g,n.ke(t,e);e=0,k--,f|=(255&t.pe(b++))<<y,y+=8}if((~f>>>16&65535)!=(65535&f))return o=9,t.Zt="invalid stored block lengths",e=-3,n.he=f,n.de=y,t.Qt=k,t.te+=b-t.le,t.le=b,n.write=g,n.ke(t,e);s=65535&f,f=y=0,o=0!==s?2:0!==h?7:0;break;case 2:if(0===k)return n.he=f,n.de=y,t.Qt=k,t.te+=b-t.le,t.le=b,n.write=g,n.ke(t,e);if(0===v&&(g==n.end&&0!==n.read&&(g=0,v=g<n.read?n.read-g-1:n.end-g),0===v&&(n.write=g,e=n.ke(t,e),g=n.write,v=g<n.read?n.read-g-1:n.end-g,g==n.end&&0!==n.read&&(g=0,v=g<n.read?n.read-g-1:n.end-g),0===v)))return n.he=f,n.de=y,t.Qt=k,t.te+=b-t.le,t.le=b,n.write=g,n.ke(t,e);if(e=0,i=s,i>k&&(i=k),i>v&&(i=v),n.ye.set(t.Xt(b,i),g),b+=i,k-=i,g+=i,v-=i,0!=(s-=i))break;o=0!==h?7:0;break;case 3:for(;14>y;){if(0===k)return n.he=f,n.de=y,t.Qt=k,t.te+=b-t.le,t.le=b,n.write=g,n.ke(t,e);e=0,k--,f|=(255&t.pe(b++))<<y,y+=8}if(c=i=16383&f,(31&i)>29||(i>>5&31)>29)return o=9,t.Zt="too many length or distance symbols",e=-3,n.he=f,n.de=y,t.Qt=k,t.te+=b-t.le,t.le=b,n.write=g,n.ke(t,e);if(i=258+(31&i)+(i>>5&31),!r||r.length<i)r=[];else for(m=0;i>m;m++)r[m]=0;f>>>=14,y-=14,l=0,o=4;case 4:for(;4+(c>>>10)>l;){for(;3>y;){if(0===k)return n.he=f,n.de=y,t.Qt=k,t.te+=b-t.le,t.le=b,n.write=g,n.ke(t,e);e=0,k--,f|=(255&t.pe(b++))<<y,y+=8}r[vt[l++]]=7&f,f>>>=3,y-=3}for(;19>l;)r[vt[l++]]=0;if(u[0]=7,i=p.ae(r,u,a,d,t),0!=i)return-3==(e=i)&&(r=null,o=9),n.he=f,n.de=y,t.Qt=k,t.te+=b-t.le,t.le=b,n.write=g,n.ke(t,e);l=0,o=5;case 5:for(;i=c,258+(31&i)+(i>>5&31)>l;){let s,w;for(i=u[0];i>y;){if(0===k)return n.he=f,n.de=y,t.Qt=k,t.te+=b-t.le,t.le=b,n.write=g,n.ke(t,e);e=0,k--,f|=(255&t.pe(b++))<<y,y+=8}if(i=d[3*(a[0]+(f&at[i]))+1],w=d[3*(a[0]+(f&at[i]))+2],16>w)f>>>=i,y-=i,r[l++]=w;else{for(m=18==w?7:w-14,s=18==w?11:3;i+m>y;){if(0===k)return n.he=f,n.de=y,t.Qt=k,t.te+=b-t.le,t.le=b,n.write=g,n.ke(t,e);e=0,k--,f|=(255&t.pe(b++))<<y,y+=8}if(f>>>=i,y-=i,s+=f&at[m],f>>>=m,y-=m,m=l,i=c,m+s>258+(31&i)+(i>>5&31)||16==w&&1>m)return r=null,o=9,t.Zt="invalid bit length repeat",e=-3,n.he=f,n.de=y,t.Qt=k,t.te+=b-t.le,t.le=b,n.write=g,n.ke(t,e);w=16==w?r[m-1]:0;do{r[m++]=w}while(0!=--s);l=m}}if(a[0]=-1,A=[],C=[],V=[],B=[],A[0]=9,C[0]=6,i=c,i=p.we(257+(31&i),1+(i>>5&31),r,A,C,V,B,d,t),0!=i)return-3==i&&(r=null,o=9),e=i,n.he=f,n.de=y,t.Qt=k,t.te+=b-t.le,t.le=b,n.write=g,n.ke(t,e);w.init(A[0],C[0],d,V[0],d,B[0]),o=6;case 6:if(n.he=f,n.de=y,t.Qt=k,t.te+=b-t.le,t.le=b,n.write=g,1!=(e=w.be(n,t,e)))return n.ke(t,e);if(e=0,w.ge(t),b=t.le,k=t.Qt,f=n.he,y=n.de,g=n.write,v=g<n.read?n.read-g-1:n.end-g,0===h){o=0;break}o=7;case 7:if(n.write=g,e=n.ke(t,e),g=n.write,v=g<n.read?n.read-g-1:n.end-g,n.read!=n.write)return n.he=f,n.de=y,t.Qt=k,t.te+=b-t.le,t.le=b,n.write=g,n.ke(t,e);o=8;case 8:return e=1,n.he=f,n.de=y,t.Qt=k,t.te+=b-t.le,t.le=b,n.write=g,n.ke(t,e);case 9:return e=-3,n.he=f,n.de=y,t.Qt=k,t.te+=b-t.le,t.le=b,n.write=g,n.ke(t,e);default:return e=-2,n.he=f,n.de=y,t.Qt=k,t.te+=b-t.le,t.le=b,n.write=g,n.ke(t,e)}}},n.ge=t=>{n.reset(t,null),n.ye=null,d=null},n.me=(t,e,r)=>{n.ye.set(t.subarray(e,e+r),0),n.read=n.write=r},n.Se=()=>1==o?1:0}const St=[0,0,255,255];function zt(){const t=this;function e(t){return t&&t.ze?(t.te=t.ee=0,t.Zt=null,t.ze.mode=7,t.ze._e.reset(t,null),0):-2}t.mode=0,t.method=0,t.Ie=[0],t.Ae=0,t.marker=0,t.Ce=0,t.Ve=e=>(t._e&&t._e.ge(e),t._e=null,0),t.Be=(n,r)=>(n.Zt=null,t._e=null,8>r||r>15?(t.Ve(n),-2):(t.Ce=r,n.ze._e=new mt(n,1<<r),e(n),0)),t.it=(t,e)=>{let n,r;if(!t||!t.ze||!t.fe)return-2;const i=t.ze;for(e=4==e?-5:0,n=-5;;)switch(i.mode){case 0:if(0===t.Qt)return n;if(n=e,t.Qt--,t.te++,8!=(15&(i.method=t.pe(t.le++)))){i.mode=13,t.Zt="unknown compression method",i.marker=5;break}if(8+(i.method>>4)>i.Ce){i.mode=13,t.Zt="invalid win size",i.marker=5;break}i.mode=1;case 1:if(0===t.Qt)return n;if(n=e,t.Qt--,t.te++,r=255&t.pe(t.le++),((i.method<<8)+r)%31!=0){i.mode=13,t.Zt="incorrect header check",i.marker=5;break}if(0==(32&r)){i.mode=7;break}i.mode=2;case 2:if(0===t.Qt)return n;n=e,t.Qt--,t.te++,i.Ae=(255&t.pe(t.le++))<<24&4278190080,i.mode=3;case 3:if(0===t.Qt)return n;n=e,t.Qt--,t.te++,i.Ae+=(255&t.pe(t.le++))<<16&16711680,i.mode=4;case 4:if(0===t.Qt)return n;n=e,t.Qt--,t.te++,i.Ae+=(255&t.pe(t.le++))<<8&65280,i.mode=5;case 5:return 0===t.Qt?n:(n=e,t.Qt--,t.te++,i.Ae+=255&t.pe(t.le++),i.mode=6,2);case 6:return i.mode=13,t.Zt="need dictionary",i.marker=0,-2;case 7:if(n=i._e.be(t,n),-3==n){i.mode=13,i.marker=0;break}if(0==n&&(n=e),1!=n)return n;n=e,i._e.reset(t,i.Ie),i.mode=12;case 12:return t.Qt=0,1;case 13:return-3;default:return-2}},t.Ee=(t,e,n)=>{let r=0,i=n;if(!t||!t.ze||6!=t.ze.mode)return-2;const o=t.ze;return i<1<<o.Ce||(i=(1<<o.Ce)-1,r=n-i),o._e.me(e,r,i),o.mode=7,0},t.De=t=>{let n,r,i,o,s;if(!t||!t.ze)return-2;const f=t.ze;if(13!=f.mode&&(f.mode=13,f.marker=0),0===(n=t.Qt))return-5;for(r=t.le,i=f.marker;0!==n&&4>i;)t.pe(r)==St[i]?i++:i=0!==t.pe(r)?0:4-i,r++,n--;return t.te+=r-t.le,t.le=r,t.Qt=n,f.marker=i,4!=i?-3:(o=t.te,s=t.ee,e(t),t.te=o,t.ee=s,f.mode=7,0)},t.Ue=t=>t&&t.ze&&t.ze._e?t.ze._e.Se():-2}function _t(){}function It(t){const e=new _t,o=t&&t.rt?n.floor(2*t.rt):131072,s=new i(o);let f=!1;e.Be(),e.se=s,this.append=(t,n)=>{const c=[];let l,u,a=0,w=0,h=0;if(0!==t.length){e.le=0,e.fe=t,e.Qt=t.length;do{if(e.ue=0,e.ce=o,0!==e.Qt||f||(e.le=0,f=!0),l=e.it(0),f&&-5===l){if(0!==e.Qt)throw new r("inflating: bad input")}else if(0!==l&&1!==l)throw new r("inflating: "+e.Zt);if((f||1===l)&&e.Qt===t.length)throw new r("inflating: bad input");e.ue&&(e.ue===o?c.push(new i(s)):c.push(s.slice(0,e.ue))),h+=e.ue,n&&e.le>0&&e.le!=a&&(n(e.le),a=e.le)}while(e.Qt>0||0===e.ce);return c.length>1?(u=new i(h),c.forEach((t=>{u.set(t,w),w+=t.length}))):u=c[0]||new i(0),u}},this.flush=()=>{e.Ve()}}_t.prototype={Be:function(t){const e=this;return e.ze=new zt,t||(t=15),e.ze.Be(e,t)},it:function(t){const e=this;return e.ze?e.ze.it(e,t):-2},Ve:function(){const t=this;if(!t.ze)return-2;const e=t.ze.Ve(t);return t.ze=null,e},De:function(){const t=this;return t.ze?t.ze.De(t):-2},Ee:function(t,e){const n=this;return n.ze?n.ze.Ee(n,t,e):-2},pe:function(t){return this.fe[t]},Xt:function(t,e){return this.fe.subarray(t,t+e)}},self.initCodec=()=>{self.Deflate=ut,self.Inflate=It};\n'], { type: "text/javascript" })); t({ workerScripts: { inflate: [e], deflate: [e] } }) } })(vt), vt({ Deflate: S, Inflate: mt }) }, 13802: function (t) { "use strict"; t.exports = JSON.parse('[["8740",""],["8767",""],["87a1",""],["8840","",4,""],["88a1",""],["8940",""],["8943",""],["8946",""],["894c",""],["89a1",""],["89ab",""],["89b0",""],["89b5",""],["89c1",""],["89c5",""],["8a40",""],["8a43",""],["8a64",""],["8a76",""],["8aa1",""],["8aac",""],["8ab2",""],["8abb",""],["8ac9",""],["8ace",""],["8adf",""],["8af6",""],["8b40",""],["8b55",""],["8ba1",""],["8bde",""],["8c40",""],["8ca1",""],["8ca7",""],["8cc9",""],["8cce",""],["8ce6",""],["8d40",""],["8d42",""],["8da1",""],["8e40",""],["8ea1",""],["8f40",""],["8fa1",""],["9040",""],["90a1",""],["9140",""],["91a1",""],["9240",""],["92a1",""],["9340",""],["93a1",""],["9440",""],["94a1",""],["9540",""],["95a1",""],["9640",""],["96a1",""],["9740",""],["97a1",""],["9840",""],["98a1",""],["9940",""],["99a1",""],["9a40",""],["9aa1",""],["9b40",""],["9b62",""],["9ba1",""],["9c40",""],["9ca1",""],["9d40",""],["9da1",""],["9e40",""],["9ea1",""],["9ead",""],["9ec5",""],["9ef5",""],["9f40",""],["9f4f",""],["9fa1",""],["9fae",""],["9fb2",""],["9fc1",""],["9fc9",""],["9fdb",""],["9fe7",""],["9feb",""],["9ff0",""],["a040",""],["a055",""],["a058",""],["a05b",""],["a063",""],["a073",""],["a0a1",""],["a0a6",""],["a0ae",""],["a0b0",""],["a0d4",""],["a0e2",""],["a3c0","",31,""],["c6a1","",9,"",9,"",9,"",23],["c740","",58,""],["c7a1","",81,"",5,"",4],["c840","",26,"",25,""],["c8a1",""],["c8cd",""],["c8f5",""],["f9fe",""],["fa40",""],["faa1",""],["fb40",""],["fba1",""],["fc40",""],["fca1",""],["fd40",""],["fda1",""],["fe40",""],["fea1",""]]') }, 39227: function (t) { "use strict"; t.exports = JSON.parse('[["0","\\u0000",127,""],["8140","",5,"",9,"",6,""],["8180","",6,"",4,"",4,"",5,""],["8240","",4,"",8,"",4,"",11],["8280","",10,"",4,"",7,"",5,"",8,"",20,"",4,"",6,""],["8340","",17,"",5,"",10,"",4,"",9,""],["8380","",5,"",13,"",28,"",4,"",4,"",5],["8440","",5,"",5,""],["8480","",9,"",4,"",6,"",6,"",9,"",5,"",10,"",7,""],["8540","",9,""],["8580","",4,"",6,"",4,"",4,"",7,""],["8640","",4,"",5,"",4,"",5,""],["8680","",4,"",4,"",5,"",6,"",8,"",4,"",4,"",4,""],["8740","",7,"",11,"",4,"",4],["8780","",7,"",6,"",14,"",10,"",6,"",12,"",8,"",5,"",6],["8840","",9,"",4,"",4,""],["8880","",4,"",6,"",8,"",6,"",7,"",4,"",4,"",7],["8940","",5,"",6,"",4,"",5,"",4,"",16,""],["8980","",4,"",4,"",7,"",17,"",10,"",13,"",5,"",7,"",4,""],["8a40","",4,"",12,""],["8a80","",5,"",6,"",4,"",11,"",6,"",4,"",4,"",9,"",5],["8b40","",8,"",17,"",6,"",13,""],["8b80","",4,"",4,"",5,"",4,"",4,"",22,"",11,"",25,"",7,"",6],["8c40","",7,""],["8c80","",8,"",4,"",6,"",6,"",6,"",4,"",4,"",4],["8d40","",5,"",5,"",5,"",6,"",9,"",4],["8d80","",5,"",4,"",4,"",4,"",7,"",7,"",10,"",10,"",12,"",21,""],["8e40","",21,"",12,"",6,"",12,""],["8e80","",4,"",7,"",4,"",4,"",5,"",6,"",4,"",14,"",4,"",4,"",6],["8f40","",5,"",11,"",8,""],["8f80","",6,"",14,"",5,"",5,"",4,""],["9040","",4,"",4,"",6,""],["9080","",7,"",4,"",4,"",4,"",4,"",18,"",6],["9140","",6,"",6,"",18,"",4,""],["9180","",6,"",8,"",9,"",5,"",4,"",4,"",16,"",13,"",8,"",5,"",4,""],["9240","",6,"",5,""],["9280","",5,"",7,"",6,""],["9340","",6,"",4,"",4,"",5,""],["9380","",5,"",4,"",6,"",4,"",7,"",9,"",6,"",8,"",4,"",6,""],["9440","",24,"",7,"",7,"",4,"",8],["9480","",4,"",4,"",14,"",7,"",7,""],["9540","",4,"",4,"",6,""],["9580","",4,"",4,"",8,"",4,"",4,"",25,"",7,"",5,""],["9640","",5,"",4,""],["9680","",7,"",9,"",7,"",4,"",6,"",6,"",5],["9740","",7,"",8,"",7,"",9,""],["9780","",6,"",5,"",4,"",9,"",4,"",11,"",7,"",16,""],["9840","",4,"",5,"",9,""],["9880","",7,"",5,"",11,"",9,"",9,"",11,"",5,"",5,"",6,"",4,"",7,"",6,""],["9940","",4,"",10,"",6,"",8,"",4,"",7,"",5],["9980","",114,"",6],["9a40","",11,"",7,"",13,""],["9a80","",4,"",7,"",7,"",6,"",4,"",4,"",7,"",6,"",4,"",4,""],["9b40","",4,""],["9b80","",5,"",4,"",4,"",5,""],["9c40","",7,""],["9c80","",7,"",7,"",10,"",14,"",4,"",6,"",5],["9d40","",7,"",4,"",9,"",6,""],["9d80","",9,"",5,"",6,"",12,"",4,"",10,"",5,"",5,"",6,"",10,""],["9e40","",7,"",32,"",7,"",6,"",6],["9e80","",9,"",17,"",13,"",11,"",12,"",12,""],["9f40","",6,"",10,"",4,"",10,"",7,""],["9f80","",13,"",12,"",4,"",4,"",5,"",4,"",4,"",6,"",5,"",8,"",9,"",4],["a040","",9,"",5,"",9,"",11,"",19],["a080","",9,"",6,"",4,"",11,"",11,"",6,""],["a1a1","",7,""],["a2a1","",9],["a2b1","",19,"",19,"",9],["a2e5","",9],["a2f1","",11],["a3a1","",88,""],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a6e0",""],["a6ee",""],["a6f4",""],["a7a1","",5,"",25],["a7d1","",5,"",25],["a840","",35,"",6],["a880","",7,""],["a8a1",""],["a8bd",""],["a8c0",""],["a8c5","",36],["a940","",8,""],["a959",""],["a95c",""],["a960","",9,"",8],["a980","",4,""],["a996",""],["a9a4","",75],["aa40","",5,"",5,"",8],["aa80","",7,"",10,""],["ab40","",11,"",4,"",5,"",4],["ab80","",6,"",4],["ac40","",10,"",8,"",5,"",4,"",11],["ac80","",6,"",12,"",4,""],["ad40","",10,"",7,"",15,"",12],["ad80","",9,"",8,"",6,""],["ae40","",6,"",7,"",4,""],["ae80","",7,"",6,"",4,""],["af40","",4,""],["af80",""],["b040","",6,"",5,"",4,"",6,"",7,""],["b080","",7,"",8,"",9,""],["b140","",4,"",7,"",10,""],["b180","",4,"",7,"",7,""],["b240","",11,"",5,"",11,"",4],["b280","",12,"",8,"",4,""],["b340","",5,""],["b380","",11,"",7,"",6,""],["b440","",7,"",9],["b480","",4,"",5,"",6,""],["b540","",5,"",9,"",4,"",14,"",4,"",8,""],["b580","",6,"",4,""],["b640","",6,"",11,"",10,"",4,"",5,""],["b680","",6,"",4,""],["b740","",14,"",5,"",9,"",4,"",16],["b780","",6,""],["b840","",4,"",10,"",10,"",9,"",5,""],["b880","",4,""],["b940","",5,"",10,"",6,""],["b980","",7,""],["ba40","",4,"",4,"",7,"",5,""],["ba80","",4,"",5,"",12,"",5,""],["bb40","",9,"",36,"",5,"",9],["bb80","",6,"",4,""],["bc40","",6,"",6,"",5,"",7,"",13,"",5],["bc80","",14,"",6,""],["bd40","",54,"",7],["bd80","",32,""],["be40","",12,"",6,"",42],["be80","",32,""],["bf40","",62],["bf80","",4,"",4,"",21,""],["c040","",35,"",23,""],["c080","",6,"",9,""],["c140","",4,"",7,"",4,"",4,"",6,""],["c180","",4,"",4,"",5,""],["c240","",6,"",5,""],["c280","",13,"",5,"",11,""],["c340","",5,"",4,"",6,""],["c380","",12,"",4,""],["c440","",5,"",4,"",4,"",5,"",4,""],["c480","",7,"",5,"",6,""],["c540","",14,"",4,"",5,"",4,"",5,""],["c580","",7,"",7,""],["c640",""],["c680","",4,"",9,""],["c740","",4,"",4,"",6,"",6,"",6,""],["c780",""],["c840","",4,"",5,"",5,"",7,"",5,"",7,""],["c880","",6,"",4,"",4,""],["c940","",4,"",7,"",12,""],["c980","",4,"",4,"",10,""],["ca40","",8,"",8,"",9,"",4,"",10],["ca80","",4,"",8,""],["cb40","",6,"",10,"",6,"",5,"",6,"",6,"",4,""],["cb80","",5,"",6,"",14,""],["cc40","",4,"",10,"",15,"",13,""],["cc80","",11,"",4,"",7,""],["cd40","",6,"",6,"",4,"",5,"",4,"",4,""],["cd80",""],["ce40","",6,"",5,"",7,""],["ce80","",4,"",6,"",4,""],["cf40","",4,"",4,"",6,"",9],["cf80","",5,"",7,"",4,""],["d040","",13,"",5,"",5,"",5,"",6,""],["d080","",4,"",4,"",5,""],["d140","",4,"",4,"",6,"",5],["d180","",4,"",4,"",4,""],["d240","",8,"",24,"",5,"",19,""],["d280","",26,""],["d340","",30,"",6],["d380","",4,"",5,"",21,""],["d440","",31,"",8,"",21],["d480","",25,"",6,""],["d540","",7,"",7,"",46],["d580","",32,""],["d640","",34,"",27],["d680","",30,""],["d740","",31,"",4,"",25],["d780","",24,""],["d840","",8,"",7,"",5,"",6,"",6,"",6,""],["d880","",6,"",20,""],["d940","",62],["d980","",32,""],["da40","",14,"",8,"",4,"",9,""],["da80","",12,""],["db40","",6,"",7,"",4,""],["db80","",4,"",5,"",11,""],["dc40","",4,"",6,"",6,"",11,"",6,"",7],["dc80","",10,"",21,""],["dd40","",62],["dd80","",32,""],["de40","",32,""],["de80","",4,""],["df40","",5,"",4,"",4,"",5,"",4,"",6,""],["df80","",4,""],["e040","",19,""],["e080","",10,"",6,"",8,""],["e140","",4,"",6,"",5,"",5,""],["e180","",10,"",9,"",8,""],["e240","",62],["e280","",32,"",5,""],["e340","",45,"",16],["e380","",7,"",24,""],["e440","",5,"",24,"",31],["e480","",32,""],["e540","",51,"",10],["e580","",31,""],["e640","",34,"",27],["e680","",29,""],["e740","",7,"",54],["e780","",32,"",6,"",4,""],["e840","",14,"",43,""],["e880","",20,""],["e940","",7,"",42],["e980","",32,""],["ea40","",27,"",6,""],["ea80","",4,"",12,""],["eb40","",9,"",7,"",9,"",6,""],["eb80","",4,""],["ec40","",8,"",4,"",18,"",7],["ec80","",4,"",7,"",4,"",4,""],["ed40","",6,"",46],["ed80","",4,"",23,""],["ee40","",62],["ee80","",32,"",4,"",6,""],["ef40","",5,"",37,"",4],["ef80","",30,"",4,"",8,""],["f040","",4,"",28,"",26],["f080","",9,"",12,"",4,"",6,""],["f140","",10,"",47],["f180","",32,""],["f240","",62],["f280","",32,""],["f340","",17,"",6,"",4,""],["f380","",8,"",6,""],["f440","",5,"",10,"",10,"",7,"",5],["f480","",32,""],["f540","",62],["f580","",32,""],["f640","",62],["f680","",32,"",5,"",5,"",4,"",7,""],["f740","",62],["f780","",4,"",4,""],["f840","",62],["f880","",32],["f940","",62],["f980","",32],["fa40","",62],["fa80","",32],["fb40","",27,"",9,""],["fb80","",5,"",8,"",5,""],["fc40","",8,"",4,"",8,"",6],["fc80","",4,"",5,"",8,""],["fd40","",4,"",4,"",10,"",38],["fd80","",5,"",11,"",4,""],["fe40",""]]') }, 64359: function (t) { "use strict"; t.exports = JSON.parse('[["0","\\u0000",127],["8141","",4,"",6,""],["8161","",9,"",5,""],["8181","",18,"",4,"",6,"",5,"",6,"",7,"",7,"",4,"",4,""],["8241","",7,"",5],["8261","",6,"",5,""],["8281","",7,"",7,"",4,"",10,"",5,"",17,"",7,"",6,"",7,"",18],["8341","",5,"",5,"",7],["8361","",18,""],["8381","",4,"",6,"",5,"",5,"",46,"",6,"",5,"",8],["8441","",5,"",8],["8461","",18],["8481","",7,"",6,"",5,"",10,"",5,"",18,"",5,"",6,"",5,"",26,""],["8541","",5,"",4,"",6,"",4],["8561","",5,"",5,"",6,""],["8581","",6,"",6,"",9,"",26,"",29,"",6,"",5,""],["8641","",6,"",5,""],["8661","",6,"",10],["8681","",22,"",4,"",6,"",5,"",6,"",22,"",4,""],["8741","",9,"",15],["8761","",18,""],["8781","",5,"",7,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",4],["8841","",4,"",5,"",6,"",4],["8861","",4,""],["8881","",15,"",4,"",6,"",5,"",54,""],["8941","",6,"",5,""],["8961","",10,"",5,""],["8981","",21,"",18,"",18,"",6,"",6,"",7,"",15],["8a41","",10,"",6,""],["8a61","",4,"",18,""],["8a81","",4,"",19,"",5,"",7,"",5,"",6,"",5,"",4,"",5,"",26,""],["8b41","",5,"",4,"",6,""],["8b61","",6,"",8],["8b81","",52,"",4,"",6,"",5,"",18,"",18],["8c41","",15,"",4],["8c61","",6,"",5,"",6,"",5],["8c81","",12,"",26,"",50,"",5,"",16],["8d41","",16,"",8],["8d61","",17,""],["8d81","",4,"",33,"",6,"",7,"",6,"",9,"",6,"",5,"",6,""],["8e41","",6,"",5,"",8],["8e61","",4,"",19],["8e81","",13,"",6,"",4,"",6,"",5,"",6,"",5,"",11,"",7,"",6,"",5,"",7],["8f41","",7,"",17],["8f61","",7,"",6,"",4],["8f81","",5,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",5],["9041","",6,"",5,""],["9061","",5,"",15],["9081","",12,"",6,"",5,"",4,"",6,"",4,"",5,"",11,"",33,""],["9141","",6,"",5],["9161","",9,"",5],["9181","",20,"",4,"",5,"",14,"",33,"",7,"",5,"",6],["9241","",7,"",4,""],["9261","",7,"",7,"",4],["9281","",21,"",18,"",6,"",7,"",6,"",35,""],["9341","",4,""],["9361","",6,"",8],["9381","",37,"",4,"",4,"",6,"",5,"",7,"",22,""],["9441","",5,"",5,"",8],["9461","",5,"",6,"",12],["9481","",5,"",6,"",6,"",9,"",22,"",4,"",6,"",10,"",6,"",24],["9541","",11,"",5,""],["9561","",6,"",5,""],["9581","",6,"",35,"",4,"",4,"",4,"",6,"",5,"",13,"",14],["9641","",23,""],["9661","",6,"",5,"",8],["9681","",10,"",5,"",13,"",33,"",6,"",44],["9741","",16,"",8],["9761","",17,"",7],["9781","",11,"",5,"",6,"",89,""],["9841","",16,"",5,""],["9861","",6,"",15],["9881","",21,"",6,"",5,"",4,"",6,"",5,"",6,"",5,"",6,"",5,""],["9941","",6,"",5,""],["9961","",6,"",5,""],["9981","",8,"",5,"",4,"",11,"",5,"",6,"",6,"",6,"",7,"",6,"",5,""],["9a41","",16],["9a61","",6,"",6,""],["9a81","",4,"",6,"",5,"",5,"",6,"",5,"",5,"",33,"",5,"",6,""],["9b41","",6,"",8],["9b61","",17,"",7],["9b81","",25,"",4,"",5,"",50,"",22,""],["9c41","",4,"",5,"",5],["9c61","",8,"",6,"",9],["9c81","",8,"",6,"",6,"",9,"",26,"",6,"",5,"",18,"",6,"",12],["9d41","",13,"",8],["9d61","",25],["9d81","",8,"",5,"",9,"",6,"",10,"",6,"",5,"",6,"",5,""],["9e41","",7,"",9,""],["9e61","",4,"",6,""],["9e81","",6,"",6,"",6,"",5,"",10,"",5,"",6,"",5,"",6,""],["9f41","",5,"",4,"",5,""],["9f61","",6,"",5,""],["9f81","",4,"",5,"",6,"",5,"",6,"",4,"",6,"",7,"",4,"",4,""],["a041","",5,"",6,""],["a061","",5,"",13],["a081","",4,"",4,"",4,"",6,"",5,"",6,"",5,"",26,"",4,"",5,"",7,""],["a141","",18,""],["a161","",6,"",5,""],["a181","",14,"",5,"",4,"",9,""],["a241","",5,"",18],["a261","",6,"",18],["a281","",7,"",6,"",7,""],["a341","",6,"",10,""],["a361","",6,"",16],["a381","",16,"",4,"",58,"",32,""],["a441","",5,""],["a461","",5,"",12],["a481","",28,"",93],["a541","",4,"",6,"",5,""],["a561","",17,"",5,""],["a581","",16,"",14,"",9],["a5b0","",9],["a5c1","",16,"",6],["a5e1","",16,"",6],["a641","",19,""],["a661","",5,"",5,"",6],["a681","",6,"",18,"",7],["a741","",4,"",6,"",7],["a761","",22,""],["a781","",6,"",5,"",7,"",9,"",9,"",4,"",5,"",4,""],["a841","",10,"",14],["a861","",18,"",6],["a881","",19,"",11,""],["a8a6",""],["a8a8",""],["a8b1","",27,"",25,"",14,""],["a941","",14,"",10],["a961","",18],["a981","",14,"",6,"",27,"",25,"",14,""],["aa41","",6,"",4,""],["aa61","",4,"",5,"",6,""],["aa81","",29,"",82],["ab41","",6,"",5,""],["ab61","",6,"",5,"",5],["ab81","",8,"",6,"",12,"",85],["ac41","",5,"",6,""],["ac61","",11,"",4],["ac81","",28,"",5,"",25],["acd1","",5,"",25],["ad41","",6,"",5,"",7],["ad61","",6,"",10,""],["ad81","",5,"",18,""],["ae41","",5,"",16],["ae61","",5,"",6,"",4],["ae81","",6,"",5,""],["af41","",19],["af61","",13,"",5,""],["af81","",5,"",6,"",5,""],["b041","",5,"",5,"",12],["b061","",5,"",19],["b081","",13,"",6,"",5,"",7,"",4,""],["b141","",6,"",5,""],["b161","",6,"",5,"",11],["b181","",14,"",6,""],["b241","",6,"",5,""],["b261","",18,"",5,""],["b281","",5,"",18,"",6,""],["b341","",19,""],["b361","",5,"",5,"",5],["b381","",5,"",5,"",19,"",4,""],["b441","",5,"",6,"",5],["b461","",6,"",10,""],["b481","",6,"",18,"",4,"",4,""],["b541","",14,"",5],["b561","",5,"",5,"",4],["b581","",6,"",5,"",11,""],["b641","",7,"",17],["b661","",15,""],["b681","",5,"",6,"",5,""],["b741","",13,"",6,""],["b761","",20,""],["b781","",6,"",14,""],["b841","",7,"",17],["b861","",8,"",13],["b881","",5,"",24,"",4,""],["b941","",6,"",5,""],["b961","",14,"",6,""],["b981","",22,"",4,"",4,""],["ba41","",5,"",6,""],["ba61","",5,"",4,"",5],["ba81","",6,"",9,""],["bb41","",4,"",5,"",4,""],["bb61","",6,"",5,""],["bb81","",31,""],["bc41","",17,""],["bc61","",5,"",6,""],["bc81","",4,"",6,"",5,"",5,"",4,""],["bd41","",7,"",7,""],["bd61","",5,"",13],["bd81","",5,"",25,""],["be41","",7,"",14],["be61","",7,"",7,""],["be81","",4,"",4,"",5,"",8,"",6,""],["bf41","",10,"",14],["bf61","",18,""],["bf81","",5,"",7,"",6,"",5,""],["c041","",5,"",6,"",5],["c061","",25],["c081","",6,"",5,"",7,""],["c141","",5,"",6,""],["c161","",19,""],["c181","",31,""],["c241","",4,"",5,""],["c261","",4,"",5,"",6,""],["c281","",5,"",7,"",9,""],["c341","",4],["c361","",4,"",5,"",11],["c381","",5,"",7,"",5,""],["c441","",7,"",7,""],["c461","",5,"",4],["c481","",5,"",11,""],["c541","",6,"",5,""],["c561","",6,"",5,"",4],["c581","",6,"",5,""],["c641","",6,"",5],["c6a1",""],["c7a1",""],["c8a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1","",5,"",4,""],["d2a1","",4,"",5,"",10,"",7,"",5,""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f5a1",""],["f6a1",""],["f7a1",""],["f8a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fda1",""]]') }, 76636: function (t) { "use strict"; t.exports = JSON.parse('[["0","\\u0000",127],["a140",""],["a1a1","",4,""],["a240","",7,""],["a2a1","",9,"",9,"",8,"",25,"",21],["a340","",16,"",6,"",16,"",6,"",10],["a3a1","",25,""],["a3e1",""],["a440",""],["a4a1",""],["a540",""],["a5a1",""],["a640",""],["a6a1",""],["a740",""],["a7a1",""],["a840",""],["a8a1",""],["a940",""],["a9a1",""],["aa40",""],["aaa1",""],["ab40",""],["aba1",""],["ac40",""],["aca1",""],["ad40",""],["ada1",""],["ae40",""],["aea1",""],["af40",""],["afa1",""],["b040",""],["b0a1",""],["b140",""],["b1a1",""],["b240",""],["b2a1",""],["b340",""],["b3a1",""],["b440",""],["b4a1",""],["b540",""],["b5a1",""],["b640",""],["b6a1",""],["b740",""],["b7a1",""],["b840",""],["b8a1",""],["b940",""],["b9a1",""],["ba40",""],["baa1",""],["bb40",""],["bba1",""],["bc40",""],["bca1",""],["bd40",""],["bda1",""],["be40",""],["bea1",""],["bf40",""],["bfa1",""],["c040",""],["c0a1",""],["c140",""],["c1a1",""],["c240",""],["c2a1",""],["c340",""],["c3a1",""],["c440",""],["c4a1",""],["c540",""],["c5a1",""],["c640",""],["c940",""],["c9a1",""],["ca40",""],["caa1",""],["cb40",""],["cba1",""],["cc40",""],["cca1",""],["cd40",""],["cda1",""],["ce40",""],["cea1",""],["cf40",""],["cfa1",""],["d040",""],["d0a1",""],["d140",""],["d1a1",""],["d240",""],["d2a1",""],["d340",""],["d3a1",""],["d440",""],["d4a1",""],["d540",""],["d5a1",""],["d640",""],["d6a1",""],["d740",""],["d7a1",""],["d840",""],["d8a1",""],["d940",""],["d9a1",""],["da40",""],["daa1",""],["db40",""],["dba1",""],["dc40",""],["dca1",""],["dd40",""],["dda1",""],["de40",""],["dea1",""],["df40",""],["dfa1",""],["e040",""],["e0a1",""],["e140",""],["e1a1",""],["e240",""],["e2a1",""],["e340",""],["e3a1",""],["e440",""],["e4a1",""],["e540",""],["e5a1",""],["e640",""],["e6a1",""],["e740",""],["e7a1",""],["e840",""],["e8a1",""],["e940",""],["e9a1",""],["ea40",""],["eaa1",""],["eb40",""],["eba1",""],["ec40",""],["eca1",""],["ed40",""],["eda1",""],["ee40",""],["eea1",""],["ef40",""],["efa1",""],["f040",""],["f0a1",""],["f140",""],["f1a1",""],["f240",""],["f2a1",""],["f340",""],["f3a1",""],["f440",""],["f4a1",""],["f540",""],["f5a1",""],["f640",""],["f6a1",""],["f740",""],["f7a1",""],["f840",""],["f8a1",""],["f940",""],["f9a1",""]]') }, 39715: function (t) { "use strict"; t.exports = JSON.parse('[["0","\\u0000",127],["8ea1","",62],["a1a1","",9,""],["a2a1",""],["a2ba",""],["a2ca",""],["a2dc",""],["a2f2",""],["a2fe",""],["a3b0","",9],["a3c1","",25],["a3e1","",25],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a7a1","",5,"",25],["a7d1","",5,"",25],["a8a1",""],["ada1","",19,"",9],["adc0",""],["addf","",4,""],["b0a1",""],["b1a1",""],["b2a1",""],["b3a1",""],["b4a1",""],["b5a1",""],["b6a1",""],["b7a1",""],["b8a1",""],["b9a1",""],["baa1",""],["bba1",""],["bca1",""],["bda1",""],["bea1",""],["bfa1",""],["c0a1",""],["c1a1",""],["c2a1",""],["c3a1",""],["c4a1",""],["c5a1",""],["c6a1",""],["c7a1",""],["c8a1",""],["c9a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1",""],["d2a1",""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fcf1","",9,""],["8fa2af",""],["8fa2c2",""],["8fa2eb",""],["8fa6e1",""],["8fa6e7",""],["8fa6e9",""],["8fa6ec",""],["8fa6f1",""],["8fa7c2","",10,""],["8fa7f2","",10,""],["8fa9a1",""],["8fa9a4",""],["8fa9a6",""],["8fa9a8",""],["8fa9ab",""],["8fa9af",""],["8fa9c1",""],["8faaa1",""],["8faaba",""],["8faba1",""],["8fabbd",""],["8fabc5",""],["8fb0a1",""],["8fb1a1",""],["8fb2a1","",4,""],["8fb3a1",""],["8fb4a1",""],["8fb5a1",""],["8fb6a1","",5,"",4,""],["8fb7a1","",4,""],["8fb8a1",""],["8fb9a1",""],["8fbaa1","",4,""],["8fbba1",""],["8fbca1","",4,""],["8fbda1","",4,""],["8fbea1","",4,""],["8fbfa1",""],["8fc0a1",""],["8fc1a1",""],["8fc2a1",""],["8fc3a1","",4,""],["8fc4a1",""],["8fc5a1",""],["8fc6a1",""],["8fc7a1",""],["8fc8a1",""],["8fc9a1","",4,"",4,""],["8fcaa1",""],["8fcba1",""],["8fcca1","",9,""],["8fcda1","",5,""],["8fcea1","",6,""],["8fcfa1",""],["8fd0a1",""],["8fd1a1",""],["8fd2a1","",5],["8fd3a1",""],["8fd4a1","",4,""],["8fd5a1",""],["8fd6a1",""],["8fd7a1",""],["8fd8a1",""],["8fd9a1","",4,"",6,""],["8fdaa1","",4,""],["8fdba1","",6,""],["8fdca1","",4,""],["8fdda1","",4,""],["8fdea1","",4,""],["8fdfa1",""],["8fe0a1",""],["8fe1a1","",4,""],["8fe2a1",""],["8fe3a1","",5,"",4,""],["8fe4a1","",4,""],["8fe5a1","",4,""],["8fe6a1",""],["8fe7a1",""],["8fe8a1","",4,""],["8fe9a1","",4],["8feaa1","",4,""],["8feba1","",4,""],["8feca1",""],["8feda1","",4,"",4,""]]') }, 41846: function (t) { "use strict"; t.exports = JSON.parse('{"uChars":[128,165,169,178,184,216,226,235,238,244,248,251,253,258,276,284,300,325,329,334,364,463,465,467,469,471,473,475,477,506,594,610,712,716,730,930,938,962,970,1026,1104,1106,8209,8215,8218,8222,8231,8241,8244,8246,8252,8365,8452,8454,8458,8471,8482,8556,8570,8596,8602,8713,8720,8722,8726,8731,8737,8740,8742,8748,8751,8760,8766,8777,8781,8787,8802,8808,8816,8854,8858,8870,8896,8979,9322,9372,9548,9588,9616,9622,9634,9652,9662,9672,9676,9680,9702,9735,9738,9793,9795,11906,11909,11913,11917,11928,11944,11947,11951,11956,11960,11964,11979,12284,12292,12312,12319,12330,12351,12436,12447,12535,12543,12586,12842,12850,12964,13200,13215,13218,13253,13263,13267,13270,13384,13428,13727,13839,13851,14617,14703,14801,14816,14964,15183,15471,15585,16471,16736,17208,17325,17330,17374,17623,17997,18018,18212,18218,18301,18318,18760,18811,18814,18820,18823,18844,18848,18872,19576,19620,19738,19887,40870,59244,59336,59367,59413,59417,59423,59431,59437,59443,59452,59460,59478,59493,63789,63866,63894,63976,63986,64016,64018,64021,64025,64034,64037,64042,65074,65093,65107,65112,65127,65132,65375,65510,65536],"gbChars":[0,36,38,45,50,81,89,95,96,100,103,104,105,109,126,133,148,172,175,179,208,306,307,308,309,310,311,312,313,341,428,443,544,545,558,741,742,749,750,805,819,820,7922,7924,7925,7927,7934,7943,7944,7945,7950,8062,8148,8149,8152,8164,8174,8236,8240,8262,8264,8374,8380,8381,8384,8388,8390,8392,8393,8394,8396,8401,8406,8416,8419,8424,8437,8439,8445,8482,8485,8496,8521,8603,8936,8946,9046,9050,9063,9066,9076,9092,9100,9108,9111,9113,9131,9162,9164,9218,9219,11329,11331,11334,11336,11346,11361,11363,11366,11370,11372,11375,11389,11682,11686,11687,11692,11694,11714,11716,11723,11725,11730,11736,11982,11989,12102,12336,12348,12350,12384,12393,12395,12397,12510,12553,12851,12962,12973,13738,13823,13919,13933,14080,14298,14585,14698,15583,15847,16318,16434,16438,16481,16729,17102,17122,17315,17320,17402,17418,17859,17909,17911,17915,17916,17936,17939,17961,18664,18703,18814,18962,19043,33469,33470,33471,33484,33485,33490,33497,33501,33505,33513,33520,33536,33550,37845,37921,37948,38029,38038,38064,38065,38066,38069,38075,38076,38078,39108,39109,39113,39114,39115,39116,39265,39394,189000]}') }, 41689: function (t) { "use strict"; t.exports = JSON.parse('[["a140","",62],["a180","",32],["a240","",62],["a280","",32],["a2ab","",5],["a2e3",""],["a2ef",""],["a2fd",""],["a340","",62],["a380","",31,""],["a440","",62],["a480","",32],["a4f4","",10],["a540","",62],["a580","",32],["a5f7","",7],["a640","",62],["a680","",32],["a6b9","",7],["a6d9","",6],["a6ec",""],["a6f3",""],["a6f6","",8],["a740","",62],["a780","",32],["a7c2","",14],["a7f2","",12],["a896","",10],["a8bc",""],["a8bf",""],["a8c1",""],["a8ea","",20],["a958",""],["a95b",""],["a95d",""],["a989","",11],["a997","",12],["a9f0","",14],["aaa1","",93],["aba1","",93],["aca1","",93],["ada1","",93],["aea1","",93],["afa1","",93],["d7fa","",4],["f8a1","",93],["f9a1","",93],["faa1","",93],["fba1","",93],["fca1","",93],["fda1","",93],["fe50",""],["fe80","",6,"",93],["8135f437",""]]') }, 39372: function (t) { "use strict"; t.exports = JSON.parse('[["0","\\u0000",128],["a1","",62],["8140","",9,""],["8180",""],["81b8",""],["81c8",""],["81da",""],["81f0",""],["81fc",""],["824f","",9],["8260","",25],["8281","",25],["829f","",82],["8340","",62],["8380","",22],["839f","",16,"",6],["83bf","",16,"",6],["8440","",5,"",25],["8470","",5,"",7],["8480","",17],["849f",""],["8740","",19,"",9],["875f",""],["877e",""],["8780","",4,""],["889f",""],["8940",""],["8980",""],["8a40",""],["8a80",""],["8b40",""],["8b80",""],["8c40",""],["8c80",""],["8d40",""],["8d80",""],["8e40",""],["8e80",""],["8f40",""],["8f80",""],["9040",""],["9080",""],["9140",""],["9180",""],["9240",""],["9280",""],["9340",""],["9380",""],["9440",""],["9480",""],["9540",""],["9580",""],["9640",""],["9680",""],["9740",""],["9780",""],["9840",""],["989f",""],["9940",""],["9980",""],["9a40",""],["9a80",""],["9b40",""],["9b80",""],["9c40",""],["9c80",""],["9d40",""],["9d80",""],["9e40",""],["9e80",""],["9f40",""],["9f80",""],["e040",""],["e080",""],["e140",""],["e180",""],["e240",""],["e280",""],["e340",""],["e380",""],["e440",""],["e480",""],["e540",""],["e580",""],["e640",""],["e680",""],["e740",""],["e780",""],["e840",""],["e880",""],["e940",""],["e980",""],["ea40",""],["ea80",""],["ed40",""],["ed80",""],["ee40",""],["ee80",""],["eeef","",9,""],["f040","",62],["f080","",124],["f140","",62],["f180","",124],["f240","",62],["f280","",124],["f340","",62],["f380","",124],["f440","",62],["f480","",124],["f540","",62],["f580","",124],["f640","",62],["f680","",124],["f740","",62],["f780","",124],["f840","",62],["f880","",124],["f940",""],["fa40","",9,"",9,""],["fa80",""],["fb40",""],["fb80",""],["fc40",""]]') }
}]);